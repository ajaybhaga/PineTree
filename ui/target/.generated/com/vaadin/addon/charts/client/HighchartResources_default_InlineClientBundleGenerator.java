package com.vaadin.addon.charts.client;

import com.google.gwt.core.client.GWT;
import com.google.gwt.resources.client.ResourcePrototype;

public class HighchartResources_default_InlineClientBundleGenerator implements com.vaadin.addon.charts.client.HighchartResources {
  private static HighchartResources_default_InlineClientBundleGenerator _instance0 = new HighchartResources_default_InlineClientBundleGenerator();
  private void defaultThemeInitializer() {
    defaultTheme = new com.google.gwt.resources.client.TextResource() {
      // jar:file:/Users/ajaybhaga/.m2/repository/com/vaadin/addon/vaadin-charts/1.0.0/vaadin-charts-1.0.0.jar!/com/vaadin/addon/charts/client/vaadintheme.js
      public String getText() {
        return "Highcharts.setOptions({\n	\"colors\" : [ \"#4A7093\", \"#49CFE5\", \"#FFBC41\", \"#C24758\", \"#77AA54\",\n			\"#7071C8\", \"#C58FBA\", \"#B5B9C6\" ],\n	\"chart\" : {\n		\"backgroundColor\" : \"#FFFFFF\",\n		\"plotBackgroundColor\" : \"rgba(255,255,255,0.00)\",\n		\"plotBackgroundImage\" : \"\",\n		\"plotShadow\" : false,\n		\"plotBorderWidth\" : 0,\n		\"className\" : \"vaadin-chart\",\n		\"borderRadius\" : 0,\n		\"style\" : {\n			\"fontFamily\" : \"Arial\",\n			\"fontSize\" : \"12px\"\n		}\n	},\n	\"title\" : {\n		\"style\" : {\n			\"color\" : \"#44698B\",\n			\"fontWeight\" : \"bold\",\n			\"fontSize\" : \"16px\"\n		}\n	},\n	\"subtitle\" : {\n		\"style\" : {\n			\"color\" : \"#979797\",\n			\"fontWeight\" : \"normal\"\n		}\n	},\n	\"xAxis\" : {\n		\"lineColor\" : \"#E5E5E5\",\n		\"lineWidth\" : 1,\n		\"tickColor\" : \"#979797\",\n		\"gridLineColor\" : \"#979797\",\n		\"alternateGridColor\" : \"rgba(255,255,255,0.00)\",\n		\"title\" : {\n			\"style\" : {\n				\"color\" : \"#44698B\",\n				\"fontWeight\" : \"bold\"\n			}\n		},\n		\"subtitle\" : {\n			\"style\" : {\n				\"color\" : \"#979797\",\n				\"fontWeight\" : \"normal\",\n				\"fontSize\" : \"10px\"\n			}\n		},\n		\"labels\" : {\n			\"style\" : {\n				\"color\" : \"#979797\",\n				\"fontWeight\" : \"normal\"\n			}\n		}\n	},\n	\"yAxis\" : {\n		\"lineColor\" : \"#979797\",\n		\"lineWidth\" : 0,\n		\"tickColor\" : \"#979797\",\n		\"gridLineColor\" : \"#E5E5E5\",\n		\"alternateGridColor\" : \"rgba(0,0,0,0.02)\",\n		\"title\" : {\n			\"style\" : {\n				\"color\" : \"#44698B\",\n				\"fontWeight\" : \"bold\"\n			}\n		},\n		\"subtitle\" : {\n			\"style\" : {\n				\"color\" : \"#979797\",\n				\"fontWeight\" : \"normal\",\n				\"fontSize\" : \"10px\"\n			}\n		},\n		\"labels\" : {\n			\"style\" : {\n				\"color\" : \"#979797\",\n				\"fontWeight\" : \"normal\"\n			}\n		}\n	},\n	\"labels\" : {\n		\"style\" : {\n			\"color\" : \"#979797\"\n		}\n	},\n	\"legend\" : {\n		\"borderColor\" : \"#E5E5E5\",\n		\"borderRadius\" : 2,\n		\"backgroundColor\" : \"rgba(0,0,0,0.02)\",\n		\"itemStyle\" : {\n			\"color\" : \"#555555\"\n		},\n		\"itemHoverStyle\" : {\n			\"color\" : \"#000000\"\n		},\n		\"itemHiddenStyle\" : {\n			\"color\" : \"#808080\"\n		}\n	},\n	\"tooltip\" : {\n		\"backgroundColor\" : \"#FFFFFF\",\n		\"borderWidth\" : 1,\n		\"borderRadius\" : 2,\n		\"style\" : {\n			\"color\" : \"#44698B\"\n		}\n	},\n	\"plotOptions\" : {\n		\"bar\" : {},\n		\"area\" : {},\n		\"pie\" : {},\n		\"line\" : {\n			\"lineWidth\" : 1\n		},\n		\"column\" : {},\n		\"spline\" : {},\n		\"series\" : {}\n	},\n	\"credits\" : {\n		\"text\" : \"Vaadin Charts\",\n		\"href\" : \"https://vaadin.com/add-ons/charts\",\n		\"style\" : {\n			\"color\" : \"#808080\",\n			\"fontSize\" : \"10px\"\n		}\n	}\n});\n\n// Workaround for #10999, TODO check if this is generic Vaadin layout issue\nif (window.matchMedia && /chrom(e|ium)/.test(navigator.userAgent.toLowerCase())) {\n	var mediaQueryList = window.matchMedia('print');\n	var inprintmode = false;\n	mediaQueryList.addListener(function(mql) {\n		if (mql.matches) {\n			inprintmode = true;\n		} else {\n			if (inprintmode) {\n				setTimeout(function() {\n					// Force layout phase just after HC has returned from print mode\n					// Without this Vaadin breaks layouts in Chrome, layout\n					// phase is once executed with 0,0 size and then not fixed\n					// afterwards\n					vaadin.forceLayout();\n				}, 1010);\n			}\n		}\n	});\n}\n";
      }
      public String getName() {
        return "defaultTheme";
      }
    }
    ;
  }
  private static class defaultThemeInitializer {
    static {
      _instance0.defaultThemeInitializer();
    }
    static com.google.gwt.resources.client.TextResource get() {
      return defaultTheme;
    }
  }
  public com.google.gwt.resources.client.TextResource defaultTheme() {
    return defaultThemeInitializer.get();
  }
  private void exportingInitializer() {
    exporting = new com.google.gwt.resources.client.TextResource() {
      // jar:file:/Users/ajaybhaga/.m2/repository/com/vaadin/addon/vaadin-charts/1.0.0/vaadin-charts-1.0.0.jar!/com/vaadin/addon/charts/client/exporting.js
      public String getText() {
        return "/*\n Highcharts JS v2.3.5 (2012-12-19)\n Exporting module\n\n (c) 2010-2011 Torstein Hønsi\n\n License: www.highcharts.com/license\n*/\n(function(e){function y(a){for(var b=a.length;b--;)typeof a[b]===\"number\"&&(a[b]=Math.round(a[b])-0.5);return a}var z=e.Chart,u=e.addEvent,B=e.removeEvent,j=e.createElement,v=e.discardElement,t=e.css,l=e.merge,k=e.each,o=e.extend,C=Math.max,i=document,D=window,E=e.isTouchDevice,A=e.Renderer.prototype.symbols,w=e.getOptions();o(w.lang,{downloadPNG:\"Download PNG image\",downloadJPEG:\"Download JPEG image\",downloadPDF:\"Download PDF document\",downloadSVG:\"Download SVG vector image\",exportButtonTitle:\"Export to raster or vector image\",\nprintButtonTitle:\"Print the chart\"});w.navigation={menuStyle:{border:\"1px solid #A0A0A0\",background:\"#FFFFFF\"},menuItemStyle:{padding:\"0 5px\",background:\"none\",color:\"#303030\",fontSize:E?\"14px\":\"11px\"},menuItemHoverStyle:{background:\"#4572A5\",color:\"#FFFFFF\"},buttonOptions:{align:\"right\",backgroundColor:{linearGradient:[0,0,0,20],stops:[[0.4,\"#F7F7F7\"],[0.6,\"#E3E3E3\"]]},borderColor:\"#B0B0B0\",borderRadius:3,borderWidth:1,height:20,hoverBorderColor:\"#909090\",hoverSymbolFill:\"#81A7CF\",hoverSymbolStroke:\"#4572A5\",\nsymbolFill:\"#E0E0E0\",symbolStroke:\"#A0A0A0\",symbolX:11.5,symbolY:10.5,verticalAlign:\"top\",width:24,y:10}};w.exporting={type:\"image/png\",url:\"http://export.highcharts.com/\",width:800,buttons:{exportButton:{symbol:\"exportIcon\",x:-10,symbolFill:\"#A8BF77\",hoverSymbolFill:\"#768F3E\",_id:\"exportButton\",_titleKey:\"exportButtonTitle\",menuItems:[{textKey:\"downloadPNG\",onclick:function(){this.exportChart()}},{textKey:\"downloadJPEG\",onclick:function(){this.exportChart({type:\"image/jpeg\"})}},{textKey:\"downloadPDF\",\nonclick:function(){this.exportChart({type:\"application/pdf\"})}},{textKey:\"downloadSVG\",onclick:function(){this.exportChart({type:\"image/svg+xml\"})}}]},printButton:{symbol:\"printIcon\",x:-36,symbolFill:\"#B5C9DF\",hoverSymbolFill:\"#779ABF\",_id:\"printButton\",_titleKey:\"printButtonTitle\",onclick:function(){this.print()}}}};e.post=function(a,b){var c,d;d=j(\"form\",{method:\"post\",action:a,enctype:\"multipart/form-data\"},{display:\"none\"},i.body);for(c in b)j(\"input\",{type:\"hidden\",name:c,value:b[c]},null,d);\nd.submit();v(d)};o(z.prototype,{getSVG:function(a){var b=this,c,d,f,g=l(b.options,a);if(!i.createElementNS)i.createElementNS=function(a,b){return i.createElement(b)};a=j(\"div\",null,{position:\"absolute\",top:\"-9999em\",width:b.chartWidth+\"px\",height:b.chartHeight+\"px\"},i.body);o(g.chart,{renderTo:a,forExport:!0});g.exporting.enabled=!1;g.chart.plotBackgroundImage=null;g.series=[];k(b.series,function(a){f=l(a.options,{animation:!1,showCheckbox:!1,visible:a.visible});f.isInternal||g.series.push(f)});c=\nnew e.Chart(g);k([\"xAxis\",\"yAxis\"],function(a){k(b[a],function(b,d){var f=c[a][d],g=b.getExtremes(),e=g.userMin,g=g.userMax;(e!==void 0||g!==void 0)&&f.setExtremes(e,g,!0,!1)})});d=c.container.innerHTML;g=null;c.destroy();v(a);d=d.replace(/zIndex=\"[^\"]+\"/g,\"\").replace(/isShadow=\"[^\"]+\"/g,\"\").replace(/symbolName=\"[^\"]+\"/g,\"\").replace(/jQuery[0-9]+=\"[^\"]+\"/g,\"\").replace(/isTracker=\"[^\"]+\"/g,\"\").replace(/url\\([^#]+#/g,\"url(#\").replace(/<svg /,'<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" ').replace(/ href=/g,\n\" xlink:href=\").replace(/\\n/,\" \").replace(/<\\/svg>.*?$/,\"</svg>\").replace(/&nbsp;/g,\" \").replace(/&shy;/g,\"­\").replace(/<IMG /g,\"<image \").replace(/height=([^\" ]+)/g,'height=\"$1\"').replace(/width=([^\" ]+)/g,'width=\"$1\"').replace(/hc-svg-href=\"([^\"]+)\">/g,'xlink:href=\"$1\"/>').replace(/id=([^\" >]+)/g,'id=\"$1\"').replace(/class=([^\" ]+)/g,'class=\"$1\"').replace(/ transform /g,\" \").replace(/:(path|rect)/g,\"$1\").replace(/style=\"([^\"]+)\"/g,function(a){return a.toLowerCase()});d=d.replace(/(url\\(#highcharts-[0-9]+)&quot;/g,\n\"$1\").replace(/&quot;/g,\"'\");d.match(/ xmlns=\"/g).length===2&&(d=d.replace(/xmlns=\"[^\"]+\"/,\"\"));return d},exportChart:function(a,b){var c=this.options.exporting,d=this.getSVG(l(c.chartOptions,b)),a=l(c,a);e.post(a.url,{filename:a.filename||\"chart\",type:a.type,width:a.width,scale:a.scale||2,svg:d})},print:function(){var a=this,b=a.container,c=[],d=b.parentNode,f=i.body,g=f.childNodes;if(!a.isPrinting)a.isPrinting=!0,k(g,function(a,b){if(a.nodeType===1)c[b]=a.style.display,a.style.display=\"none\"}),\nf.appendChild(b),D.print(),setTimeout(function(){d.appendChild(b);k(g,function(a,b){if(a.nodeType===1)a.style.display=c[b]});a.isPrinting=!1},1E3)},contextMenu:function(a,b,c,d,f,g){var e=this,p=e.options.navigation,i=p.menuItemStyle,q=e.chartWidth,r=e.chartHeight,s=\"cache-\"+a,h=e[s],m=C(f,g),x,n,l;if(!h)e[s]=h=j(\"div\",{className:\"highcharts-\"+a},{position:\"absolute\",zIndex:1E3,padding:m+\"px\"},e.container),x=j(\"div\",null,o({MozBoxShadow:\"3px 3px 10px #888\",WebkitBoxShadow:\"3px 3px 10px #888\",boxShadow:\"3px 3px 10px #888\"},\np.menuStyle),h),n=function(){t(h,{display:\"none\"})},u(h,\"mouseleave\",function(){l=setTimeout(n,500)}),u(h,\"mouseenter\",function(){clearTimeout(l)}),k(b,function(a){if(a){var b=j(\"div\",{onmouseover:function(){t(this,p.menuItemHoverStyle)},onmouseout:function(){t(this,i)},innerHTML:a.text||e.options.lang[a.textKey]},o({cursor:\"pointer\"},i),x);b.onclick=function(){n();a.onclick.apply(e,arguments)};e.exportDivElements.push(b)}}),e.exportDivElements.push(x,h),e.exportMenuWidth=h.offsetWidth,e.exportMenuHeight=\nh.offsetHeight;a={display:\"block\"};c+e.exportMenuWidth>q?a.right=q-c-f-m+\"px\":a.left=c-m+\"px\";d+g+e.exportMenuHeight>r?a.bottom=r-d-m+\"px\":a.top=d+g-m+\"px\";t(h,a)},addButton:function(a){function b(){r.attr(k);q.attr(m)}var c=this,d=c.renderer,f=l(c.options.navigation.buttonOptions,a),e=f.onclick,i=f.menuItems,p=f.width,j=f.height,q,r,s,h,a=f.borderWidth,m={stroke:f.borderColor},k={stroke:f.symbolStroke,fill:f.symbolFill},n=f.symbolSize||12;if(!c.btnCount)c.btnCount=0;h=c.btnCount++;if(!c.exportDivElements)c.exportDivElements=\n[],c.exportSVGElements=[];f.enabled!==!1&&(q=d.rect(0,0,p,j,f.borderRadius,a).align(f,!0).attr(o({fill:f.backgroundColor,\"stroke-width\":a,zIndex:19},m)).add(),s=d.rect(0,0,p,j,0).align(f).attr({id:f._id,fill:\"rgba(255, 255, 255, 0.001)\",title:c.options.lang[f._titleKey],zIndex:21}).css({cursor:\"pointer\"}).on(\"mouseover\",function(){r.attr({stroke:f.hoverSymbolStroke,fill:f.hoverSymbolFill});q.attr({stroke:f.hoverBorderColor})}).on(\"mouseout\",b).on(\"click\",b).add(),i&&(e=function(){b();var a=s.getBBox();\nc.contextMenu(\"menu\"+h,i,a.x,a.y,p,j)}),s.on(\"click\",function(){e.apply(c,arguments)}),r=d.symbol(f.symbol,f.symbolX-n/2,f.symbolY-n/2,n,n).align(f,!0).attr(o(k,{\"stroke-width\":f.symbolStrokeWidth||1,zIndex:20})).add(),c.exportSVGElements.push(q,s,r))},destroyExport:function(){var a,b;for(a=0;a<this.exportSVGElements.length;a++)b=this.exportSVGElements[a],b.onclick=b.ontouchstart=null,this.exportSVGElements[a]=b.destroy();for(a=0;a<this.exportDivElements.length;a++)b=this.exportDivElements[a],B(b,\n\"mouseleave\"),this.exportDivElements[a]=b.onmouseout=b.onmouseover=b.ontouchstart=b.onclick=null,v(b)}});A.exportIcon=function(a,b,c,d){return y([\"M\",a,b+c,\"L\",a+c,b+d,a+c,b+d*0.8,a,b+d*0.8,\"Z\",\"M\",a+c*0.5,b+d*0.8,\"L\",a+c*0.8,b+d*0.4,a+c*0.4,b+d*0.4,a+c*0.4,b,a+c*0.6,b,a+c*0.6,b+d*0.4,a+c*0.2,b+d*0.4,\"Z\"])};A.printIcon=function(a,b,c,d){return y([\"M\",a,b+d*0.7,\"L\",a+c,b+d*0.7,a+c,b+d*0.4,a,b+d*0.4,\"Z\",\"M\",a+c*0.2,b+d*0.4,\"L\",a+c*0.2,b,a+c*0.8,b,a+c*0.8,b+d*0.4,\"Z\",\"M\",a+c*0.2,b+d*0.7,\"L\",a,b+d,a+\nc,b+d,a+c*0.8,b+d*0.7,\"Z\"])};z.prototype.callbacks.push(function(a){var b,c=a.options.exporting,d=c.buttons;if(c.enabled!==!1){for(b in d)a.addButton(d[b]);u(a,\"destroy\",a.destroyExport)}})})(Highcharts);\n";
      }
      public String getName() {
        return "exporting";
      }
    }
    ;
  }
  private static class exportingInitializer {
    static {
      _instance0.exportingInitializer();
    }
    static com.google.gwt.resources.client.TextResource get() {
      return exporting;
    }
  }
  public com.google.gwt.resources.client.TextResource exporting() {
    return exportingInitializer.get();
  }
  private void highchartsInitializer() {
    highcharts = new com.google.gwt.resources.client.TextResource() {
      // jar:file:/Users/ajaybhaga/.m2/repository/com/vaadin/addon/vaadin-charts/1.0.0/vaadin-charts-1.0.0.jar!/com/vaadin/addon/charts/client/highcharts.src.js
      public String getText() {
        StringBuilder builder = new StringBuilder();
        builder.append("// ==ClosureCompiler==\n// @compilation_level SIMPLE_OPTIMIZATIONS\n\n/**\n * @license Highcharts JS v2.3.5 (2012-12-19)\n *\n * (c) 2009-2012 Torstein Hønsi\n *\n * License: www.highcharts.com/license\n */\n\n// JSLint options:\n/*global Highcharts, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console */\n\n(function () {\n// encapsulated variables\nvar UNDEFINED,\n	doc = document,\n	win = window,\n	math = Math,\n	mathRound = math.round,\n	mathFloor = math.floor,\n	mathCeil = math.ceil,\n	mathMax = math.max,\n	mathMin = math.min,\n	mathAbs = math.abs,\n	mathCos = math.cos,\n	mathSin = math.sin,\n	mathPI = math.PI,\n	deg2rad = mathPI * 2 / 360,\n\n\n	// some variables\n	userAgent = navigator.userAgent,\n	isOpera = win.opera,\n	isIE = /msie/i.test(userAgent) && !isOpera,\n	docMode8 = doc.documentMode === 8,\n	isWebKit = /AppleWebKit/.test(userAgent),\n	isFirefox = /Firefox/.test(userAgent),\n	isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),\n	SVG_NS = 'http://www.w3.org/2000/svg',\n	hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,\n	hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38\n	useCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,\n	Renderer,\n	hasTouch = doc.documentElement.ontouchstart !== UNDEFINED,\n	symbolSizes = {},\n	idCounter = 0,\n	garbageBin,\n	defaultOptions,\n	dateFormat, // function\n	globalAnimation,\n	pathAnim,\n	timeUnits,\n	noop = function () {},\n	charts = [],\n\n	// some constants for frequently used strings\n	DIV = 'div',\n	ABSOLUTE = 'absolute',\n	RELATIVE = 'relative',\n	HIDDEN = 'hidden',\n	PREFIX = 'highcharts-',\n	VISIBLE = 'visible',\n	PX = 'px',\n	NONE = 'none',\n	M = 'M',\n	L = 'L',\n	/*\n	 * Empirical lowest possible opacities for TRACKER_FILL\n	 * IE6: 0.002\n	 * IE7: 0.002\n	 * IE8: 0.002\n	 * IE9: 0.00000000001 (unlimited)\n	 * IE10: 0.0001 (exporting only)\n	 * FF: 0.00000000001 (unlimited)\n	 * Chrome: 0.000001\n	 * Safari: 0.000001\n	 * Opera: 0.00000000001 (unlimited)\n	 */\n	TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')', // invisible but clickable\n	//TRACKER_FILL = 'rgba(192,192,192,0.5)',\n	NORMAL_STATE = '',\n	HOVER_STATE = 'hover',\n	SELECT_STATE = 'select',\n	MILLISECOND = 'millisecond',\n	SECOND = 'second',\n	MINUTE = 'minute',\n	HOUR = 'hour',\n	DAY = 'day',\n	WEEK = 'week',\n	MONTH = 'month',\n	YEAR = 'year',\n\n	// constants for attributes\n	FILL = 'fill',\n	LINEAR_GRADIENT = 'linearGradient',\n	STOPS = 'stops',\n	STROKE = 'stroke',\n	STROKE_WIDTH = 'stroke-width',\n\n	// time methods, changed based on whether or not UTC is used\n	makeTime,\n	getMinutes,\n	getHours,\n	getDay,\n	getDate,\n	getMonth,\n	getFullYear,\n	setMinutes,\n	setHours,\n	setDate,\n	setMonth,\n	setFullYear,\n\n\n	// lookup over the types and the associated classes\n	seriesTypes = {};\n\n// The Highcharts namespace\nwin.Highcharts = {};\n\n/**\n * Extend an object with the members of another\n * @param {Object} a The object to be extended\n * @param {Object} b The object to add to the first one\n */\nfunction extend(a, b) {\n	var n;\n	if (!a) {\n		a = {};\n	}\n	for (n in b) {\n		a[n] = b[n];\n	}\n	return a;\n}\n\n/**\n * Take an array and turn into a hash with even number arguments as keys and odd numbers as\n * values. Allows creating constants for commonly used style properties, attributes etc.\n * Avoid it in performance critical situations like looping\n */\nfunction hash() {\n	var i = 0,\n		args = arguments,\n		length = args.length,\n		obj = {};\n	for (; i < length; i++) {\n		obj[args[i++]] = args[i];\n	}\n	return obj;\n}\n\n/**\n * Shortcut for parseInt\n * @param {Object} s\n * @param {Number} mag Magnitude\n */\nfunction pInt(s, mag) {\n	return parseInt(s, mag || 10);\n}\n\n/**\n * Check for string\n * @param {Object} s\n */\nfunction isString(s) {\n	return typeof s === 'string';\n}\n\n/**\n * Check for object\n * @param {Object} obj\n */\nfunction isObject(obj) {\n	return typeof obj === 'object';\n}\n\n/**\n * Check for array\n * @param {Object} obj\n */\nfunction isArray(obj) {\n	return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\n/**\n * Check for number\n * @param {Object} n\n */\nfunction isNumber(n) {\n	return typeof n === 'number';\n}\n\nfunction log2lin(num) {\n	return math.log(num) / math.LN10;\n}\nfunction lin2log(num) {\n	return math.pow(10, num);\n}\n\n/**\n * Remove last occurence of an item from an array\n * @param {Array} arr\n * @param {Mixed} item\n */\nfunction erase(arr, item) {\n	var i = arr.length;\n	while (i--) {\n		if (arr[i] === item) {\n			arr.splice(i, 1);\n			break;\n		}\n	}\n	//return arr;\n}\n\n/**\n * Returns true if the object is not null or undefined. Like MooTools' $.defined.\n * @param {Object} obj\n */\nfunction defined(obj) {\n	return obj !== UNDEFINED && obj !== null;\n}\n\n/**\n * Set or get an attribute or an object of attributes. Can't use jQuery attr because\n * it attempts to set expando properties on the SVG element, which is not allowed.\n *\n * @param {Object} elem The DOM element to receive the attribute(s)\n * @param {String|Object} prop The property or an abject of key-value pairs\n * @param {String} value The value if a single property is set\n */\nfunction attr(elem, prop, value) {\n	var key,\n		setAttribute = 'setAttribute',\n		ret;\n\n	// if the prop is a string\n	if (isString(prop)) {\n		// set the value\n		if (defined(value)) {\n\n			elem[setAttribute](prop, value);\n\n		// get the value\n		} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...\n			ret = elem.getAttribute(prop);\n		}\n\n	// else if prop is defined, it is a hash of key/value pairs\n	} else if (defined(prop) && isObject(prop)) {\n		for (key in prop) {\n			elem[setAttribute](key, prop[key]);\n		}\n	}\n	return ret;\n}\n/**\n * Check if an element is an array, and if not, make it into an array. Like\n * MooTools' $.splat.\n */\nfunction splat(obj) {\n	return isArray(obj) ? obj : [obj];\n}\n\n\n/**\n * Return the first value that is defined. Like MooTools' $.pick.\n */\nfunction pick() {\n	var args = arguments,\n		i,\n		arg,\n		length = args.length;\n	for (i = 0; i < length; i++) {\n		arg = args[i];\n		if (typeof arg !== 'undefined' && arg !== null) {\n			return arg;\n		}\n	}\n}\n\n/**\n * Set CSS on a given element\n * @param {Object} el\n * @param {Object} styles Style object with camel case property names\n */\nfunction css(el, styles) {\n	if (isIE) {\n		if (styles && styles.opacity !== UNDEFINED) {\n			styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';\n		}\n	}\n	extend(el.style, styles);\n}\n\n/**\n * Utility function to create element with attributes and styles\n * @param {Object} tag\n * @param {Object} attribs\n * @param {Object} styles\n * @param {Object} parent\n * @param {Object} nopad\n */\nfunction createElement(tag, attribs, styles, parent, nopad) {\n	var el = doc.createElement(tag);\n	if (attribs) {\n		extend(el, attribs);\n	}\n	if (nopad) {\n		css(el, {padding: 0, border: NONE, margin: 0});\n	}\n	if (styles) {\n		css(el, styles);\n	}\n	if (parent) {\n		parent.appendChild(el);\n	}\n	return el;\n}\n\n/**\n * Extend a prototyped class by new members\n * @param {Object} parent\n * @param {Object} members\n */\nfunction extendClass(parent, members) {\n	var object = function () {};\n	object.prototype = new parent();\n	extend(object.prototype, members);\n	return object;\n}\n\n/**\n * How many decimals are there in a number\n */\nfunction getDecimals(number) {\n	\n	number = (number || 0).toString();\n	\n	return number.indexOf('.') > -1 ? \n		number.split('.')[1].length :\n		0;\n}\n\n/**\n * Format a number and return a string based on input settings\n * @param {Number} number The input number to format\n * @param {Number} decimals The amount of decimals\n * @param {String} decPoint The decimal point, defaults to the one given in the lang options\n * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options\n */\nfunction numberFormat(number, decimals, decPoint, thousandsSep) {\n	var lang = defaultOptions.lang,\n		// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/\n		n = number,\n		c = decimals === -1 ?\n			getDecimals(number) :\n			(isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),\n		d = decPoint === undefined ? lang.decimalPoint : decPoint,\n		t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,\n		s = n < 0 ? \"-\" : \"\",\n		i = String(pInt(n = mathAbs(+n || 0).toFixed(c))),\n		j = i.length > 3 ? i.length % 3 : 0;\n\n	return s + (j ? i.substr(0, j) + t : \"\") + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + t) +\n		(c ? d + mathAbs(n - i).toFixed(c).slice(2) : \"\");\n}\n\n/**\n * Pad a string to a given length by adding 0 to the beginning\n * @param {Number} number\n * @param {Number} length\n */\nfunction pad(number, length) {\n	// Create an array of the remaining length +1 and join it with 0's\n	return new Array((length || 2) + 1 - String(number).length).join(0) + number;\n}\n\n/**\n * Wrap a method with extended functionality, preserving the original function\n * @param {Object} obj The context object that the method belongs to \n * @param {String} method The name of the method to extend\n * @param {Function} func A wrapper function callback. This function is called with the same arguments\n * as the original function, except that the original function is unshifted and passed as the first \n * argument. \n */\nfunction wrap(obj, method, func) {\n	var proceed = obj[method];\n	obj[method] = function () {\n		var args = Array.prototype.slice.call(arguments);\n		args.unshift(proceed);\n		return func.apply(this, args);\n	};\n}\n\n/**\n * Based on http://www.php.net/manual/en/function.strftime.php\n * @param {String} format\n * @param {Number} timestamp\n * @param {Boolean} capitalize\n */\ndateFormat = function (format, timestamp, capitalize) {\n	if (!defined(timestamp) || isNaN(timestamp)) {\n		return 'Invalid date';\n	}\n	format = pick(format, '%Y-%m-%d %H:%M:%S');\n\n	var date = new Date(timestamp),\n		key, // used in for constuct below\n		// get the basic time values\n		hours = date[getHours](),\n		day = date[getDay](),\n		dayOfMonth = date[getDate](),\n		month = date[getMonth](),\n		fullYear = date[getFullYear](),\n		lang = defaultOptions.lang,\n		langWeekdays = lang.weekdays,\n		/* // uncomment this and the 'W' format key below to enable week numbers\n		weekNumber = function () {\n			var clone = new Date(date.valueOf()),\n				day = clone[getDay]() == 0 ? 7 : clone[getDay](),\n				dayNumber;\n			clone.setDate(clone[getDate]() + 4 - day);\n			dayNumber = mathFloor((clone.getTime() - new Date(clone[getFullYear](), 0, 1, -6)) / 86400000);\n			return 1 + mathFloor(dayNumber / 7);\n		},\n		*/\n\n		// list all format keys\n		replacements = {\n\n			// Day\n			'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'\n			'A': langWeekdays[day], // Long weekday, like 'Monday'\n			'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31\n			'e': dayOfMonth, // Day of the month, 1 through 31\n\n			// Week (none implemented)\n			//'W': weekNumber(),\n\n			// Month\n			'b': lang.shortMonths[month], // Short month, like 'Jan'\n			'B': lang.months[month], // Long month, like 'January'\n			'm': pad(month + 1), // Two digit month number, 01 through 12\n\n			// Year\n			'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009\n			'Y': fullYear, // Four digits year, like 2009\n\n			// Time\n			'H': pad(hours), // Two digits hours in 24h format, 00 through 23\n			'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11\n			'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12\n			'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59\n			'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM\n			'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM\n			'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59\n			'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)\n		};\n\n\n	// do the replaces\n	for (key in replacements) {\n		while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster\n			format = format.replace('%' + key, replacements[key]);\n		}\n	}\n\n	// Optionally capitalize the string and return\n	return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;\n};\n\n/**\n * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5\n * @param {Number} interval\n * @param {Array} multiples\n * @param {Number} magnitude\n * @param {Object} options\n */\nfunction normalizeTickInterval(interval, multiples, magnitude, options) {\n	var normalized, i;\n\n	// round to a tenfold of 1, 2, 2.5 or 5\n	magnitude = pick(magnitude, 1);\n	normalized = interval / magnitude;\n\n	// multiples for a linear scale\n	if (!multiples) {\n		multiples = [1, 2, 2.5, 5, 10];\n\n		// the allowDecimals option\n		if (options && options.allowDecimals === false) {\n			if (magnitude === 1) {\n				multiples = [1, 2, 5, 10];\n			} else if (magnitude <= 0.1) {\n				multiples = [1 / magnitude];\n			}\n		}\n	}\n\n	// normalize the interval to the nearest multiple\n	for (i = 0; i < multiples.length; i++) {\n		interval = multiples[i];\n		if (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {\n			break;\n		}\n	}\n\n	// multiply back to the correct magnitude\n	interval *= magnitude;\n\n	return interval;\n}\n\n/**\n * Get a normalized tick interval for dates. Returns a configuration object with\n * unit range (interval), count and name. Used to prepare data for getTimeTicks. \n * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs\n * of segments in stock charts, the normalizing logic was extracted in order to \n * prevent it for running over again for each segment having the same interval. \n * #662, #697.\n */\nfunction normalizeTimeTickInterval(tickInterval, unitsOption) {\n	var units = unitsOption || [[\n				MILLISECOND, // unit name\n				[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n			], [\n				SECOND,\n				[1, 2, 5, 10, 15, 30]\n			], [\n				MINUTE,\n				[1, 2, 5, 10, 15, 30]\n			], [\n				HOUR,\n				[1, 2, 3, 4, 6, 8, 12]\n			], [\n				DAY,\n				[1, 2]\n			], [\n				WEEK,\n				[1, 2]\n			], [\n				MONTH,\n				[1, 2, 3, 4, 6]\n			], [\n				YEAR,\n				null\n			]],\n		unit = units[units.length - 1], // default unit is years\n		interval = timeUnits[unit[0]],\n		multiples = unit[1],\n		count,\n		i;\n		\n	// loop through the units to find the one that best fits the tickInterval\n	for (i = 0; i < units.length; i++) {\n		unit = units[i];\n		interval = timeUnits[unit[0]];\n		multiples = unit[1];\n\n\n		if (units[i + 1]) {\n			// lessThan is in the middle between the highest multiple and the next unit.\n			var lessThan = (interval * multiples[multiples.length - 1] +\n						timeUnits[units[i + 1][0]]) / 2;\n\n			// break and keep the current unit\n			if (tickInterval <= lessThan) {\n				break;\n			}\n		}\n	}\n\n	// prevent 2.5 years intervals, though 25, 250 etc. are allowed\n	if (interval === timeUnits[YEAR] && tickInterval < 5 * interval) {\n		multiples = [1, 2, 5];\n	}\n	\n	// prevent 2.5 years intervals, though 25, 250 etc. are allowed\n	if (interval === timeUnits[YEAR] && tickInterval < 5 * interval) {\n		multiples = [1, 2, 5];\n	}\n\n	// get the count\n	count = normalizeTickInterval(tickInterval / interval, multiples);\n	\n	return {\n		unitRange: interval,\n		count: count,\n		unitName: unit[0]\n	};\n}\n\n/**\n * Set the tick positions to a time unit that makes sense, for example\n * on the first of each month or on every Monday. Return an array\n * with the time positions. Used in datetime axes as well as for grouping\n * data on a datetime axis.\n *\n * @param {Object} normalizedInterval The interval in axis values (ms) and the count\n * @param {Number} min The minimum in axis values\n * @param {Number} max The maximum in axis values\n * @param {Number} startOfWeek\n */\nfunction getTimeTicks(normalizedInterval, min, max, startOfWeek) {\n	var tickPositions = [],\n		i,\n		higherRanks = {},\n		useUTC = defaultOptions.global.useUTC,\n		minYear, // used in months and years as a basis for Date.UTC()\n		minDate = new Date(min),\n		interval = normalizedInterval.unitRange,\n		count = normalizedInterval.count;\n\n	if (defined(min)) { // #1300\n		if (interval >= timeUnits[SECOND]) { // second\n			minDate.setMilliseconds(0);\n			minDate.setSeconds(interval >= timeUnits[MINUTE] ? 0 :\n				count * mathFloor(minDate.getSeconds() / count));\n		}\n	\n		if (interval >= timeUnits[MINUTE]) { // minute\n			minDate[setMinutes](interval >= timeUnits[HOUR] ? 0 :\n				count * mathFloor(minDate[getMinutes]() / count));\n		}\n	\n		if (interval >= timeUnits[HOUR]) { // hour\n			minDate[setHours](interval >= timeUnits[DAY] ? 0 :\n				cou");
        builder.append("nt * mathFloor(minDate[getHours]() / count));\n		}\n	\n		if (interval >= timeUnits[DAY]) { // day\n			minDate[setDate](interval >= timeUnits[MONTH] ? 1 :\n				count * mathFloor(minDate[getDate]() / count));\n		}\n	\n		if (interval >= timeUnits[MONTH]) { // month\n			minDate[setMonth](interval >= timeUnits[YEAR] ? 0 :\n				count * mathFloor(minDate[getMonth]() / count));\n			minYear = minDate[getFullYear]();\n		}\n	\n		if (interval >= timeUnits[YEAR]) { // year\n			minYear -= minYear % count;\n			minDate[setFullYear](minYear);\n		}\n	\n		// week is a special case that runs outside the hierarchy\n		if (interval === timeUnits[WEEK]) {\n			// get start of current week, independent of count\n			minDate[setDate](minDate[getDate]() - minDate[getDay]() +\n				pick(startOfWeek, 1));\n		}\n	\n	\n		// get tick positions\n		i = 1;\n		minYear = minDate[getFullYear]();\n		var time = minDate.getTime(),\n			minMonth = minDate[getMonth](),\n			minDateDate = minDate[getDate](),\n			timezoneOffset = useUTC ? \n				0 : \n				(24 * 3600 * 1000 + minDate.getTimezoneOffset() * 60 * 1000) % (24 * 3600 * 1000); // #950\n	\n		// iterate and add tick positions at appropriate values\n		while (time < max) {\n			tickPositions.push(time);\n	\n			// if the interval is years, use Date.UTC to increase years\n			if (interval === timeUnits[YEAR]) {\n				time = makeTime(minYear + i * count, 0);\n	\n			// if the interval is months, use Date.UTC to increase months\n			} else if (interval === timeUnits[MONTH]) {\n				time = makeTime(minYear, minMonth + i * count);\n	\n			// if we're using global time, the interval is not fixed as it jumps\n			// one hour at the DST crossover\n			} else if (!useUTC && (interval === timeUnits[DAY] || interval === timeUnits[WEEK])) {\n				time = makeTime(minYear, minMonth, minDateDate +\n					i * count * (interval === timeUnits[DAY] ? 1 : 7));\n	\n			// else, the interval is fixed and we use simple addition\n			} else {\n				time += interval * count;\n				\n				// mark new days if the time is dividable by day\n				if (interval <= timeUnits[HOUR] && time % timeUnits[DAY] === timezoneOffset) {\n					higherRanks[time] = DAY;\n				}\n			}\n	\n			i++;\n		}\n	\n		// push the last time\n		tickPositions.push(time);\n	}\n\n	// record information on the chosen unit - for dynamic label formatter\n	tickPositions.info = extend(normalizedInterval, {\n		higherRanks: higherRanks,\n		totalRange: interval * count\n	});\n\n	return tickPositions;\n}\n\n/**\n * Helper class that contains variuos counters that are local to the chart.\n */\nfunction ChartCounters() {\n	this.color = 0;\n	this.symbol = 0;\n}\n\nChartCounters.prototype =  {\n	/**\n	 * Wraps the color counter if it reaches the specified length.\n	 */\n	wrapColor: function (length) {\n		if (this.color >= length) {\n			this.color = 0;\n		}\n	},\n\n	/**\n	 * Wraps the symbol counter if it reaches the specified length.\n	 */\n	wrapSymbol: function (length) {\n		if (this.symbol >= length) {\n			this.symbol = 0;\n		}\n	}\n};\n\n\n/**\n * Utility method that sorts an object array and keeping the order of equal items.\n * ECMA script standard does not specify the behaviour when items are equal.\n */\nfunction stableSort(arr, sortFunction) {\n	var length = arr.length,\n		sortValue,\n		i;\n\n	// Add index to each item\n	for (i = 0; i < length; i++) {\n		arr[i].ss_i = i; // stable sort index\n	}\n\n	arr.sort(function (a, b) {\n		sortValue = sortFunction(a, b);\n		return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;\n	});\n\n	// Remove index from items\n	for (i = 0; i < length; i++) {\n		delete arr[i].ss_i; // stable sort index\n	}\n}\n\n/**\n * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n * method is slightly slower, but safe.\n */\nfunction arrayMin(data) {\n	var i = data.length,\n		min = data[0];\n\n	while (i--) {\n		if (data[i] < min) {\n			min = data[i];\n		}\n	}\n	return min;\n}\n\n/**\n * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n * method is slightly slower, but safe.\n */\nfunction arrayMax(data) {\n	var i = data.length,\n		max = data[0];\n\n	while (i--) {\n		if (data[i] > max) {\n			max = data[i];\n		}\n	}\n	return max;\n}\n\n/**\n * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.\n * It loops all properties and invokes destroy if there is a destroy method. The property is\n * then delete'ed.\n * @param {Object} The object to destroy properties on\n * @param {Object} Exception, do not destroy this property, only delete it.\n */\nfunction destroyObjectProperties(obj, except) {\n	var n;\n	for (n in obj) {\n		// If the object is non-null and destroy is defined\n		if (obj[n] && obj[n] !== except && obj[n].destroy) {\n			// Invoke the destroy\n			obj[n].destroy();\n		}\n\n		// Delete the property from the object.\n		delete obj[n];\n	}\n}\n\n\n/**\n * Discard an element by moving it to the bin and delete\n * @param {Object} The HTML node to discard\n */\nfunction discardElement(element) {\n	// create a garbage bin element, not part of the DOM\n	if (!garbageBin) {\n		garbageBin = createElement(DIV);\n	}\n\n	// move the node and empty bin\n	if (element) {\n		garbageBin.appendChild(element);\n	}\n	garbageBin.innerHTML = '';\n}\n\n/**\n * Provide error messages for debugging, with links to online explanation \n */\nfunction error(code, stop) {\n	var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;\n	if (stop) {\n		throw msg;\n	} else if (win.console) {\n		console.log(msg);\n	}\n}\n\n/**\n * Fix JS round off float errors\n * @param {Number} num\n */\nfunction correctFloat(num) {\n	return parseFloat(\n		num.toPrecision(14)\n	);\n}\n\n/**\n * Set the global animation to either a given value, or fall back to the\n * given chart's animation option\n * @param {Object} animation\n * @param {Object} chart\n */\nfunction setAnimation(animation, chart) {\n	globalAnimation = pick(animation, chart.animation);\n}\n\n/**\n * The time unit lookup\n */\n/*jslint white: true*/\ntimeUnits = hash(\n	MILLISECOND, 1,\n	SECOND, 1000,\n	MINUTE, 60000,\n	HOUR, 3600000,\n	DAY, 24 * 3600000,\n	WEEK, 7 * 24 * 3600000,\n	MONTH, 31 * 24 * 3600000,\n	YEAR, 31556952000\n);\n/*jslint white: false*/\n/**\n * Path interpolation algorithm used across adapters\n */\npathAnim = {\n	/**\n	 * Prepare start and end values so that the path can be animated one to one\n	 */\n	init: function (elem, fromD, toD) {\n		fromD = fromD || '';\n		var shift = elem.shift,\n			bezier = fromD.indexOf('C') > -1,\n			numParams = bezier ? 7 : 3,\n			endLength,\n			slice,\n			i,\n			start = fromD.split(' '),\n			end = [].concat(toD), // copy\n			startBaseLine,\n			endBaseLine,\n			sixify = function (arr) { // in splines make move points have six parameters like bezier curves\n				i = arr.length;\n				while (i--) {\n					if (arr[i] === M) {\n						arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);\n					}\n				}\n			};\n\n		if (bezier) {\n			sixify(start);\n			sixify(end);\n		}\n\n		// pull out the base lines before padding\n		if (elem.isArea) {\n			startBaseLine = start.splice(start.length - 6, 6);\n			endBaseLine = end.splice(end.length - 6, 6);\n		}\n\n		// if shifting points, prepend a dummy point to the end path\n		if (shift <= end.length / numParams) {\n			while (shift--) {\n				end = [].concat(end).splice(0, numParams).concat(end);\n			}\n		}\n		elem.shift = 0; // reset for following animations\n\n		// copy and append last point until the length matches the end length\n		if (start.length) {\n			endLength = end.length;\n			while (start.length < endLength) {\n\n				//bezier && sixify(start);\n				slice = [].concat(start).splice(start.length - numParams, numParams);\n				if (bezier) { // disable first control point\n					slice[numParams - 6] = slice[numParams - 2];\n					slice[numParams - 5] = slice[numParams - 1];\n				}\n				start = start.concat(slice);\n			}\n		}\n\n		if (startBaseLine) { // append the base lines for areas\n			start = start.concat(startBaseLine);\n			end = end.concat(endBaseLine);\n		}\n		return [start, end];\n	},\n\n	/**\n	 * Interpolate each value of the path and return the array\n	 */\n	step: function (start, end, pos, complete) {\n		var ret = [],\n			i = start.length,\n			startVal;\n\n		if (pos === 1) { // land on the final path without adjustment points appended in the ends\n			ret = complete;\n\n		} else if (i === end.length && pos < 1) {\n			while (i--) {\n				startVal = parseFloat(start[i]);\n				ret[i] =\n					isNaN(startVal) ? // a letter instruction like M or L\n						start[i] :\n						pos * (parseFloat(end[i] - startVal)) + startVal;\n\n			}\n		} else { // if animation is finished or length not matching, land on right value\n			ret = end;\n		}\n		return ret;\n	}\n};\n\n(function ($) {\n	/**\n	 * The default HighchartsAdapter for jQuery\n	 */\n	win.HighchartsAdapter = win.HighchartsAdapter || ($ && {\n		\n		/**\n		 * Initialize the adapter by applying some extensions to jQuery\n		 */\n		init: function (pathAnim) {\n			\n			// extend the animate function to allow SVG animations\n			var Fx = $.fx,\n				Step = Fx.step,\n				dSetter,\n				Tween = $.Tween,\n				propHooks = Tween && Tween.propHooks;\n			\n			/*jslint unparam: true*//* allow unused param x in this function */\n			$.extend($.easing, {\n				easeOutQuad: function (x, t, b, c, d) {\n					return -c * (t /= d) * (t - 2) + b;\n				}\n			});\n			/*jslint unparam: false*/\n		\n		\n			// extend some methods to check for elem.attr, which means it is a Highcharts SVG object\n			$.each(['cur', '_default', 'width', 'height'], function (i, fn) {\n				var obj = Step,\n					base,\n					elem;\n					\n				// Handle different parent objects\n				if (fn === 'cur') {\n					obj = Fx.prototype; // 'cur', the getter, relates to Fx.prototype\n				\n				} else if (fn === '_default' && Tween) { // jQuery 1.8 model\n					obj = propHooks[fn];\n					fn = 'set';\n				}\n		\n				// Overwrite the method\n				base = obj[fn];\n				if (base) { // step.width and step.height don't exist in jQuery < 1.7\n		\n					// create the extended function replacement\n					obj[fn] = function (fx) {\n		\n						// Fx.prototype.cur does not use fx argument\n						fx = i ? fx : this;\n		\n						// shortcut\n						elem = fx.elem;\n		\n						// Fx.prototype.cur returns the current value. The other ones are setters\n						// and returning a value has no effect.\n						return elem.attr ? // is SVG element wrapper\n							elem.attr(fx.prop, fn === 'cur' ? UNDEFINED : fx.now) : // apply the SVG wrapper's method\n							base.apply(this, arguments); // use jQuery's built-in method\n					};\n				}\n			});\n			\n			\n			// Define the setter function for d (path definitions)\n			dSetter = function (fx) {\n				var elem = fx.elem,\n					ends;\n		\n				// Normally start and end should be set in state == 0, but sometimes,\n				// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped\n				// in these cases\n				if (!fx.started) {\n					ends = pathAnim.init(elem, elem.d, elem.toD);\n					fx.start = ends[0];\n					fx.end = ends[1];\n					fx.started = true;\n				}\n		\n		\n				// interpolate each value of the path\n				elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));\n			};\n			\n			// jQuery 1.8 style\n			if (Tween) {\n				propHooks.d = {\n					set: dSetter\n				};\n			// pre 1.8\n			} else {\n				// animate paths\n				Step.d = dSetter;\n			}\n			\n			/**\n			 * Utility for iterating over an array. Parameters are reversed compared to jQuery.\n			 * @param {Array} arr\n			 * @param {Function} fn\n			 */\n			this.each = Array.prototype.forEach ?\n				function (arr, fn) { // modern browsers\n					return Array.prototype.forEach.call(arr, fn);\n					\n				} : \n				function (arr, fn) { // legacy\n					var i = 0, \n						len = arr.length;\n					for (; i < len; i++) {\n						if (fn.call(arr[i], arr[i], i, arr) === false) {\n							return i;\n						}\n					}\n				};\n			\n			// Register Highcharts as a jQuery plugin\n			// TODO: MooTools and prototype as well?\n			// TODO: StockChart\n			/*$.fn.highcharts = function(options, callback) {\n		        options.chart = merge(options.chart, { renderTo: this[0] });\n		        this.chart = new Chart(options, callback);\n		        return this;\n		    };*/\n		},\n	\n		/**\n		 * Downloads a script and executes a callback when done.\n		 * @param {String} scriptLocation\n		 * @param {Function} callback\n		 */\n		getScript: $.getScript,\n		\n		/**\n		 * Return the index of an item in an array, or -1 if not found\n		 */\n		inArray: $.inArray,\n		\n		/**\n		 * A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.\n		 * @param {Object} elem The HTML element\n		 * @param {String} method Which method to run on the wrapped element\n		 */\n		adapterRun: function (elem, method) {\n			return $(elem)[method]();\n		},\n	\n		/**\n		 * Filter an array\n		 */\n		grep: $.grep,\n	\n		/**\n		 * Map an array\n		 * @param {Array} arr\n		 * @param {Function} fn\n		 */\n		map: function (arr, fn) {\n			//return jQuery.map(arr, fn);\n			var results = [],\n				i = 0,\n				len = arr.length;\n			for (; i < len; i++) {\n				results[i] = fn.call(arr[i], arr[i], i, arr);\n			}\n			return results;\n	\n		},\n	\n		/**\n		 * Deep merge two objects and return a third object\n		 */\n		merge: function () {\n			var args = arguments;\n			return $.extend(true, null, args[0], args[1], args[2], args[3]);\n		},\n	\n		/**\n		 * Get the position of an element relative to the top left of the page\n		 */\n		offset: function (el) {\n			return $(el).offset();\n		},\n	\n		/**\n		 * Add an event listener\n		 * @param {Object} el A HTML element or custom object\n		 * @param {String} event The event type\n		 * @param {Function} fn The event handler\n		 */\n		addEvent: function (el, event, fn) {\n			$(el).bind(event, fn);\n		},\n	\n		/**\n		 * Remove event added with addEvent\n		 * @param {Object} el The object\n		 * @param {String} eventType The event type. Leave blank to remove all events.\n		 * @param {Function} handler The function to remove\n		 */\n		removeEvent: function (el, eventType, handler) {\n			// workaround for jQuery issue with unbinding custom events:\n			// http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2\n			var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';\n			if (doc[func] && !el[func]) {\n				el[func] = function () {};\n			}\n	\n			$(el).unbind(eventType, handler);\n		},\n	\n		/**\n		 * Fire an event on a custom object\n		 * @param {Object} el\n		 * @param {String} type\n		 * @param {Object} eventArguments\n		 * @param {Function} defaultFunction\n		 */\n		fireEvent: function (el, type, eventArguments, defaultFunction) {\n			var event = $.Event(type),\n				detachedType = 'detached' + type,\n				defaultPrevented;\n	\n			// Remove warnings in Chrome when accessing layerX and layerY. Although Highcharts\n			// never uses these properties, Chrome includes them in the default click event and\n			// raises the warning when they are copied over in the extend statement below.\n			//\n			// To avoid problems in IE (see #1010) where we cannot delete the properties and avoid\n			// testing if they are there (warning in chrome) the only option is to test if running IE.\n			if (!isIE && eventArguments) {\n				delete eventArguments.layerX;\n				delete eventArguments.layerY;\n			}\n	\n			extend(event, eventArguments);\n	\n			// Prevent jQuery from triggering the object method that is named the\n			// same as the event. For example, if the event is 'select', jQuery\n			// attempts calling el.select and it goes into a loop.\n			if (el[type]) {\n				el[detachedType] = el[type];\n				el[type] = null;\n			}\n	\n			// Wrap preventDefault and stopPropagation in try/catch blocks in\n			// order to prevent JS errors when cancelling events on non-DOM\n			// objects. #615.\n			/*jslint unparam: true*/\n			$.each(['preventDefault', 'stopPropagation'], function (i, fn) {\n				var base = event[fn];\n				event[fn] = function () {\n					try {\n						base.call(event);\n					} catch (e) {\n						if (fn === 'preventDefault') {\n							defaultPrevented = true;\n						}\n					}\n				};\n			});\n			/*jslint unparam: false*/\n	\n			// trigger it\n			$(el).trigger(event);\n	\n			// attach the method\n			if (el[detachedType]) {\n				el[type] = el[detachedType];\n				el[detachedType] = null;\n			}\n	\n			if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {\n				defaultFunction(event);\n			}\n		},\n		\n		/**\n		 * Extension method needed for MooTools\n		 */\n		washMouseEvent: function (e) {\n			var ret = e.originalEvent || e;\n			\n			// computed by jQuery, needed by IE8\n			if (ret.pageX === UNDE");
        builder.append("FINED) { // #1236\n				ret.pageX = e.pageX;\n				ret.pageY = e.pageY;\n			}\n			\n			return ret;\n		},\n	\n		/**\n		 * Animate a HTML element or SVG element wrapper\n		 * @param {Object} el\n		 * @param {Object} params\n		 * @param {Object} options jQuery-like animation options: duration, easing, callback\n		 */\n		animate: function (el, params, options) {\n			var $el = $(el);\n			if (params.d) {\n				el.toD = params.d; // keep the array form for paths, used in $.fx.step.d\n				params.d = 1; // because in jQuery, animating to an array has a different meaning\n			}\n	\n			$el.stop();\n			$el.animate(params, options);\n	\n		},\n		/**\n		 * Stop running animation\n		 */\n		stop: function (el) {\n			$(el).stop();\n		}\n	});\n}(win.jQuery));\n\n\n// check for a custom HighchartsAdapter defined prior to this file\nvar globalAdapter = win.HighchartsAdapter,\n	adapter = globalAdapter || {};\n	\n// Initialize the adapter\nif (globalAdapter) {\n	globalAdapter.init.call(globalAdapter, pathAnim);\n}\n\n\n	// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object\n	// and all the utility functions will be null. In that case they are populated by the\n	// default adapters below.\nvar adapterRun = adapter.adapterRun,\n	getScript = adapter.getScript,\n	inArray = adapter.inArray,\n	each = adapter.each,\n	grep = adapter.grep,\n	offset = adapter.offset,\n	map = adapter.map,\n	merge = adapter.merge,\n	addEvent = adapter.addEvent,\n	removeEvent = adapter.removeEvent,\n	fireEvent = adapter.fireEvent,\n	washMouseEvent = adapter.washMouseEvent,\n	animate = adapter.animate,\n	stop = adapter.stop;\n\n\n\n/* ****************************************************************************\n * Handle the options                                                         *\n *****************************************************************************/\nvar\n\ndefaultLabelOptions = {\n	enabled: true,\n	// rotation: 0,\n	align: 'center',\n	x: 0,\n	y: 15,\n	/*formatter: function () {\n		return this.value;\n	},*/\n	style: {\n		color: '#666',\n		fontSize: '11px',\n		lineHeight: '14px'\n	}\n};\n\ndefaultOptions = {\n	colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',\n		'#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],\n	symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],\n	lang: {\n		loading: 'Loading...',\n		months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',\n				'August', 'September', 'October', 'November', 'December'],\n		shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n		weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n		decimalPoint: '.',\n		numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels\n		resetZoom: 'Reset zoom',\n		resetZoomTitle: 'Reset zoom level 1:1',\n		thousandsSep: ','\n	},\n	global: {\n		useUTC: true,\n		canvasToolsURL: 'http://code.highcharts.com/2.3.5/modules/canvas-tools.js',\n		VMLRadialGradientURL: 'http://code.highcharts.com/2.3.5/gfx/vml-radial-gradient.png'\n	},\n	chart: {\n		//animation: true,\n		//alignTicks: false,\n		//reflow: true,\n		//className: null,\n		//events: { load, selection },\n		//margin: [null],\n		//marginTop: null,\n		//marginRight: null,\n		//marginBottom: null,\n		//marginLeft: null,\n		borderColor: '#4572A7',\n		//borderWidth: 0,\n		borderRadius: 5,\n		defaultSeriesType: 'line',\n		ignoreHiddenSeries: true,\n		//inverted: false,\n		//shadow: false,\n		spacingTop: 10,\n		spacingRight: 10,\n		spacingBottom: 15,\n		spacingLeft: 10,\n		style: {\n			fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif', // default font\n			fontSize: '12px'\n		},\n		backgroundColor: '#FFFFFF',\n		//plotBackgroundColor: null,\n		plotBorderColor: '#C0C0C0',\n		//plotBorderWidth: 0,\n		//plotShadow: false,\n		//zoomType: ''\n		resetZoomButton: {\n			theme: {\n				zIndex: 20\n			},\n			position: {\n				align: 'right',\n				x: -10,\n				//verticalAlign: 'top',\n				y: 10\n			}\n			// relativeTo: 'plot'\n		}\n	},\n	title: {\n		text: 'Chart title',\n		align: 'center',\n		// floating: false,\n		// margin: 15,\n		// x: 0,\n		// verticalAlign: 'top',\n		y: 15,\n		style: {\n			color: '#3E576F',\n			fontSize: '16px'\n		}\n\n	},\n	subtitle: {\n		text: '',\n		align: 'center',\n		// floating: false\n		// x: 0,\n		// verticalAlign: 'top',\n		y: 30,\n		style: {\n			color: '#6D869F'\n		}\n	},\n\n	plotOptions: {\n		line: { // base series options\n			allowPointSelect: false,\n			showCheckbox: false,\n			animation: {\n				duration: 1000\n			},\n			//connectNulls: false,\n			//cursor: 'default',\n			//clip: true,\n			//dashStyle: null,\n			//enableMouseTracking: true,\n			events: {},\n			//legendIndex: 0,\n			lineWidth: 2,\n			shadow: true,\n			// stacking: null,\n			marker: {\n				enabled: true,\n				//symbol: null,\n				lineWidth: 0,\n				radius: 4,\n				lineColor: '#FFFFFF',\n				//fillColor: null,\n				states: { // states for a single point\n					hover: {\n						enabled: true\n						//radius: base + 2\n					},\n					select: {\n						fillColor: '#FFFFFF',\n						lineColor: '#000000',\n						lineWidth: 2\n					}\n				}\n			},\n			point: {\n				events: {}\n			},\n			dataLabels: merge(defaultLabelOptions, {\n				enabled: false,\n				formatter: function () {\n					return this.y;\n				},\n				verticalAlign: 'bottom', // above singular point\n				y: 0\n				// backgroundColor: undefined,\n				// borderColor: undefined,\n				// borderRadius: undefined,\n				// borderWidth: undefined,\n				// padding: 3,\n				// shadow: false\n			}),\n			cropThreshold: 300, // draw points outside the plot area when the number of points is less than this\n			pointRange: 0,\n			//pointStart: 0,\n			//pointInterval: 1,\n			showInLegend: true,\n			states: { // states for the entire series\n				hover: {\n					//enabled: false,\n					//lineWidth: base + 1,\n					marker: {\n						// lineWidth: base + 1,\n						// radius: base + 1\n					}\n				},\n				select: {\n					marker: {}\n				}\n			},\n			stickyTracking: true\n			//tooltip: {\n				//pointFormat: '<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.y}</b>'\n				//valueDecimals: null,\n				//xDateFormat: '%A, %b %e, %Y',\n				//valuePrefix: '',\n				//ySuffix: ''				\n			//}\n			// turboThreshold: 1000\n			// zIndex: null\n		}\n	},\n	labels: {\n		//items: [],\n		style: {\n			//font: defaultFont,\n			position: ABSOLUTE,\n			color: '#3E576F'\n		}\n	},\n	legend: {\n		enabled: true,\n		align: 'center',\n		//floating: false,\n		layout: 'horizontal',\n		labelFormatter: function () {\n			return this.name;\n		},\n		borderWidth: 1,\n		borderColor: '#909090',\n		borderRadius: 5,\n		navigation: {\n			// animation: true,\n			activeColor: '#3E576F',\n			// arrowSize: 12\n			inactiveColor: '#CCC'\n			// style: {} // text styles\n		},\n		// margin: 10,\n		// reversed: false,\n		shadow: false,\n		// backgroundColor: null,\n		/*style: {\n			padding: '5px'\n		},*/\n		itemStyle: {\n			cursor: 'pointer',\n			color: '#3E576F',\n			fontSize: '12px'\n		},\n		itemHoverStyle: {\n			//cursor: 'pointer', removed as of #601\n			color: '#000'\n		},\n		itemHiddenStyle: {\n			color: '#CCC'\n		},\n		itemCheckboxStyle: {\n			position: ABSOLUTE,\n			width: '13px', // for IE precision\n			height: '13px'\n		},\n		// itemWidth: undefined,\n		symbolWidth: 16,\n		symbolPadding: 5,\n		verticalAlign: 'bottom',\n		// width: undefined,\n		x: 0,\n		y: 0\n	},\n\n	loading: {\n		// hideDuration: 100,\n		labelStyle: {\n			fontWeight: 'bold',\n			position: RELATIVE,\n			top: '1em'\n		},\n		// showDuration: 0,\n		style: {\n			position: ABSOLUTE,\n			backgroundColor: 'white',\n			opacity: 0.5,\n			textAlign: 'center'\n		}\n	},\n\n	tooltip: {\n		enabled: true,\n		//crosshairs: null,\n		backgroundColor: 'rgba(255, 255, 255, .85)',\n		borderWidth: 2,\n		borderRadius: 5,\n		dateTimeLabelFormats: { \n			millisecond: '%A, %b %e, %H:%M:%S.%L',\n			second: '%A, %b %e, %H:%M:%S',\n			minute: '%A, %b %e, %H:%M',\n			hour: '%A, %b %e, %H:%M',\n			day: '%A, %b %e, %Y',\n			week: 'Week from %A, %b %e, %Y',\n			month: '%B %Y',\n			year: '%Y'\n		},\n		//formatter: defaultFormatter,\n		headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n		pointFormat: '<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.y}</b><br/>',\n		shadow: true,\n		shared: useCanVG,\n		snap: isTouchDevice ? 25 : 10,\n		style: {\n			color: '#333333',\n			fontSize: '12px',\n			padding: '5px',\n			whiteSpace: 'nowrap'\n		}\n		//xDateFormat: '%A, %b %e, %Y',\n		//valueDecimals: null,\n		//valuePrefix: '',\n		//valueSuffix: ''\n	},\n\n	credits: {\n		enabled: true,\n		text: 'Highcharts.com',\n		href: 'http://www.highcharts.com',\n		position: {\n			align: 'right',\n			x: -10,\n			verticalAlign: 'bottom',\n			y: -5\n		},\n		style: {\n			cursor: 'pointer',\n			color: '#909090',\n			fontSize: '10px'\n		}\n	}\n};\n\n\n\n\n// Series defaults\nvar defaultPlotOptions = defaultOptions.plotOptions,\n	defaultSeriesOptions = defaultPlotOptions.line;\n\n// set the default time methods\nsetTimeMethods();\n\n\n\n/**\n * Set the time methods globally based on the useUTC option. Time method can be either\n * local time or UTC (default).\n */\nfunction setTimeMethods() {\n	var useUTC = defaultOptions.global.useUTC,\n		GET = useUTC ? 'getUTC' : 'get',\n		SET = useUTC ? 'setUTC' : 'set';\n\n	makeTime = useUTC ? Date.UTC : function (year, month, date, hours, minutes, seconds) {\n		return new Date(\n			year,\n			month,\n			pick(date, 1),\n			pick(hours, 0),\n			pick(minutes, 0),\n			pick(seconds, 0)\n		).getTime();\n	};\n	getMinutes =  GET + 'Minutes';\n	getHours =    GET + 'Hours';\n	getDay =      GET + 'Day';\n	getDate =     GET + 'Date';\n	getMonth =    GET + 'Month';\n	getFullYear = GET + 'FullYear';\n	setMinutes =  SET + 'Minutes';\n	setHours =    SET + 'Hours';\n	setDate =     SET + 'Date';\n	setMonth =    SET + 'Month';\n	setFullYear = SET + 'FullYear';\n\n}\n\n/**\n * Merge the default options with custom options and return the new options structure\n * @param {Object} options The new custom options\n */\nfunction setOptions(options) {\n	\n	// Pull out axis options and apply them to the respective default axis options \n	/*defaultXAxisOptions = merge(defaultXAxisOptions, options.xAxis);\n	defaultYAxisOptions = merge(defaultYAxisOptions, options.yAxis);\n	options.xAxis = options.yAxis = UNDEFINED;*/\n	\n	// Merge in the default options\n	defaultOptions = merge(defaultOptions, options);\n	\n	// Apply UTC\n	setTimeMethods();\n\n	return defaultOptions;\n}\n\n/**\n * Get the updated default options. Merely exposing defaultOptions for outside modules\n * isn't enough because the setOptions method creates a new object.\n */\nfunction getOptions() {\n	return defaultOptions;\n}\n\n\n\n/**\n * Handle color operations. The object methods are chainable.\n * @param {String} input The input color in either rbga or hex format\n */\nvar Color = function (input) {\n	// declare variables\n	var rgba = [], result;\n\n	/**\n	 * Parse the input color to rgba array\n	 * @param {String} input\n	 */\n	function init(input) {\n\n		// rgba\n		result = /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/.exec(input);\n		if (result) {\n			rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];\n		} else { // hex\n			result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(input);\n			if (result) {\n				rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];\n			}\n		}\n\n	}\n	/**\n	 * Return the color a specified format\n	 * @param {String} format\n	 */\n	function get(format) {\n		var ret;\n\n		// it's NaN if gradient colors on a column chart\n		if (rgba && !isNaN(rgba[0])) {\n			if (format === 'rgb') {\n				ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';\n			} else if (format === 'a') {\n				ret = rgba[3];\n			} else {\n				ret = 'rgba(' + rgba.join(',') + ')';\n			}\n		} else {\n			ret = input;\n		}\n		return ret;\n	}\n\n	/**\n	 * Brighten the color\n	 * @param {Number} alpha\n	 */\n	function brighten(alpha) {\n		if (isNumber(alpha) && alpha !== 0) {\n			var i;\n			for (i = 0; i < 3; i++) {\n				rgba[i] += pInt(alpha * 255);\n\n				if (rgba[i] < 0) {\n					rgba[i] = 0;\n				}\n				if (rgba[i] > 255) {\n					rgba[i] = 255;\n				}\n			}\n		}\n		return this;\n	}\n	/**\n	 * Set the color's opacity to a given alpha value\n	 * @param {Number} alpha\n	 */\n	function setOpacity(alpha) {\n		rgba[3] = alpha;\n		return this;\n	}\n\n	// initialize: parse the input\n	init(input);\n\n	// public methods\n	return {\n		get: get,\n		brighten: brighten,\n		setOpacity: setOpacity\n	};\n};\n\n\n/**\n * A wrapper object for SVG elements\n */\nfunction SVGElement() {}\n\nSVGElement.prototype = {\n	/**\n	 * Initialize the SVG renderer\n	 * @param {Object} renderer\n	 * @param {String} nodeName\n	 */\n	init: function (renderer, nodeName) {\n		var wrapper = this;\n		wrapper.element = nodeName === 'span' ?\n			createElement(nodeName) :\n			doc.createElementNS(SVG_NS, nodeName);\n		wrapper.renderer = renderer;\n		/**\n		 * A collection of attribute setters. These methods, if defined, are called right before a certain\n		 * attribute is set on an element wrapper. Returning false prevents the default attribute\n		 * setter to run. Returning a value causes the default setter to set that value. Used in\n		 * Renderer.label.\n		 */\n		wrapper.attrSetters = {};\n	},\n	/**\n	 * Animate a given attribute\n	 * @param {Object} params\n	 * @param {Number} options The same options as in jQuery animation\n	 * @param {Function} complete Function to perform at the end of animation\n	 */\n	animate: function (params, options, complete) {\n		var animOptions = pick(options, globalAnimation, true);\n		stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)\n		if (animOptions) {\n			animOptions = merge(animOptions);\n			if (complete) { // allows using a callback with the global animation without overwriting it\n				animOptions.complete = complete;\n			}\n			animate(this, params, animOptions);\n		} else {\n			this.attr(params);\n			if (complete) {\n				complete();\n			}\n		}\n	},\n	/**\n	 * Set or get a given attribute\n	 * @param {Object|String} hash\n	 * @param {Mixed|Undefined} val\n	 */\n	attr: function (hash, val) {\n		var wrapper = this,\n			key,\n			value,\n			result,\n			i,\n			child,\n			element = wrapper.element,\n			nodeName = element.nodeName.toLowerCase(), // Android2 requires lower for \"text\"\n			renderer = wrapper.renderer,\n			skipAttr,\n			titleNode,\n			attrSetters = wrapper.attrSetters,\n			shadows = wrapper.shadows,\n			hasSetSymbolSize,\n			doTransform,\n			ret = wrapper;\n\n		// single key-value pair\n		if (isString(hash) && defined(val)) {\n			key = hash;\n			hash = {};\n			hash[key] = val;\n		}\n\n		// used as a getter: first argument is a string, second is undefined\n		if (isString(hash)) {\n			key = hash;\n			if (nodeName === 'circle') {\n				key = { x: 'cx', y: 'cy' }[key] || key;\n			} else if (key === 'strokeWidth') {\n				key = 'stroke-width';\n			}\n			ret = attr(element, key) || wrapper[key] || 0;\n\n			if (key !== 'd' && key !== 'visibility') { // 'd' is string in animation step\n				ret = parseFloat(ret);\n			}\n\n		// setter\n		} else {\n\n			for (key in hash) {\n				skipAttr = false; // reset\n				value = hash[key];\n\n				// check for a specific attribute setter\n				result = attrSetters[key] && attrSetters[key].call(wrapper, value, key);\n\n				if (result !== false) {\n					if (result !== UNDEFINED) {\n						value = result; // the attribute setter has returned a new value to set\n					}\n\n					// paths\n					if (key === 'd') {\n						if (value && value.join) { // join path\n							value = value.join(' ');\n						}\n						if (/(NaN| {2}|^$)/.test(value)) {\n							value = 'M 0 0';\n						}\n						//wrapper.d = value; // shortcut for animations\n\n					// update child tspans x values\n					} else if (key === 'x' && nodeName === 'text') {\n						for (i = 0; i < element.childNodes.length; i++) {\n							child = element.childNodes[i];\n							// if the x values are equal, the tspan represents a linebreak\n							if (attr(child, 'x') === attr(element, 'x')) {\n								//child.setAttribute('x', value);\n								attr(child, 'x', value);\n							}\n						}\n\n						if (wrapper.rotation) {\n							attr(element, 'transform', 'rotate(' + wrapper.rotation + ' ' + value + ' ' +\n								pInt(hash.y || attr(element, 'y')) + ')');\n						}\n\n					// apply gradients\n					} else if (key === 'fill') {\n						value = renderer.color(value, element, key);\n\n					// circle x and y\n					} else if (nodeName === 'circle' && (key === 'x' || key === 'y')) {\n						key = { x: 'cx', y: 'cy' }[key] || key;\n\n					// rectangle border radius\n					} else if (nodeName === 'rect' && key === 'r') {\n						attr(element, {\n							rx: value,\n							ry: value\n						});\n						skipAttr = true;\n\n					// translati");
        builder.append("on and text rotation\n					} else if (key === 'translateX' || key === 'translateY' || key === 'rotation' || key === 'verticalAlign') {\n						doTransform = true;\n						skipAttr = true;\n\n					// apply opacity as subnode (required by legacy WebKit and Batik)\n					} else if (key === 'stroke') {\n						value = renderer.color(value, element, key);\n\n					// emulate VML's dashstyle implementation\n					} else if (key === 'dashstyle') {\n						key = 'stroke-dasharray';\n						value = value && value.toLowerCase();\n						if (value === 'solid') {\n							value = NONE;\n						} else if (value) {\n							value = value\n								.replace('shortdashdotdot', '3,1,1,1,1,1,')\n								.replace('shortdashdot', '3,1,1,1')\n								.replace('shortdot', '1,1,')\n								.replace('shortdash', '3,1,')\n								.replace('longdash', '8,3,')\n								.replace(/dot/g, '1,3,')\n								.replace('dash', '4,3,')\n								.replace(/,$/, '')\n								.split(','); // ending comma\n\n							i = value.length;\n							while (i--) {\n								value[i] = pInt(value[i]) * hash['stroke-width'];\n							}\n							value = value.join(',');\n						}\n\n					// special\n					} else if (key === 'isTracker') {\n						wrapper[key] = value;\n\n					// IE9/MooTools combo: MooTools returns objects instead of numbers and IE9 Beta 2\n					// is unable to cast them. Test again with final IE9.\n					} else if (key === 'width') {\n						value = pInt(value);\n\n					// Text alignment\n					} else if (key === 'align') {\n						key = 'text-anchor';\n						value = { left: 'start', center: 'middle', right: 'end' }[value];\n\n					// Title requires a subnode, #431\n					} else if (key === 'title') {\n						titleNode = element.getElementsByTagName('title')[0];\n						if (!titleNode) {\n							titleNode = doc.createElementNS(SVG_NS, 'title');\n							element.appendChild(titleNode);\n						}\n						titleNode.textContent = value;\n					}\n\n					// jQuery animate changes case\n					if (key === 'strokeWidth') {\n						key = 'stroke-width';\n					}\n\n					// Chrome/Win < 6 bug (http://code.google.com/p/chromium/issues/detail?id=15461), #1369\n					if (key === 'stroke-width' && value === 0 && (isWebKit || renderer.forExport)) {\n						value = 0.000001;\n					}\n\n					// symbols\n					if (wrapper.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {\n\n\n						if (!hasSetSymbolSize) {\n							wrapper.symbolAttr(hash);\n							hasSetSymbolSize = true;\n						}\n						skipAttr = true;\n					}\n\n					// let the shadow follow the main element\n					if (shadows && /^(width|height|visibility|x|y|d|transform)$/.test(key)) {\n						i = shadows.length;\n						while (i--) {\n							attr(\n								shadows[i], \n								key, \n								key === 'height' ? \n									mathMax(value - (shadows[i].cutHeight || 0), 0) :\n									value\n							);\n						}\n					}\n\n					// validate heights\n					if ((key === 'width' || key === 'height') && nodeName === 'rect' && value < 0) {\n						value = 0;\n					}\n\n					// Record for animation and quick access without polling the DOM\n					wrapper[key] = value;\n					\n					// Update transform\n					if (doTransform) {\n						wrapper.updateTransform();\n					}\n\n\n					if (key === 'text') {\n						// Delete bBox memo when the text changes\n						if (value !== wrapper.textStr) {\n							delete wrapper.bBox;\n						}\n						wrapper.textStr = value;\n						if (wrapper.added) {\n							renderer.buildText(wrapper);\n						}\n					} else if (!skipAttr) {\n						attr(element, key, value);\n					}\n\n				}\n\n			}\n\n		}\n		\n		return ret;\n	},\n\n	/**\n	 * If one of the symbol size affecting parameters are changed,\n	 * check all the others only once for each call to an element's\n	 * .attr() method\n	 * @param {Object} hash\n	 */\n	symbolAttr: function (hash) {\n		var wrapper = this;\n\n		each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {\n			wrapper[key] = pick(hash[key], wrapper[key]);\n		});\n\n		wrapper.attr({\n			d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)\n		});\n	},\n\n	/**\n	 * Apply a clipping path to this object\n	 * @param {String} id\n	 */\n	clip: function (clipRect) {\n		return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);\n	},\n\n	/**\n	 * Calculate the coordinates needed for drawing a rectangle crisply and return the\n	 * calculated attributes\n	 * @param {Number} strokeWidth\n	 * @param {Number} x\n	 * @param {Number} y\n	 * @param {Number} width\n	 * @param {Number} height\n	 */\n	crisp: function (strokeWidth, x, y, width, height) {\n\n		var wrapper = this,\n			key,\n			attribs = {},\n			values = {},\n			normalizer;\n\n		strokeWidth = strokeWidth || wrapper.strokeWidth || (wrapper.attr && wrapper.attr('stroke-width')) || 0;\n		normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors\n\n		// normalize for crisp edges\n		values.x = mathFloor(x || wrapper.x || 0) + normalizer;\n		values.y = mathFloor(y || wrapper.y || 0) + normalizer;\n		values.width = mathFloor((width || wrapper.width || 0) - 2 * normalizer);\n		values.height = mathFloor((height || wrapper.height || 0) - 2 * normalizer);\n		values.strokeWidth = strokeWidth;\n\n		for (key in values) {\n			if (wrapper[key] !== values[key]) { // only set attribute if changed\n				wrapper[key] = attribs[key] = values[key];\n			}\n		}\n\n		return attribs;\n	},\n\n	/**\n	 * Set styles for the element\n	 * @param {Object} styles\n	 */\n	css: function (styles) {\n		/*jslint unparam: true*//* allow unused param a in the regexp function below */\n		var elemWrapper = this,\n			elem = elemWrapper.element,\n			textWidth = styles && styles.width && elem.nodeName.toLowerCase() === 'text',\n			n,\n			serializedCss = '',\n			hyphenate = function (a, b) { return '-' + b.toLowerCase(); };\n		/*jslint unparam: false*/\n\n		// convert legacy\n		if (styles && styles.color) {\n			styles.fill = styles.color;\n		}\n\n		// Merge the new styles with the old ones\n		styles = extend(\n			elemWrapper.styles,\n			styles\n		);\n\n		// store object\n		elemWrapper.styles = styles;\n		\n		\n		// Don't handle line wrap on canvas\n		if (useCanVG && textWidth) {\n			delete styles.width;\n		}\n			\n		// serialize and set style attribute\n		if (isIE && !hasSVG) { // legacy IE doesn't support setting style attribute\n			if (textWidth) {\n				delete styles.width;\n			}\n			css(elemWrapper.element, styles);\n		} else {\n			for (n in styles) {\n				serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';\n			}\n			elemWrapper.attr({\n				style: serializedCss\n			});\n		}\n\n\n		// re-build text\n		if (textWidth && elemWrapper.added) {\n			elemWrapper.renderer.buildText(elemWrapper);\n		}\n\n		return elemWrapper;\n	},\n\n	/**\n	 * Add an event listener\n	 * @param {String} eventType\n	 * @param {Function} handler\n	 */\n	on: function (eventType, handler) {\n		// touch\n		if (hasTouch && eventType === 'click') {\n			this.element.ontouchstart = function (e) {\n				e.preventDefault();\n				handler();\n			};\n		}\n		// simplest possible event model for internal use\n		this.element['on' + eventType] = handler;\n		return this;\n	},\n	\n	/**\n	 * Set the coordinates needed to draw a consistent radial gradient across\n	 * pie slices regardless of positioning inside the chart. The format is\n	 * [centerX, centerY, diameter] in pixels.\n	 */\n	setRadialReference: function (coordinates) {\n		this.element.radialReference = coordinates;\n		return this;\n	},\n\n	/**\n	 * Move an object and its children by x and y values\n	 * @param {Number} x\n	 * @param {Number} y\n	 */\n	translate: function (x, y) {\n		return this.attr({\n			translateX: x,\n			translateY: y\n		});\n	},\n\n	/**\n	 * Invert a group, rotate and flip\n	 */\n	invert: function () {\n		var wrapper = this;\n		wrapper.inverted = true;\n		wrapper.updateTransform();\n		return wrapper;\n	},\n\n	/**\n	 * Apply CSS to HTML elements. This is used in text within SVG rendering and\n	 * by the VML renderer\n	 */\n	htmlCss: function (styles) {\n		var wrapper = this,\n			element = wrapper.element,\n			textWidth = styles && element.tagName === 'SPAN' && styles.width;\n\n		if (textWidth) {\n			delete styles.width;\n			wrapper.textWidth = textWidth;\n			wrapper.updateTransform();\n		}\n\n		wrapper.styles = extend(wrapper.styles, styles);\n		css(wrapper.element, styles);\n\n		return wrapper;\n	},\n\n\n\n	/**\n	 * VML and useHTML method for calculating the bounding box based on offsets\n	 * @param {Boolean} refresh Whether to force a fresh value from the DOM or to\n	 * use the cached value\n	 *\n	 * @return {Object} A hash containing values for x, y, width and height\n	 */\n\n	htmlGetBBox: function () {\n		var wrapper = this,\n			element = wrapper.element,\n			bBox = wrapper.bBox;\n\n		// faking getBBox in exported SVG in legacy IE\n		if (!bBox) {\n			// faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)\n			if (element.nodeName === 'text') {\n				element.style.position = ABSOLUTE;\n			}\n\n			bBox = wrapper.bBox = {\n				x: element.offsetLeft,\n				y: element.offsetTop,\n				width: element.offsetWidth,\n				height: element.offsetHeight\n			};\n		}\n\n		return bBox;\n	},\n\n	/**\n	 * VML override private method to update elements based on internal\n	 * properties based on SVG transform\n	 */\n	htmlUpdateTransform: function () {\n		// aligning non added elements is expensive\n		if (!this.added) {\n			this.alignOnAdd = true;\n			return;\n		}\n\n		var wrapper = this,\n			renderer = wrapper.renderer,\n			elem = wrapper.element,\n			translateX = wrapper.translateX || 0,\n			translateY = wrapper.translateY || 0,\n			x = wrapper.x || 0,\n			y = wrapper.y || 0,\n			align = wrapper.textAlign || 'left',\n			alignCorrection = { left: 0, center: 0.5, right: 1 }[align],\n			nonLeft = align && align !== 'left',\n			shadows = wrapper.shadows;\n\n		// apply translate\n		if (translateX || translateY) {\n			css(elem, {\n				marginLeft: translateX,\n				marginTop: translateY\n			});\n			if (shadows) { // used in labels/tooltip\n				each(shadows, function (shadow) {\n					css(shadow, {\n						marginLeft: translateX + 1,\n						marginTop: translateY + 1\n					});\n				});\n			}\n		}\n\n		// apply inversion\n		if (wrapper.inverted) { // wrapper is a group\n			each(elem.childNodes, function (child) {\n				renderer.invertChild(child, elem);\n			});\n		}\n\n		if (elem.tagName === 'SPAN') {\n\n			var width, height,\n				rotation = wrapper.rotation,\n				baseline,\n				radians = 0,\n				costheta = 1,\n				sintheta = 0,\n				quad,\n				textWidth = pInt(wrapper.textWidth),\n				xCorr = wrapper.xCorr || 0,\n				yCorr = wrapper.yCorr || 0,\n				currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(','),\n				rotationStyle = {},\n				cssTransformKey;\n\n			if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed\n\n				if (defined(rotation)) {\n					\n					if (renderer.isSVG) { // #916\n						cssTransformKey = isIE ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';\n						rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';\n						\n					} else {\n						radians = rotation * deg2rad; // deg to rad\n						costheta = mathCos(radians);\n						sintheta = mathSin(radians);\n	\n						// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented\n						// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+\n						// has support for CSS3 transform. The getBBox method also needs to be updated\n						// to compensate for the rotation, like it currently does for SVG.\n						// Test case: http://highcharts.com/tests/?file=text-rotation\n						rotationStyle.filter = rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,\n								', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,\n								', sizingMethod=\\'auto expand\\')'].join('') : NONE;\n					}\n					css(elem, rotationStyle);\n				}\n\n				width = pick(wrapper.elemWidth, elem.offsetWidth);\n				height = pick(wrapper.elemHeight, elem.offsetHeight);\n\n				// update textWidth\n				if (width > textWidth && /[ \\-]/.test(elem.textContent || elem.innerText)) { // #983, #1254\n					css(elem, {\n						width: textWidth + PX,\n						display: 'block',\n						whiteSpace: 'normal'\n					});\n					width = textWidth;\n				}\n\n				// correct x and y\n				baseline = renderer.fontMetrics(elem.style.fontSize).b;\n				xCorr = costheta < 0 && -width;\n				yCorr = sintheta < 0 && -height;\n\n				// correct for baseline and corners spilling out after rotation\n				quad = costheta * sintheta < 0;\n				xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);\n				yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);\n\n				// correct for the length/height of the text\n				if (nonLeft) {\n					xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);\n					if (rotation) {\n						yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);\n					}\n					css(elem, {\n						textAlign: align\n					});\n				}\n\n				// record correction\n				wrapper.xCorr = xCorr;\n				wrapper.yCorr = yCorr;\n			}\n\n			// apply position with correction\n			css(elem, {\n				left: (x + xCorr) + PX,\n				top: (y + yCorr) + PX\n			});\n			\n			// force reflow in webkit to apply the left and top on useHTML element (#1249)\n			if (isWebKit) {\n				height = elem.offsetHeight; // assigned to height for JSLint purpose\n			}\n\n			// record current text transform\n			wrapper.cTT = currentTextTransform;\n		}\n	},\n\n	/**\n	 * Private method to update the transform attribute based on internal\n	 * properties\n	 */\n	updateTransform: function () {\n		var wrapper = this,\n			translateX = wrapper.translateX || 0,\n			translateY = wrapper.translateY || 0,\n			inverted = wrapper.inverted,\n			rotation = wrapper.rotation,\n			transform = [];\n\n		// flipping affects translate as adjustment for flipping around the group's axis\n		if (inverted) {\n			translateX += wrapper.attr('width');\n			translateY += wrapper.attr('height');\n		}\n\n		// apply translate\n		if (translateX || translateY) {\n			transform.push('translate(' + translateX + ',' + translateY + ')');\n		}\n\n		// apply rotation\n		if (inverted) {\n			transform.push('rotate(90) scale(-1,1)');\n		} else if (rotation) { // text rotation\n			transform.push('rotate(' + rotation + ' ' + (wrapper.x || 0) + ' ' + (wrapper.y || 0) + ')');\n		}\n\n		if (transform.length) {\n			attr(wrapper.element, 'transform', transform.join(' '));\n		}\n	},\n	/**\n	 * Bring the element to the front\n	 */\n	toFront: function () {\n		var element = this.element;\n		element.parentNode.appendChild(element);\n		return this;\n	},\n\n\n	/**\n	 * Break down alignment options like align, verticalAlign, x and y\n	 * to x and y relative to the chart.\n	 *\n	 * @param {Object} alignOptions\n	 * @param {Boolean} alignByTranslate\n	 * @param {Object} box The box to align to, needs a width and height\n	 *\n	 */\n	align: function (alignOptions, alignByTranslate, box) {\n		var elemWrapper = this;\n\n		if (!alignOptions) { // called on resize\n			alignOptions = elemWrapper.alignOptions;\n			alignByTranslate = elemWrapper.alignByTranslate;\n		} else { // first call on instanciate\n			elemWrapper.alignOptions = alignOptions;\n			elemWrapper.alignByTranslate = alignByTranslate;\n			if (!box) { // boxes other than renderer handle this internally\n				elemWrapper.renderer.alignedObjects.push(elemWrapper);\n			}\n		}\n\n		box = pick(box, elemWrapper.renderer);\n\n		var align = alignOptions.align,\n			vAlign = alignOptions.verticalAlign,\n			x = (box.x || 0) + (alignOptions.x || 0), // default: left align\n			y = (box.y || 0) + (alignOptions.y || 0), // default: top align\n			attribs = {};\n\n\n		// align\n		if (align === 'right' || align === 'center') {\n			x += (box.width - (alignOptions.width || 0)) /\n					{ right: 1, center: 2 }[align];\n		}\n		attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);\n\n\n		// vertical align\n		if (vAlign === 'bottom' || vAlign === 'middle') {\n			y += (box.height - (alignOptions.height || 0)) /\n					({ bottom: 1, middle: 2 }[vAlign] || 1);\n\n		}\n		attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);\n\n		// animate only if already placed\n		elemWrapper[elemWrapper.placed ? 'animate' : 'attr'](attribs);\n		elemWrapper.placed = true;\n		elemWrapper.alignAttr = attribs;\n\n		return elemWrapper;\n	},\n\n	/**\n	 * Get the bounding box (width, height, x and y) for the element\n	 */\n	getBBox: function () {\n		var wrapper = this,\n			bBox = wrapper.bBox,\n			renderer = wrapper.renderer,\n			width,\n			height,\n			rotation = wrappe");
        builder.append("r.rotation,\n			element = wrapper.element,\n			styles = wrapper.styles,\n			rad = rotation * deg2rad;\n			\n		if (!bBox) {\n			// SVG elements\n			if (element.namespaceURI === SVG_NS || renderer.forExport) {\n				try { // Fails in Firefox if the container has display: none.\n					\n					bBox = element.getBBox ?\n						// SVG: use extend because IE9 is not allowed to change width and height in case\n						// of rotation (below)\n						extend({}, element.getBBox()) :\n						// Canvas renderer and legacy IE in export mode\n						{\n							width: element.offsetWidth,\n							height: element.offsetHeight\n						};\n				} catch (e) {}\n				\n				// If the bBox is not set, the try-catch block above failed. The other condition\n				// is for Opera that returns a width of -Infinity on hidden elements.\n				if (!bBox || bBox.width < 0) {\n					bBox = { width: 0, height: 0 };\n				}\n				\n	\n			// VML Renderer or useHTML within SVG\n			} else {\n				\n				bBox = wrapper.htmlGetBBox();\n				\n			}\n			\n			// True SVG elements as well as HTML elements in modern browsers using the .useHTML option\n			// need to compensated for rotation\n			if (renderer.isSVG) {\n				width = bBox.width;\n				height = bBox.height;\n				\n				// Workaround for wrong bounding box in IE9 and IE10 (#1101)\n				if (isIE && styles && styles.fontSize === '11px' && height === 22.700000762939453) {\n					bBox.height = height = 14;\n				}\n			\n				// Adjust for rotated text\n				if (rotation) {\n					bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));\n					bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));\n				}\n			}\n			\n			wrapper.bBox = bBox;\n		}\n		return bBox;\n	},\n\n	/**\n	 * Show the element\n	 */\n	show: function () {\n		return this.attr({ visibility: VISIBLE });\n	},\n\n	/**\n	 * Hide the element\n	 */\n	hide: function () {\n		return this.attr({ visibility: HIDDEN });\n	},\n	\n	/**\n	 * Add the element\n	 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined\n	 *    to append the element to the renderer.box.\n	 */\n	add: function (parent) {\n\n		var renderer = this.renderer,\n			parentWrapper = parent || renderer,\n			parentNode = parentWrapper.element || renderer.box,\n			childNodes = parentNode.childNodes,\n			element = this.element,\n			zIndex = attr(element, 'zIndex'),\n			otherElement,\n			otherZIndex,\n			i,\n			inserted;\n			\n		if (parent) {\n			this.parentGroup = parent;\n		}\n\n		// mark as inverted\n		this.parentInverted = parent && parent.inverted;\n\n		// build formatted text\n		if (this.textStr !== undefined) {\n			renderer.buildText(this);\n		}\n\n		// mark the container as having z indexed children\n		if (zIndex) {\n			parentWrapper.handleZ = true;\n			zIndex = pInt(zIndex);\n		}\n\n		// insert according to this and other elements' zIndex\n		if (parentWrapper.handleZ) { // this element or any of its siblings has a z index\n			for (i = 0; i < childNodes.length; i++) {\n				otherElement = childNodes[i];\n				otherZIndex = attr(otherElement, 'zIndex');\n				if (otherElement !== element && (\n						// insert before the first element with a higher zIndex\n						pInt(otherZIndex) > zIndex ||\n						// if no zIndex given, insert before the first element with a zIndex\n						(!defined(zIndex) && defined(otherZIndex))\n\n						)) {\n					parentNode.insertBefore(element, otherElement);\n					inserted = true;\n					break;\n				}\n			}\n		}\n\n		// default: append at the end\n		if (!inserted) {\n			parentNode.appendChild(element);\n		}\n\n		// mark as added\n		this.added = true;\n\n		// fire an event for internal hooks\n		fireEvent(this, 'add');\n\n		return this;\n	},\n\n	/**\n	 * Removes a child either by removeChild or move to garbageBin.\n	 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n	 */\n	safeRemoveChild: function (element) {\n		var parentNode = element.parentNode;\n		if (parentNode) {\n			parentNode.removeChild(element);\n		}\n	},\n\n	/**\n	 * Destroy the element and element wrapper\n	 */\n	destroy: function () {\n		var wrapper = this,\n			element = wrapper.element || {},\n			shadows = wrapper.shadows,\n			key,\n			i;\n\n		// remove events\n		element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = null;\n		stop(wrapper); // stop running animations\n\n		if (wrapper.clipPath) {\n			wrapper.clipPath = wrapper.clipPath.destroy();\n		}\n\n		// Destroy stops in case this is a gradient object\n		if (wrapper.stops) {\n			for (i = 0; i < wrapper.stops.length; i++) {\n				wrapper.stops[i] = wrapper.stops[i].destroy();\n			}\n			wrapper.stops = null;\n		}\n\n		// remove element\n		wrapper.safeRemoveChild(element);\n\n		// destroy shadows\n		if (shadows) {\n			each(shadows, function (shadow) {\n				wrapper.safeRemoveChild(shadow);\n			});\n		}\n\n		// remove from alignObjects\n		erase(wrapper.renderer.alignedObjects, wrapper);\n\n		for (key in wrapper) {\n			delete wrapper[key];\n		}\n\n		return null;\n	},\n\n	/**\n	 * Empty a group element\n	 */\n	empty: function () {\n		var element = this.element,\n			childNodes = element.childNodes,\n			i = childNodes.length;\n\n		while (i--) {\n			element.removeChild(childNodes[i]);\n		}\n	},\n\n	/**\n	 * Add a shadow to the element. Must be done after the element is added to the DOM\n	 * @param {Boolean|Object} shadowOptions\n	 */\n	shadow: function (shadowOptions, group, cutOff) {\n		var shadows = [],\n			i,\n			shadow,\n			element = this.element,\n			strokeWidth,\n			shadowWidth,\n			shadowElementOpacity,\n\n			// compensate for inverted plot area\n			transform;\n\n\n		if (shadowOptions) {\n			shadowWidth = pick(shadowOptions.width, 3);\n			shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n			transform = this.parentInverted ? \n				'(-1,-1)' : \n				'(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';\n			for (i = 1; i <= shadowWidth; i++) {\n				shadow = element.cloneNode(0);\n				strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n				attr(shadow, {\n					'isShadow': 'true',\n					'stroke': shadowOptions.color || 'black',\n					'stroke-opacity': shadowElementOpacity * i,\n					'stroke-width': strokeWidth,\n					'transform': 'translate' + transform,\n					'fill': NONE\n				});\n				if (cutOff) {\n					attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));\n					shadow.cutHeight = strokeWidth;\n				}\n\n				if (group) {\n					group.element.appendChild(shadow);\n				} else {\n					element.parentNode.insertBefore(shadow, element);\n				}\n\n				shadows.push(shadow);\n			}\n\n			this.shadows = shadows;\n		}\n		return this;\n\n	}\n};\n\n\n/**\n * The default SVG renderer\n */\nvar SVGRenderer = function () {\n	this.init.apply(this, arguments);\n};\nSVGRenderer.prototype = {\n	Element: SVGElement,\n\n	/**\n	 * Initialize the SVGRenderer\n	 * @param {Object} container\n	 * @param {Number} width\n	 * @param {Number} height\n	 * @param {Boolean} forExport\n	 */\n	init: function (container, width, height, forExport) {\n		var renderer = this,\n			loc = location,\n			boxWrapper;\n\n		boxWrapper = renderer.createElement('svg')\n			.attr({\n				xmlns: SVG_NS,\n				version: '1.1'\n			});\n		container.appendChild(boxWrapper.element);\n\n		// object properties\n		renderer.isSVG = true;\n		renderer.box = boxWrapper.element;\n		renderer.boxWrapper = boxWrapper;\n		renderer.alignedObjects = [];\n		\n		// Page url used for internal references. #24, #672, #1070\n		renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ? \n			loc.href\n				.replace(/#.*?$/, '') // remove the hash\n				.replace(/([\\('\\)])/g, '\\\\$1') // escape parantheses and quotes\n				.replace(/ /g, '%20') : // replace spaces (needed for Safari only)\n			''; \n			\n		renderer.defs = this.createElement('defs').add();\n		renderer.forExport = forExport;\n		renderer.gradients = {}; // Object where gradient SvgElements are stored\n\n		renderer.setSize(width, height, false);\n\n\n\n		// Issue 110 workaround:\n		// In Firefox, if a div is positioned by percentage, its pixel position may land\n		// between pixels. The container itself doesn't display this, but an SVG element\n		// inside this container will be drawn at subpixel precision. In order to draw\n		// sharp lines, this must be compensated for. This doesn't seem to work inside\n		// iframes though (like in jsFiddle).\n		var subPixelFix, rect;\n		if (isFirefox && container.getBoundingClientRect) {\n			renderer.subPixelFix = subPixelFix = function () {\n				css(container, { left: 0, top: 0 });\n				rect = container.getBoundingClientRect();\n				css(container, {\n					left: (mathCeil(rect.left) - rect.left) + PX,\n					top: (mathCeil(rect.top) - rect.top) + PX\n				});\n			};\n\n			// run the fix now\n			subPixelFix();\n\n			// run it on resize\n			addEvent(win, 'resize', subPixelFix);\n		}\n	},\n\n	/**\n	 * Detect whether the renderer is hidden. This happens when one of the parent elements\n	 * has display: none. #608.\n	 */\n	isHidden: function () {\n		return !this.boxWrapper.getBBox().width;			\n	},\n\n	/**\n	 * Destroys the renderer and its allocated members.\n	 */\n	destroy: function () {\n		var renderer = this,\n			rendererDefs = renderer.defs;\n		renderer.box = null;\n		renderer.boxWrapper = renderer.boxWrapper.destroy();\n\n		// Call destroy on all gradient elements\n		destroyObjectProperties(renderer.gradients || {});\n		renderer.gradients = null;\n\n		// Defs are null in VMLRenderer\n		// Otherwise, destroy them here.\n		if (rendererDefs) {\n			renderer.defs = rendererDefs.destroy();\n		}\n\n		// Remove sub pixel fix handler\n		// We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed\n		// See issue #982\n		if (renderer.subPixelFix) {\n			removeEvent(win, 'resize', renderer.subPixelFix);\n		}\n\n		renderer.alignedObjects = null;\n\n		return null;\n	},\n\n	/**\n	 * Create a wrapper for an SVG element\n	 * @param {Object} nodeName\n	 */\n	createElement: function (nodeName) {\n		var wrapper = new this.Element();\n		wrapper.init(this, nodeName);\n		return wrapper;\n	},\n\n	/**\n	 * Dummy function for use in canvas renderer\n	 */\n	draw: function () {},\n\n	/**\n	 * Parse a simple HTML string into SVG tspans\n	 *\n	 * @param {Object} textNode The parent text SVG node\n	 */\n	buildText: function (wrapper) {\n		var textNode = wrapper.element,\n			lines = pick(wrapper.textStr, '').toString()\n				.replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">')\n				.replace(/<(i|em)>/g, '<span style=\"font-style:italic\">')\n				.replace(/<a/g, '<span')\n				.replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n				.split(/<br.*?>/g),\n			childNodes = textNode.childNodes,\n			styleRegex = /style=\"([^\"]+)\"/,\n			hrefRegex = /href=\"([^\"]+)\"/,\n			parentX = attr(textNode, 'x'),\n			textStyles = wrapper.styles,\n			width = textStyles && textStyles.width && pInt(textStyles.width),\n			textLineHeight = textStyles && textStyles.lineHeight,\n			lastLine,\n			GET_COMPUTED_STYLE = 'getComputedStyle',\n			i = childNodes.length,\n			linePositions = [];\n		\n		// Needed in IE9 because it doesn't report tspan's offsetHeight (#893)\n		function getLineHeightByBBox(lineNo) {\n			linePositions[lineNo] = textNode.getBBox ?\n				textNode.getBBox().height :\n				wrapper.renderer.fontMetrics(textNode.style.fontSize).h; // #990\n			return mathRound(linePositions[lineNo] - (linePositions[lineNo - 1] || 0));\n		}\n\n		// remove old text\n		while (i--) {\n			textNode.removeChild(childNodes[i]);\n		}\n\n		if (width && !wrapper.added) {\n			this.box.appendChild(textNode); // attach it to the DOM to read offset width\n		}\n\n		// remove empty line at end\n		if (lines[lines.length - 1] === '') {\n			lines.pop();\n		}\n\n		// build the lines\n		each(lines, function (line, lineNo) {\n			var spans, spanNo = 0, lineHeight;\n\n			line = line.replace(/<span/g, '|||<span').replace(/<\\/span>/g, '</span>|||');\n			spans = line.split('|||');\n\n			each(spans, function (span) {\n				if (span !== '' || spans.length === 1) {\n					var attributes = {},\n						tspan = doc.createElementNS(SVG_NS, 'tspan'),\n						spanStyle; // #390\n					if (styleRegex.test(span)) {\n						spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');\n						attr(tspan, 'style', spanStyle);\n					}\n					if (hrefRegex.test(span)) {\n						attr(tspan, 'onclick', 'location.href=\\\"' + span.match(hrefRegex)[1] + '\\\"');\n						css(tspan, { cursor: 'pointer' });\n					}\n\n					span = (span.replace(/<(.|\\n)*?>/g, '') || ' ')\n						.replace(/&lt;/g, '<')\n						.replace(/&gt;/g, '>');\n\n					// issue #38 workaround.\n					/*if (reverse) {\n						arr = [];\n						i = span.length;\n						while (i--) {\n							arr.push(span.charAt(i));\n						}\n						span = arr.join('');\n					}*/\n\n					// add the text node\n					tspan.appendChild(doc.createTextNode(span));\n\n					if (!spanNo) { // first span in a line, align it to the left\n						attributes.x = parentX;\n					} else {\n						// Firefox ignores spaces at the front or end of the tspan\n						attributes.dx = 3; // space\n					}\n\n					// first span on subsequent line, add the line height\n					if (!spanNo) {\n						if (lineNo) {\n\n							// allow getting the right offset height in exporting in IE\n							if (!hasSVG && wrapper.renderer.forExport) {\n								css(tspan, { display: 'block' });\n							}\n\n							// Webkit and opera sometimes return 'normal' as the line height. In that\n							// case, webkit uses offsetHeight, while Opera falls back to 18\n							lineHeight = win[GET_COMPUTED_STYLE] &&\n								pInt(win[GET_COMPUTED_STYLE](lastLine, null).getPropertyValue('line-height'));\n\n							if (!lineHeight || isNaN(lineHeight)) {\n								lineHeight = textLineHeight || lastLine.offsetHeight || getLineHeightByBBox(lineNo) || 18;\n							}\n							attr(tspan, 'dy', lineHeight);\n						}\n						lastLine = tspan; // record for use in next line\n					}\n\n					// add attributes\n					attr(tspan, attributes);\n\n					// append it\n					textNode.appendChild(tspan);\n\n					spanNo++;\n\n					// check width and apply soft breaks\n					if (width) {\n						var words = span.replace(/([^\\^])-/g, '$1- ').split(' '), // #1273\n							tooLong,\n							actualWidth,\n							rest = [];\n\n						while (words.length || rest.length) {\n							delete wrapper.bBox; // delete cache\n							actualWidth = wrapper.getBBox().width;\n							tooLong = actualWidth > width;\n							if (!tooLong || words.length === 1) { // new line needed\n								words = rest;\n								rest = [];\n								if (words.length) {\n									tspan = doc.createElementNS(SVG_NS, 'tspan');\n									attr(tspan, {\n										dy: textLineHeight || 16,\n										x: parentX\n									});\n									if (spanStyle) { // #390\n										attr(tspan, 'style', spanStyle);\n									}\n									textNode.appendChild(tspan);\n\n									if (actualWidth > width) { // a single word is pressing it out\n										width = actualWidth;\n									}\n								}\n							} else { // append to existing line tspan\n								tspan.removeChild(tspan.firstChild);\n								rest.unshift(words.pop());\n							}\n							if (words.length) {\n								tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));\n							}\n						}\n					}\n				}\n			});\n		});\n	},\n\n	/**\n	 * Create a button with preset states\n	 * @param {String} text\n	 * @param {Number} x\n	 * @param {Number} y\n	 * @param {Function} callback\n	 * @param {Object} normalState\n	 * @param {Object} hoverState\n	 * @param {Object} pressedState\n	 */\n	button: function (text, x, y, callback, normalState, hoverState, pressedState) {\n		var label = this.label(text, x, y),\n			curState = 0,\n			stateOptions,\n			stateStyle,\n			normalStyle,\n			hoverStyle,\n			pressedStyle,\n			STYLE = 'style',\n			verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };\n\n		// prepare the attributes\n		/*jslint white: true*/\n		normalState = merge(hash(\n			STROKE_WIDTH, 1,\n			STROKE, '#999',\n			FILL, hash(\n				LINEAR_GRADIENT, verticalGradient,\n				STOPS, [\n					[0, '#FFF'],\n					[1, '#DDD']\n				]\n			),\n			'r', 3,\n			'padding', 3,\n			STYLE, hash(\n				'color', 'black'\n			)\n		), normalState);\n		/*jslint white: false*/\n		normalStyle = normalState[STYLE];\n		delete normalState[STYLE];\n\n		/*jslint white: true*/\n		hoverState = merge(normalState, hash(\n			STROKE, '#68A',\n			FILL, hash(\n				LINEAR_GRADIENT, verticalGradient,\n				STOPS, [\n					[0, '#FFF'],\n					[1, '#ACF']\n				]\n			)\n		), hoverState);\n		/*jslint white: false*/\n		hoverStyle = hoverState[STYLE];\n		delete hoverState[STYLE];\n\n		/*jslint white: true*/\n		pressedState = merge(normalState, hash(\n			STROKE, '#68A',\n			FILL, hash(\n				LINEAR_GRADIENT, verticalGradient,\n				STOPS, [\n					[0, '#9BD'],\n					[1, '#CDF']\n				]\n			)\n		), pressedState);\n		/*jslint white: false*/\n		pressedStyle = pressedState[ST");
        builder.append("YLE];\n		delete pressedState[STYLE];\n\n		// add the events\n		addEvent(label.element, 'mouseenter', function () {\n			label.attr(hoverState)\n				.css(hoverStyle);\n		});\n		addEvent(label.element, 'mouseleave', function () {\n			stateOptions = [normalState, hoverState, pressedState][curState];\n			stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];\n			label.attr(stateOptions)\n				.css(stateStyle);\n		});\n\n		label.setState = function (state) {\n			curState = state;\n			if (!state) {\n				label.attr(normalState)\n					.css(normalStyle);\n			} else if (state === 2) {\n				label.attr(pressedState)\n					.css(pressedStyle);\n			}\n		};\n\n		return label\n			.on('click', function () {\n				callback.call(label);\n			})\n			.attr(normalState)\n			.css(extend({ cursor: 'default' }, normalStyle));\n	},\n\n	/**\n	 * Make a straight line crisper by not spilling out to neighbour pixels\n	 * @param {Array} points\n	 * @param {Number} width\n	 */\n	crispLine: function (points, width) {\n		// points format: [M, 0, 0, L, 100, 0]\n		// normalize to a crisp line\n		if (points[1] === points[4]) {\n			// Substract due to #1129. Now bottom and left axis gridlines behave the same.\n			points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2); \n		}\n		if (points[2] === points[5]) {\n			points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);\n		}\n		return points;\n	},\n\n\n	/**\n	 * Draw a path\n	 * @param {Array} path An SVG path in array form\n	 */\n	path: function (path) {\n		var attr = {\n			fill: NONE\n		};\n		if (isArray(path)) {\n			attr.d = path;\n		} else if (isObject(path)) { // attributes\n			extend(attr, path);\n		}\n		return this.createElement('path').attr(attr);\n	},\n\n	/**\n	 * Draw and return an SVG circle\n	 * @param {Number} x The x position\n	 * @param {Number} y The y position\n	 * @param {Number} r The radius\n	 */\n	circle: function (x, y, r) {\n		var attr = isObject(x) ?\n			x :\n			{\n				x: x,\n				y: y,\n				r: r\n			};\n\n		return this.createElement('circle').attr(attr);\n	},\n\n	/**\n	 * Draw and return an arc\n	 * @param {Number} x X position\n	 * @param {Number} y Y position\n	 * @param {Number} r Radius\n	 * @param {Number} innerR Inner radius like used in donut charts\n	 * @param {Number} start Starting angle\n	 * @param {Number} end Ending angle\n	 */\n	arc: function (x, y, r, innerR, start, end) {\n		// arcs are defined as symbols for the ability to set\n		// attributes in attr and animate\n\n		if (isObject(x)) {\n			y = x.y;\n			r = x.r;\n			innerR = x.innerR;\n			start = x.start;\n			end = x.end;\n			x = x.x;\n		}\n		return this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {\n			innerR: innerR || 0,\n			start: start || 0,\n			end: end || 0\n		});\n	},\n	\n	/**\n	 * Draw and return a rectangle\n	 * @param {Number} x Left position\n	 * @param {Number} y Top position\n	 * @param {Number} width\n	 * @param {Number} height\n	 * @param {Number} r Border corner radius\n	 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing\n	 */\n	rect: function (x, y, width, height, r, strokeWidth) {\n		\n		r = isObject(x) ? x.r : r;\n		\n		var wrapper = this.createElement('rect').attr({\n				rx: r,\n				ry: r,\n				fill: NONE\n			});\n		return wrapper.attr(\n				isObject(x) ? \n					x : \n					// do not crispify when an object is passed in (as in column charts)\n					wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0))\n			);\n	},\n\n	/**\n	 * Resize the box and re-align all aligned elements\n	 * @param {Object} width\n	 * @param {Object} height\n	 * @param {Boolean} animate\n	 *\n	 */\n	setSize: function (width, height, animate) {\n		var renderer = this,\n			alignedObjects = renderer.alignedObjects,\n			i = alignedObjects.length;\n\n		renderer.width = width;\n		renderer.height = height;\n\n		renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({\n			width: width,\n			height: height\n		});\n\n		while (i--) {\n			alignedObjects[i].align();\n		}\n	},\n\n	/**\n	 * Create a group\n	 * @param {String} name The group will be given a class name of 'highcharts-{name}'.\n	 *     This can be used for styling and scripting.\n	 */\n	g: function (name) {\n		var elem = this.createElement('g');\n		return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;\n	},\n\n	/**\n	 * Display an image\n	 * @param {String} src\n	 * @param {Number} x\n	 * @param {Number} y\n	 * @param {Number} width\n	 * @param {Number} height\n	 */\n	image: function (src, x, y, width, height) {\n		var attribs = {\n				preserveAspectRatio: NONE\n			},\n			elemWrapper;\n\n		// optional properties\n		if (arguments.length > 1) {\n			extend(attribs, {\n				x: x,\n				y: y,\n				width: width,\n				height: height\n			});\n		}\n\n		elemWrapper = this.createElement('image').attr(attribs);\n\n		// set the href in the xlink namespace\n		if (elemWrapper.element.setAttributeNS) {\n			elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',\n				'href', src);\n		} else {\n			// could be exporting in IE\n			// using href throws \"not supported\" in ie7 and under, requries regex shim to fix later\n			elemWrapper.element.setAttribute('hc-svg-href', src);\n	}\n\n		return elemWrapper;\n	},\n\n	/**\n	 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.\n	 *\n	 * @param {Object} symbol\n	 * @param {Object} x\n	 * @param {Object} y\n	 * @param {Object} radius\n	 * @param {Object} options\n	 */\n	symbol: function (symbol, x, y, width, height, options) {\n\n		var obj,\n\n			// get the symbol definition function\n			symbolFn = this.symbols[symbol],\n\n			// check if there's a path defined for this symbol\n			path = symbolFn && symbolFn(\n				mathRound(x),\n				mathRound(y),\n				width,\n				height,\n				options\n			),\n\n			imageElement,\n			imageRegex = /^url\\((.*?)\\)$/,\n			imageSrc,\n			imageSize,\n			centerImage;\n\n		if (path) {\n\n			obj = this.path(path);\n			// expando properties for use in animate and attr\n			extend(obj, {\n				symbolName: symbol,\n				x: x,\n				y: y,\n				width: width,\n				height: height\n			});\n			if (options) {\n				extend(obj, options);\n			}\n\n\n		// image symbols\n		} else if (imageRegex.test(symbol)) {\n\n			// On image load, set the size and position\n			centerImage = function (img, size) {\n				if (img.element) { // it may be destroyed in the meantime (#1390)\n					img.attr({\n						width: size[0],\n						height: size[1]\n					});\n\n					if (!img.alignByTranslate) { // #185\n						img.translate(\n							mathRound((width - size[0]) / 2), // #1378\n							mathRound((height - size[1]) / 2)\n						);\n					}\n				}\n			};\n\n			imageSrc = symbol.match(imageRegex)[1];\n			imageSize = symbolSizes[imageSrc];\n\n			// Ireate the image synchronously, add attribs async\n			obj = this.image(imageSrc)\n				.attr({\n					x: x,\n					y: y\n				});\n\n			if (imageSize) {\n				centerImage(obj, imageSize);\n			} else {\n				// Initialize image to be 0 size so export will still function if there's no cached sizes.\n				// \n				obj.attr({ width: 0, height: 0 });\n\n				// Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,\n				// the created element must be assigned to a variable in order to load (#292).\n				imageElement = createElement('img', {\n					onload: function () {\n						centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);\n					},\n					src: imageSrc\n				});\n			}\n		}\n\n		return obj;\n	},\n\n	/**\n	 * An extendable collection of functions for defining symbol paths.\n	 */\n	symbols: {\n		'circle': function (x, y, w, h) {\n			var cpw = 0.166 * w;\n			return [\n				M, x + w / 2, y,\n				'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,\n				'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,\n				'Z'\n			];\n		},\n\n		'square': function (x, y, w, h) {\n			return [\n				M, x, y,\n				L, x + w, y,\n				x + w, y + h,\n				x, y + h,\n				'Z'\n			];\n		},\n\n		'triangle': function (x, y, w, h) {\n			return [\n				M, x + w / 2, y,\n				L, x + w, y + h,\n				x, y + h,\n				'Z'\n			];\n		},\n\n		'triangle-down': function (x, y, w, h) {\n			return [\n				M, x, y,\n				L, x + w, y,\n				x + w / 2, y + h,\n				'Z'\n			];\n		},\n		'diamond': function (x, y, w, h) {\n			return [\n				M, x + w / 2, y,\n				L, x + w, y + h / 2,\n				x + w / 2, y + h,\n				x, y + h / 2,\n				'Z'\n			];\n		},\n		'arc': function (x, y, w, h, options) {\n			var start = options.start,\n				radius = options.r || w || h,\n				end = options.end - 0.000001, // to prevent cos and sin of start and end from becoming equal on 360 arcs\n				innerRadius = options.innerR,\n				open = options.open,\n				cosStart = mathCos(start),\n				sinStart = mathSin(start),\n				cosEnd = mathCos(end),\n				sinEnd = mathSin(end),\n				longArc = options.end - start < mathPI ? 0 : 1;\n\n			return [\n				M,\n				x + radius * cosStart,\n				y + radius * sinStart,\n				'A', // arcTo\n				radius, // x radius\n				radius, // y radius\n				0, // slanting\n				longArc, // long or short arc\n				1, // clockwise\n				x + radius * cosEnd,\n				y + radius * sinEnd,\n				open ? M : L,\n				x + innerRadius * cosEnd,\n				y + innerRadius * sinEnd,\n				'A', // arcTo\n				innerRadius, // x radius\n				innerRadius, // y radius\n				0, // slanting\n				longArc, // long or short arc\n				0, // clockwise\n				x + innerRadius * cosStart,\n				y + innerRadius * sinStart,\n\n				open ? '' : 'Z' // close\n			];\n		}\n	},\n\n	/**\n	 * Define a clipping rectangle\n	 * @param {String} id\n	 * @param {Number} x\n	 * @param {Number} y\n	 * @param {Number} width\n	 * @param {Number} height\n	 */\n	clipRect: function (x, y, width, height) {\n		var wrapper,\n			id = PREFIX + idCounter++,\n\n			clipPath = this.createElement('clipPath').attr({\n				id: id\n			}).add(this.defs);\n\n		wrapper = this.rect(x, y, width, height, 0).add(clipPath);\n		wrapper.id = id;\n		wrapper.clipPath = clipPath;\n\n		return wrapper;\n	},\n\n\n	/**\n	 * Take a color and return it if it's a string, make it a gradient if it's a\n	 * gradient configuration object. Prior to Highstock, an array was used to define\n	 * a linear gradient with pixel positions relative to the SVG. In newer versions\n	 * we change the coordinates to apply relative to the shape, using coordinates\n	 * 0-1 within the shape. To preserve backwards compatibility, linearGradient\n	 * in this definition is an object of x1, y1, x2 and y2.\n	 *\n	 * @param {Object} color The color or config object\n	 */\n	color: function (color, elem, prop) {\n		var renderer = this,\n			colorObject,\n			regexRgba = /^rgba/,\n			gradName, \n			gradAttr,\n			gradients,\n			gradientObject,\n			stops,\n			stopColor,\n			stopOpacity,\n			radialReference,\n			n,\n			id,\n			key = [];\n		\n		// Apply linear or radial gradients\n		if (color && color.linearGradient) {\n			gradName = 'linearGradient';\n		} else if (color && color.radialGradient) {\n			gradName = 'radialGradient';\n		}\n		\n		if (gradName) {\n			gradAttr = color[gradName];\n			gradients = renderer.gradients;\n			stops = color.stops;\n			radialReference = elem.radialReference;\n			\n			// Keep < 2.2 kompatibility\n			if (isArray(gradAttr)) {\n				color[gradName] = gradAttr = {\n					x1: gradAttr[0],\n					y1: gradAttr[1],\n					x2: gradAttr[2],\n					y2: gradAttr[3],\n					gradientUnits: 'userSpaceOnUse'\n				};				\n			}\n			\n			// Correct the radial gradient for the radial reference system\n			if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {\n				extend(gradAttr, {\n					cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],\n					cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],\n					r: gradAttr.r * radialReference[2],\n					gradientUnits: 'userSpaceOnUse'\n				});\n			}\n			\n			// Build the unique key to detect whether we need to create a new element (#1282)\n			for (n in gradAttr) {\n				if (n !== 'id') {\n					key.push(n, gradAttr[n]);\n				}\n			}\n			for (n in stops) {\n				key.push(stops[n]);\n			}\n			key = key.join(',');\n			\n			// Check if a gradient object with the same config object is created within this renderer\n			if (gradients[key]) {\n				id = gradients[key].id;\n				\n			} else {\n\n				// Set the id and create the element\n				gradAttr.id = id = PREFIX + idCounter++;\n				gradients[key] = gradientObject = renderer.createElement(gradName)\n					.attr(gradAttr)\n					.add(renderer.defs);\n				\n				\n				// The gradient needs to keep a list of stops to be able to destroy them\n				gradientObject.stops = [];\n				each(stops, function (stop) {\n					var stopObject;\n					if (regexRgba.test(stop[1])) {\n						colorObject = Color(stop[1]);\n						stopColor = colorObject.get('rgb');\n						stopOpacity = colorObject.get('a');\n					} else {\n						stopColor = stop[1];\n						stopOpacity = 1;\n					}\n					stopObject = renderer.createElement('stop').attr({\n						offset: stop[0],\n						'stop-color': stopColor,\n						'stop-opacity': stopOpacity\n					}).add(gradientObject);\n\n					// Add the stop element to the gradient\n					gradientObject.stops.push(stopObject);\n				});\n			}\n\n			// Return the reference to the gradient object\n			return 'url(' + renderer.url + '#' + id + ')';\n			\n		// Webkit and Batik can't show rgba.\n		} else if (regexRgba.test(color)) {\n			colorObject = Color(color);\n			attr(elem, prop + '-opacity', colorObject.get('a'));\n\n			return colorObject.get('rgb');\n\n\n		} else {\n			// Remove the opacity attribute added above. Does not throw if the attribute is not there.\n			elem.removeAttribute(prop + '-opacity');\n\n			return color;\n		}\n\n	},\n\n\n	/**\n	 * Add text to the SVG object\n	 * @param {String} str\n	 * @param {Number} x Left position\n	 * @param {Number} y Top position\n	 * @param {Boolean} useHTML Use HTML to render the text\n	 */\n	text: function (str, x, y, useHTML) {\n\n		// declare variables\n		var renderer = this,\n			defaultChartStyle = defaultOptions.chart.style,\n			fakeSVG = useCanVG || (!hasSVG && renderer.forExport),\n			wrapper;\n\n		if (useHTML && !renderer.forExport) {\n			return renderer.html(str, x, y);\n		}\n\n		x = mathRound(pick(x, 0));\n		y = mathRound(pick(y, 0));\n\n		wrapper = renderer.createElement('text')\n			.attr({\n				x: x,\n				y: y,\n				text: str\n			})\n			.css({\n				fontFamily: defaultChartStyle.fontFamily,\n				fontSize: defaultChartStyle.fontSize\n			});\n		\n		// Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)	\n		if (fakeSVG) {\n			wrapper.css({\n				position: ABSOLUTE\n			});\n		}\n\n		wrapper.x = x;\n		wrapper.y = y;\n		return wrapper;\n	},\n\n\n	/**\n	 * Create HTML text node. This is used by the VML renderer as well as the SVG\n	 * renderer through the useHTML option.\n	 *\n	 * @param {String} str\n	 * @param {Number} x\n	 * @param {Number} y\n	 */\n	html: function (str, x, y) {\n		var defaultChartStyle = defaultOptions.chart.style,\n			wrapper = this.createElement('span'),\n			attrSetters = wrapper.attrSetters,\n			element = wrapper.element,\n			renderer = wrapper.renderer;\n\n		// Text setter\n		attrSetters.text = function (value) {\n			if (value !== element.innerHTML) {\n				delete this.bBox;\n			}\n			element.innerHTML = value;\n			return false;\n		};\n\n		// Various setters which rely on update transform\n		attrSetters.x = attrSetters.y = attrSetters.align = function (value, key) {\n			if (key === 'align') {\n				key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.\n			}\n			wrapper[key] = value;\n			wrapper.htmlUpdateTransform();\n			return false;\n		};\n\n		// Set the default attributes\n		wrapper.attr({\n				text: str,\n				x: mathRound(x),\n				y: mathRound(y)\n			})\n			.css({\n				position: ABSOLUTE,\n				whiteSpace: 'nowrap',\n				fontFamily: defaultChartStyle.fontFamily,\n				fontSize: defaultChartStyle.fontSize\n			});\n\n		// Use the HTML specific .css method\n		wrapper.css = wrapper.htmlCss;\n\n		// This is specific for HTML within SVG\n		if (renderer.isSVG) {\n			wrapper.add = function (svgGroupWrapper) {\n\n				var htmlGroup,\n					container = renderer.box.parentNode,\n					parentGroup,\n					parents = [];\n\n				// Create a mock group to hold the HTML elements\n				if (svgGroupWrapper) {\n					htmlGroup = svgGroupWrapper.div;\n					if (!htmlGroup) {\n						\n						// Read the parent chain into an array and read from top down\n						parentGroup = svgGroupWrapper;\n						while (parentGroup) {\n						\n							parents.push(parentGroup);\n						\n							// Move up to the next parent group\n							parentGroup = parentGroup.parentGroup;\n						}\n						\n						// Ensure dynamically updating position when any parent is translated\n						each(parents.reverse(), function (parentGroup) {\n							var htmlGroupStyle;\n								\n							// Create a HTML div and append it to the parent div to emulate \n							// the SVG group structure\n							htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, {\n								clas");
        builder.append("sName: attr(parentGroup.element, 'class')\n							}, {\n								position: ABSOLUTE,\n								left: (parentGroup.translateX || 0) + PX,\n								top: (parentGroup.translateY || 0) + PX\n							}, htmlGroup || container); // the top group is appended to container\n							\n							// Shortcut\n							htmlGroupStyle = htmlGroup.style;\n							\n							// Set listeners to update the HTML div's position whenever the SVG group\n							// position is changed\n							extend(parentGroup.attrSetters, {\n								translateX: function (value) {\n									htmlGroupStyle.left = value + PX;\n								},\n								translateY: function (value) {\n									htmlGroupStyle.top = value + PX;\n								},\n								visibility: function (value, key) {\n									htmlGroupStyle[key] = value;\n								}\n							});\n						});\n\n					}\n				} else {\n					htmlGroup = container;\n				}\n\n				htmlGroup.appendChild(element);\n\n				// Shared with VML:\n				wrapper.added = true;\n				if (wrapper.alignOnAdd) {\n					wrapper.htmlUpdateTransform();\n				}\n\n				return wrapper;\n			};\n		}\n		return wrapper;\n	},\n\n	/**\n	 * Utility to return the baseline offset and total line height from the font size\n	 */\n	fontMetrics: function (fontSize) {\n		fontSize = pInt(fontSize || 11);\n		\n		// Empirical values found by comparing font size and bounding box height.\n		// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/\n		var lineHeight = fontSize < 24 ? fontSize + 4 : mathRound(fontSize * 1.2),\n			baseline = mathRound(lineHeight * 0.8);\n		\n		return {\n			h: lineHeight, \n			b: baseline\n		};\n	},\n\n	/**\n	 * Add a label, a text item that can hold a colored or gradient background\n	 * as well as a border and shadow.\n	 * @param {string} str\n	 * @param {Number} x\n	 * @param {Number} y\n	 * @param {String} shape\n	 * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the\n	 *    coordinates it should be pinned to\n	 * @param {Number} anchorY\n	 * @param {Boolean} baseline Whether to position the label relative to the text baseline,\n	 *    like renderer.text, or to the upper border of the rectangle. \n	 * @param {String} className Class name for the group \n	 */\n	label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n\n		var renderer = this,\n			wrapper = renderer.g(className),\n			text = renderer.text('', 0, 0, useHTML)\n				.attr({\n					zIndex: 1\n				}),\n				//.add(wrapper),\n			box,\n			bBox,\n			alignFactor = 0,\n			padding = 3,\n			width,\n			height,\n			wrapperX,\n			wrapperY,\n			crispAdjust = 0,\n			deferredAttr = {},\n			baselineOffset,\n			attrSetters = wrapper.attrSetters,\n			needsBox;\n\n		/**\n		 * This function runs after the label is added to the DOM (when the bounding box is\n		 * available), and after the text of the label is updated to detect the new bounding\n		 * box and reflect it in the border box.\n		 */\n		function updateBoxSize() {\n			var boxY,\n				style = text.element.style;\n				\n			bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) &&\n				text.getBBox();\n			wrapper.width = (width || bBox.width || 0) + 2 * padding;\n			wrapper.height = (height || bBox.height || 0) + 2 * padding;\n			\n			// update the label-scoped y offset\n			baselineOffset = padding + renderer.fontMetrics(style && style.fontSize).b;\n				\n			if (needsBox) {\n				\n				// create the border box if it is not already present\n				if (!box) {\n					boxY = baseline ? -baselineOffset : 0;\n				\n					wrapper.box = box = shape ?\n						renderer.symbol(shape, -alignFactor * padding, boxY, wrapper.width, wrapper.height) :\n						renderer.rect(-alignFactor * padding, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);\n					box.add(wrapper);\n				}\n	\n				// apply the box attributes\n				box.attr(merge({\n					width: wrapper.width,\n					height: wrapper.height\n				}, deferredAttr));\n				deferredAttr = null;\n			}\n		}\n\n		/**\n		 * This function runs after setting text or padding, but only if padding is changed\n		 */\n		function updateTextPadding() {\n			var styles = wrapper.styles,\n				textAlign = styles && styles.textAlign,\n				x = padding * (1 - alignFactor),\n				y;\n			\n			// determin y based on the baseline\n			y = baseline ? 0 : baselineOffset;\n\n			// compensate for alignment\n			if (defined(width) && (textAlign === 'center' || textAlign === 'right')) {\n				x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);\n			}\n\n			// update if anything changed\n			if (x !== text.x || y !== text.y) {\n				text.attr({\n					x: x,\n					y: y\n				});\n			}\n\n			// record current values\n			text.x = x;\n			text.y = y;\n		}\n\n		/**\n		 * Set a box attribute, or defer it if the box is not yet created\n		 * @param {Object} key\n		 * @param {Object} value\n		 */\n		function boxAttr(key, value) {\n			if (box) {\n				box.attr(key, value);\n			} else {\n				deferredAttr[key] = value;\n			}\n		}\n\n		function getSizeAfterAdd() {\n			text.add(wrapper);\n			wrapper.attr({\n				text: str, // alignment is available now\n				x: x,\n				y: y\n			});\n			\n			if (box && defined(anchorX)) {\n				wrapper.attr({\n					anchorX: anchorX,\n					anchorY: anchorY\n				});\n			}\n		}\n\n		/**\n		 * After the text element is added, get the desired size of the border box\n		 * and add it before the text in the DOM.\n		 */\n		addEvent(wrapper, 'add', getSizeAfterAdd);\n\n		/*\n		 * Add specific attribute setters.\n		 */\n\n		// only change local variables\n		attrSetters.width = function (value) {\n			width = value;\n			return false;\n		};\n		attrSetters.height = function (value) {\n			height = value;\n			return false;\n		};\n		attrSetters.padding = function (value) {\n			if (defined(value) && value !== padding) {\n				padding = value;\n				updateTextPadding();\n			}\n\n			return false;\n		};\n\n		// change local variable and set attribue as well\n		attrSetters.align = function (value) {\n			alignFactor = { left: 0, center: 0.5, right: 1 }[value];\n			return false; // prevent setting text-anchor on the group\n		};\n		\n		// apply these to the box and the text alike\n		attrSetters.text = function (value, key) {\n			text.attr(key, value);\n			updateBoxSize();\n			updateTextPadding();\n			return false;\n		};\n\n		// apply these to the box but not to the text\n		attrSetters[STROKE_WIDTH] = function (value, key) {\n			needsBox = true;\n			crispAdjust = value % 2 / 2;\n			boxAttr(key, value);\n			return false;\n		};\n		attrSetters.stroke = attrSetters.fill = attrSetters.r = function (value, key) {\n			if (key === 'fill') {\n				needsBox = true;\n			}\n			boxAttr(key, value);\n			return false;\n		};\n		attrSetters.anchorX = function (value, key) {\n			anchorX = value;\n			boxAttr(key, value + crispAdjust - wrapperX);\n			return false;\n		};\n		attrSetters.anchorY = function (value, key) {\n			anchorY = value;\n			boxAttr(key, value - wrapperY);\n			return false;\n		};\n		\n		// rename attributes\n		attrSetters.x = function (value) {\n			wrapper.x = value; // for animation getter\n			value -= alignFactor * ((width || bBox.width) + padding);\n			wrapperX = mathRound(value); \n			\n			wrapper.attr('translateX', wrapperX);\n			return false;\n		};\n		attrSetters.y = function (value) {\n			wrapperY = wrapper.y = mathRound(value);\n			wrapper.attr('translateY', value);\n			return false;\n		};\n\n		// Redirect certain methods to either the box or the text\n		var baseCss = wrapper.css;\n		return extend(wrapper, {\n			/**\n			 * Pick up some properties and apply them to the text instead of the wrapper\n			 */\n			css: function (styles) {\n				if (styles) {\n					var textStyles = {};\n					styles = merge({}, styles); // create a copy to avoid altering the original object (#537)\n					each(['fontSize', 'fontWeight', 'fontFamily', 'color', 'lineHeight', 'width'], function (prop) {\n						if (styles[prop] !== UNDEFINED) {\n							textStyles[prop] = styles[prop];\n							delete styles[prop];\n						}\n					});\n					text.css(textStyles);\n				}\n				return baseCss.call(wrapper, styles);\n			},\n			/**\n			 * Return the bounding box of the box, not the group\n			 */\n			getBBox: function () {\n				return {\n					width: bBox.width + 2 * padding,\n					height: bBox.height + 2 * padding,\n					x: bBox.x - padding,\n					y: bBox.y - padding\n				};\n			},\n			/**\n			 * Apply the shadow to the box\n			 */\n			shadow: function (b) {\n				if (box) {\n					box.shadow(b);\n				}\n				return wrapper;\n			},\n			/**\n			 * Destroy and release memory.\n			 */\n			destroy: function () {\n				removeEvent(wrapper, 'add', getSizeAfterAdd);\n\n				// Added by button implementation\n				removeEvent(wrapper.element, 'mouseenter');\n				removeEvent(wrapper.element, 'mouseleave');\n\n				if (text) {\n					text = text.destroy();\n				}\n				if (box) {\n					box = box.destroy();\n				}\n				// Call base implementation to destroy the rest\n				SVGElement.prototype.destroy.call(wrapper);\n				\n				// Release local pointers (#1298)\n				wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = getSizeAfterAdd = null;\n			}\n		});\n	}\n}; // end SVGRenderer\n\n\n// general renderer\nRenderer = SVGRenderer;\n\n\n/* ****************************************************************************\n *                                                                            *\n * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *\n *                                                                            *\n * For applications and websites that don't need IE support, like platform    *\n * targeted mobile apps and web apps, this code can be removed.               *\n *                                                                            *\n *****************************************************************************/\n\n/**\n * @constructor\n */\nvar VMLRenderer;\nif (!hasSVG && !useCanVG) {\n\n/**\n * The VML element wrapper.\n */\nvar VMLElement = {\n\n	/**\n	 * Initialize a new VML element wrapper. It builds the markup as a string\n	 * to minimize DOM traffic.\n	 * @param {Object} renderer\n	 * @param {Object} nodeName\n	 */\n	init: function (renderer, nodeName) {\n		var wrapper = this,\n			markup =  ['<', nodeName, ' filled=\"f\" stroked=\"f\"'],\n			style = ['position: ', ABSOLUTE, ';'];\n\n		// divs and shapes need size\n		if (nodeName === 'shape' || nodeName === DIV) {\n			style.push('left:0;top:0;width:1px;height:1px;');\n		}\n		if (docMode8) {\n			style.push('visibility: ', nodeName === DIV ? HIDDEN : VISIBLE);\n		}\n\n		markup.push(' style=\"', style.join(''), '\"/>');\n\n		// create element with default attributes and style\n		if (nodeName) {\n			markup = nodeName === DIV || nodeName === 'span' || nodeName === 'img' ?\n				markup.join('')\n				: renderer.prepVML(markup);\n			wrapper.element = createElement(markup);\n		}\n\n		wrapper.renderer = renderer;\n		wrapper.attrSetters = {};\n	},\n\n	/**\n	 * Add the node to the given parent\n	 * @param {Object} parent\n	 */\n	add: function (parent) {\n		var wrapper = this,\n			renderer = wrapper.renderer,\n			element = wrapper.element,\n			box = renderer.box,\n			inverted = parent && parent.inverted,\n\n			// get the parent node\n			parentNode = parent ?\n				parent.element || parent :\n				box;\n\n\n		// if the parent group is inverted, apply inversion on all children\n		if (inverted) { // only on groups\n			renderer.invertChild(element, parentNode);\n		}\n\n		// append it\n		parentNode.appendChild(element);\n\n		// align text after adding to be able to read offset\n		wrapper.added = true;\n		if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {\n			wrapper.updateTransform();\n		}\n\n		// fire an event for internal hooks\n		fireEvent(wrapper, 'add');\n\n		return wrapper;\n	},\n\n	/**\n	 * VML always uses htmlUpdateTransform\n	 */\n	updateTransform: SVGElement.prototype.htmlUpdateTransform,\n\n	/**\n	 * Get or set attributes\n	 */\n	attr: function (hash, val) {\n		var wrapper = this,\n			key,\n			value,\n			i,\n			result,\n			element = wrapper.element || {},\n			elemStyle = element.style,\n			nodeName = element.nodeName,\n			renderer = wrapper.renderer,\n			symbolName = wrapper.symbolName,\n			hasSetSymbolSize,\n			shadows = wrapper.shadows,\n			skipAttr,\n			attrSetters = wrapper.attrSetters,\n			ret = wrapper;\n\n		// single key-value pair\n		if (isString(hash) && defined(val)) {\n			key = hash;\n			hash = {};\n			hash[key] = val;\n		}\n\n		// used as a getter, val is undefined\n		if (isString(hash)) {\n			key = hash;\n			if (key === 'strokeWidth' || key === 'stroke-width') {\n				ret = wrapper.strokeweight;\n			} else {\n				ret = wrapper[key];\n			}\n\n		// setter\n		} else {\n			for (key in hash) {\n				value = hash[key];\n				skipAttr = false;\n\n				// check for a specific attribute setter\n				result = attrSetters[key] && attrSetters[key].call(wrapper, value, key);\n\n				if (result !== false && value !== null) { // #620\n\n					if (result !== UNDEFINED) {\n						value = result; // the attribute setter has returned a new value to set\n					}\n\n\n					// prepare paths\n					// symbols\n					if (symbolName && /^(x|y|r|start|end|width|height|innerR|anchorX|anchorY)/.test(key)) {\n						// if one of the symbol size affecting parameters are changed,\n						// check all the others only once for each call to an element's\n						// .attr() method\n						if (!hasSetSymbolSize) {\n							wrapper.symbolAttr(hash);\n\n							hasSetSymbolSize = true;\n						}\n						skipAttr = true;\n\n					} else if (key === 'd') {\n						value = value || [];\n						wrapper.d = value.join(' '); // used in getter for animation\n\n						// convert paths\n						i = value.length;\n						var convertedPath = [];\n						while (i--) {\n\n							// Multiply by 10 to allow subpixel precision.\n							// Substracting half a pixel seems to make the coordinates\n							// align with SVG, but this hasn't been tested thoroughly\n							if (isNumber(value[i])) {\n								convertedPath[i] = mathRound(value[i] * 10) - 5;\n							} else if (value[i] === 'Z') { // close the path\n								convertedPath[i] = 'x';\n							} else {\n								convertedPath[i] = value[i];\n							}\n\n						}\n						value = convertedPath.join(' ') || 'x';\n						element.path = value;\n\n						// update shadows\n						if (shadows) {\n							i = shadows.length;\n							while (i--) {\n								shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;\n							}\n						}\n						skipAttr = true;\n\n					// handle visibility\n					} else if (key === 'visibility') {\n\n						// let the shadow follow the main element\n						if (shadows) {\n							i = shadows.length;\n							while (i--) {\n								shadows[i].style[key] = value;\n							}\n						}\n						\n						// Instead of toggling the visibility CSS property, move the div out of the viewport. \n						// This works around #61 and #586							\n						if (nodeName === 'DIV') {\n							value = value === HIDDEN ? '-999em' : 0;\n							key = 'top';\n						}\n						\n						elemStyle[key] = value;	\n						skipAttr = true;\n\n					// directly mapped to css\n					} else if (key === 'zIndex') {\n\n						if (value) {\n							elemStyle[key] = value;\n						}\n						skipAttr = true;\n\n					// width and height\n					} else if (key === 'width' || key === 'height') {\n						\n						value = mathMax(0, value); // don't set width or height below zero (#311)\n						\n						this[key] = value; // used in getter\n\n						// clipping rectangle special\n						if (wrapper.updateClipping) {\n							wrapper[key] = value;\n							wrapper.updateClipping();\n						} else {\n							// normal\n							elemStyle[key] = value;\n						}\n\n						skipAttr = true;\n\n					// x and y\n					} else if (key === 'x' || key === 'y') {\n						wrapper[key] = value; // used in getter\n						elemStyle[{ x: 'left', y: 'top' }[key]] = value;\n\n					// class name\n					} else if (key === 'class') {\n						// IE8 Standards mode has problems retrieving the className\n						element.className = value;\n\n					// stroke\n					} else if (key === 'stroke') {\n\n						value = renderer.color(value, element, key);\n\n						key = 'strokecolor';\n\n					// stroke width\n					} else if (key === 'stroke-width' || key === 'strokeWidth') {\n						element.stroked = value ? true : false;\n						key = 'strokeweight';\n						wrapper[key] = value; // used in getter, issue #113\n						if (isNumber(value)) {\n							value += PX;\n						}\n\n					// dashStyle\n					} else if (key === 'dashstyle') {\n						var strokeElem = element.getElementsByTagName('stroke')[0] ||\n							createElement(renderer.prepVML(['<stroke/>']), null, null, element);\n						strokeElem[key] = value || 'solid';\n						wrapper.dashstyle = value; /* because changing stroke-width will change the dash length\n							and cause an epileptic effect */\n						skipAttr = true;\n\n					// fill\n					} else if (key === 'fill') {\n\n						if (nodeName === 'SPAN') { //");
        builder.append(" text color\n							elemStyle.color = value;\n						} else if (nodeName !== 'IMG') { // #1336\n							element.filled = value !== NONE ? true : false;\n\n							value = renderer.color(value, element, key, wrapper);\n\n							key = 'fillcolor';\n						}\n						\n					// rotation on VML elements\n					} else if (nodeName === 'shape' && key === 'rotation') {\n						wrapper[key] = value;\n						// Correction for the 1x1 size of the shape container. Used in gauge needles.\n						element.style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;\n						element.style.top = mathRound(mathCos(value * deg2rad)) + PX;\n\n					// translation for animation\n					} else if (key === 'translateX' || key === 'translateY' || key === 'rotation') {\n						wrapper[key] = value;\n						wrapper.updateTransform();\n\n						skipAttr = true;\n\n					// text for rotated and non-rotated elements\n					} else if (key === 'text') {\n						this.bBox = null;\n						element.innerHTML = value;\n						skipAttr = true;\n					}\n\n					if (!skipAttr) {\n						if (docMode8) { // IE8 setAttribute bug\n							element[key] = value;\n						} else {\n							attr(element, key, value);\n						}\n					}\n\n				}\n			}\n		}\n		return ret;\n	},\n\n	/**\n	 * Set the element's clipping to a predefined rectangle\n	 *\n	 * @param {String} id The id of the clip rectangle\n	 */\n	clip: function (clipRect) {\n		var wrapper = this,\n			clipMembers,\n			element = wrapper.element,\n			parentNode = element.parentNode,\n			cssRet;\n\n		if (clipRect) {\n			clipMembers = clipRect.members;\n			erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)\n			clipMembers.push(wrapper);\n			wrapper.destroyClip = function () {\n				erase(clipMembers, wrapper);\n			};\n			// Issue #863 workaround - related to #140, #61, #74\n			if (parentNode && parentNode.className === 'highcharts-tracker' && !docMode8) {\n				css(element, { visibility: HIDDEN });\n			}\n			cssRet = clipRect.getCSS(wrapper);\n			\n		} else {\n			if (wrapper.destroyClip) {\n				wrapper.destroyClip();\n			}\n			cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214\n		}\n		\n		return wrapper.css(cssRet);\n			\n	},\n\n	/**\n	 * Set styles for the element\n	 * @param {Object} styles\n	 */\n	css: SVGElement.prototype.htmlCss,\n\n	/**\n	 * Removes a child either by removeChild or move to garbageBin.\n	 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n	 */\n	safeRemoveChild: function (element) {\n		// discardElement will detach the node from its parent before attaching it\n		// to the garbage bin. Therefore it is important that the node is attached and have parent.\n		if (element.parentNode) {\n			discardElement(element);\n		}\n	},\n\n	/**\n	 * Extend element.destroy by removing it from the clip members array\n	 */\n	destroy: function () {\n		if (this.destroyClip) {\n			this.destroyClip();\n		}\n\n		return SVGElement.prototype.destroy.apply(this);\n	},\n\n	/**\n	 * Remove all child nodes of a group, except the v:group element\n	 */\n	empty: function () {\n		var element = this.element,\n			childNodes = element.childNodes,\n			i = childNodes.length,\n			node;\n\n		while (i--) {\n			node = childNodes[i];\n			node.parentNode.removeChild(node);\n		}\n	},\n\n	/**\n	 * Add an event listener. VML override for normalizing event parameters.\n	 * @param {String} eventType\n	 * @param {Function} handler\n	 */\n	on: function (eventType, handler) {\n		// simplest possible event model for internal use\n		this.element['on' + eventType] = function () {\n			var evt = win.event;\n			evt.target = evt.srcElement;\n			handler(evt);\n		};\n		return this;\n	},\n	\n	/**\n	 * In stacked columns, cut off the shadows so that they don't overlap\n	 */\n	cutOffPath: function (path, length) {\n		\n		var len;\n		\n		path = path.split(/[ ,]/);\n		len = path.length;\n		\n		if (len === 9 || len === 11) {\n			path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;\n		}\n		return path.join(' ');		\n	},\n\n	/**\n	 * Apply a drop shadow by copying elements and giving them different strokes\n	 * @param {Boolean|Object} shadowOptions\n	 */\n	shadow: function (shadowOptions, group, cutOff) {\n		var shadows = [],\n			i,\n			element = this.element,\n			renderer = this.renderer,\n			shadow,\n			elemStyle = element.style,\n			markup,\n			path = element.path,\n			strokeWidth,\n			modifiedPath,\n			shadowWidth,\n			shadowElementOpacity;\n\n		// some times empty paths are not strings\n		if (path && typeof path.value !== 'string') {\n			path = 'x';\n		}\n		modifiedPath = path;\n\n		if (shadowOptions) {\n			shadowWidth = pick(shadowOptions.width, 3);\n			shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n			for (i = 1; i <= 3; i++) {\n				\n				strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n				\n				// Cut off shadows for stacked column items\n				if (cutOff) {\n					modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);\n				}\n				\n				markup = ['<shape isShadow=\"true\" strokeweight=\"', strokeWidth,\n					'\" filled=\"false\" path=\"', modifiedPath,\n					'\" coordsize=\"10 10\" style=\"', element.style.cssText, '\" />'];\n				\n				shadow = createElement(renderer.prepVML(markup),\n					null, {\n						left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),\n						top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)\n					}\n				);\n				if (cutOff) {\n					shadow.cutOff = strokeWidth + 1;\n				}\n				\n				// apply the opacity\n				markup = ['<stroke color=\"', shadowOptions.color || 'black', '\" opacity=\"', shadowElementOpacity * i, '\"/>'];\n				createElement(renderer.prepVML(markup), null, null, shadow);\n\n\n				// insert it\n				if (group) {\n					group.element.appendChild(shadow);\n				} else {\n					element.parentNode.insertBefore(shadow, element);\n				}\n\n				// record it\n				shadows.push(shadow);\n\n			}\n\n			this.shadows = shadows;\n		}\n		return this;\n\n	}\n};\nVMLElement = extendClass(SVGElement, VMLElement);\n\n/**\n * The VML renderer\n */\nvar VMLRendererExtension = { // inherit SVGRenderer\n\n	Element: VMLElement,\n	isIE8: userAgent.indexOf('MSIE 8.0') > -1,\n\n\n	/**\n	 * Initialize the VMLRenderer\n	 * @param {Object} container\n	 * @param {Number} width\n	 * @param {Number} height\n	 */\n	init: function (container, width, height) {\n		var renderer = this,\n			boxWrapper,\n			box;\n\n		renderer.alignedObjects = [];\n\n		boxWrapper = renderer.createElement(DIV);\n		box = boxWrapper.element;\n		box.style.position = RELATIVE; // for freeform drawing using renderer directly\n		container.appendChild(boxWrapper.element);\n\n\n		// generate the containing box\n		renderer.box = box;\n		renderer.boxWrapper = boxWrapper;\n\n\n		renderer.setSize(width, height, false);\n\n		// The only way to make IE6 and IE7 print is to use a global namespace. However,\n		// with IE8 the only way to make the dynamic shapes visible in screen and print mode\n		// seems to be to add the xmlns attribute and the behaviour style inline.\n		if (!doc.namespaces.hcv) {\n\n			doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');\n\n			// setup default css\n			doc.createStyleSheet().cssText =\n				'hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke' +\n				'{ behavior:url(#default#VML); display: inline-block; } ';\n\n		}\n	},\n	\n	\n	/**\n	 * Detect whether the renderer is hidden. This happens when one of the parent elements\n	 * has display: none\n	 */\n	isHidden: function () {\n		return !this.box.offsetWidth;			\n	},\n\n	/**\n	 * Define a clipping rectangle. In VML it is accomplished by storing the values\n	 * for setting the CSS style to all associated members.\n	 *\n	 * @param {Number} x\n	 * @param {Number} y\n	 * @param {Number} width\n	 * @param {Number} height\n	 */\n	clipRect: function (x, y, width, height) {\n\n		// create a dummy element\n		var clipRect = this.createElement(),\n			isObj = isObject(x);\n		\n		// mimic a rectangle with its style object for automatic updating in attr\n		return extend(clipRect, {\n			members: [],\n			left: isObj ? x.x : x,\n			top: isObj ? x.y : y,\n			width: isObj ? x.width : width,\n			height: isObj ? x.height : height,\n			getCSS: function (wrapper) {\n				var inverted = wrapper.inverted,\n					rect = this,\n					top = rect.top,\n					left = rect.left,\n					right = left + rect.width,\n					bottom = top + rect.height,\n					ret = {\n						clip: 'rect(' +\n							mathRound(inverted ? left : top) + 'px,' +\n							mathRound(inverted ? bottom : right) + 'px,' +\n							mathRound(inverted ? right : bottom) + 'px,' +\n							mathRound(inverted ? top : left) + 'px)'\n					};\n\n				// issue 74 workaround\n				if (!inverted && docMode8 && wrapper.element.nodeName !== 'IMG') {\n					extend(ret, {\n						width: right + PX,\n						height: bottom + PX\n					});\n				}\n				\n				return ret;\n			},\n\n			// used in attr and animation to update the clipping of all members\n			updateClipping: function () {\n				each(clipRect.members, function (member) {\n					member.css(clipRect.getCSS(member));\n				});\n			}\n		});\n\n	},\n\n\n	/**\n	 * Take a color and return it if it's a string, make it a gradient if it's a\n	 * gradient configuration object, and apply opacity.\n	 *\n	 * @param {Object} color The color or config object\n	 */\n	color: function (color, elem, prop, wrapper) {\n		var renderer = this,\n			colorObject,\n			regexRgba = /^rgba/,\n			markup,\n			fillType,\n			ret = NONE;\n\n		// Check for linear or radial gradient\n		if (color && color.linearGradient) {\n			fillType = 'gradient';\n		} else if (color && color.radialGradient) {\n			fillType = 'pattern';\n		}\n		\n		\n		if (fillType) {\n\n			var stopColor,\n				stopOpacity,\n				gradient = color.linearGradient || color.radialGradient,\n				x1,\n				y1, \n				x2,\n				y2,\n				opacity1,\n				opacity2,\n				color1,\n				color2,\n				fillAttr = '',\n				stops = color.stops,\n				firstStop,\n				lastStop,\n				colors = [],\n				addFillNode = function () {\n					// Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2\n					// are reversed.\n					markup = ['<fill colors=\"' + colors.join(',') + '\" opacity=\"', opacity2, '\" o:opacity2=\"', opacity1,\n						'\" type=\"', fillType, '\" ', fillAttr, 'focus=\"100%\" method=\"any\" />'];\n					createElement(renderer.prepVML(markup), null, null, elem);\n				};\n			\n			// Extend from 0 to 1\n			firstStop = stops[0];\n			lastStop = stops[stops.length - 1];\n			if (firstStop[0] > 0) {\n				stops.unshift([\n					0,\n					firstStop[1]\n				]);\n			}\n			if (lastStop[0] < 1) {\n				stops.push([\n					1,\n					lastStop[1]\n				]);\n			}\n\n			// Compute the stops\n			each(stops, function (stop, i) {\n				if (regexRgba.test(stop[1])) {\n					colorObject = Color(stop[1]);\n					stopColor = colorObject.get('rgb');\n					stopOpacity = colorObject.get('a');\n				} else {\n					stopColor = stop[1];\n					stopOpacity = 1;\n				}\n				\n				// Build the color attribute\n				colors.push((stop[0] * 100) + '% ' + stopColor); \n\n				// Only start and end opacities are allowed, so we use the first and the last\n				if (!i) {\n					opacity1 = stopOpacity;\n					color2 = stopColor;\n				} else {\n					opacity2 = stopOpacity;\n					color1 = stopColor;\n				}\n			});\n			\n			// Apply the gradient to fills only.\n			if (prop === 'fill') {\n				\n				// Handle linear gradient angle\n				if (fillType === 'gradient') {\n					x1 = gradient.x1 || gradient[0] || 0;\n					y1 = gradient.y1 || gradient[1] || 0;\n					x2 = gradient.x2 || gradient[2] || 0;\n					y2 = gradient.y2 || gradient[3] || 0;\n					fillAttr = 'angle=\"' + (90  - math.atan(\n						(y2 - y1) / // y vector\n						(x2 - x1) // x vector\n						) * 180 / mathPI) + '\"';\n						\n					addFillNode();\n					\n				// Radial (circular) gradient\n				} else { \n					\n					var r = gradient.r,\n						sizex = r * 2,\n						sizey = r * 2,\n						cx = gradient.cx,\n						cy = gradient.cy,\n						radialReference = elem.radialReference,\n						bBox,\n						applyRadialGradient = function () {\n							if (radialReference) {\n								bBox = wrapper.getBBox();\n								cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;\n								cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;\n								sizex *= radialReference[2] / bBox.width;\n								sizey *= radialReference[2] / bBox.height;							\n							}\n							fillAttr = 'src=\"' + defaultOptions.global.VMLRadialGradientURL + '\" ' +\n								'size=\"' + sizex + ',' + sizey + '\" ' +\n								'origin=\"0.5,0.5\" ' +\n								'position=\"' + cx + ',' + cy + '\" ' +\n								'color2=\"' + color2 + '\" ';\n							\n							addFillNode();\n						};\n					\n					// Apply radial gradient\n					if (wrapper.added) {\n						applyRadialGradient();\n					} else {\n						// We need to know the bounding box to get the size and position right\n						addEvent(wrapper, 'add', applyRadialGradient);\n					}\n					\n					// The fill element's color attribute is broken in IE8 standards mode, so we\n					// need to set the parent shape's fillcolor attribute instead.\n					ret = color1;\n				}\n			\n			// Gradients are not supported for VML stroke, return the first color. #722.\n			} else {\n				ret = stopColor;\n			}\n\n		// if the color is an rgba color, split it and add a fill node\n		// to hold the opacity component\n		} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {\n\n			colorObject = Color(color);\n\n			markup = ['<', prop, ' opacity=\"', colorObject.get('a'), '\"/>'];\n			createElement(this.prepVML(markup), null, null, elem);\n\n			ret = colorObject.get('rgb');\n\n\n		} else {\n			var strokeNodes = elem.getElementsByTagName(prop);\n			if (strokeNodes.length) {\n				strokeNodes[0].opacity = 1;\n			}\n			ret = color;\n		}\n\n		return ret;\n	},\n\n	/**\n	 * Take a VML string and prepare it for either IE8 or IE6/IE7.\n	 * @param {Array} markup A string array of the VML markup to prepare\n	 */\n	prepVML: function (markup) {\n		var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',\n			isIE8 = this.isIE8;\n\n		markup = markup.join('');\n\n		if (isIE8) { // add xmlns and style inline\n			markup = markup.replace('/>', ' xmlns=\"urn:schemas-microsoft-com:vml\" />');\n			if (markup.indexOf('style=\"') === -1) {\n				markup = markup.replace('/>', ' style=\"' + vmlStyle + '\" />');\n			} else {\n				markup = markup.replace('style=\"', 'style=\"' + vmlStyle);\n			}\n\n		} else { // add namespace\n			markup = markup.replace('<', '<hcv:');\n		}\n\n		return markup;\n	},\n\n	/**\n	 * Create rotated and aligned text\n	 * @param {String} str\n	 * @param {Number} x\n	 * @param {Number} y\n	 */\n	text: SVGRenderer.prototype.html,\n\n	/**\n	 * Create and return a path element\n	 * @param {Array} path\n	 */\n	path: function (path) {\n		var attr = {\n			// subpixel precision down to 0.1 (width and height = 1px)\n			coordsize: '10 10'\n		};\n		if (isArray(path)) {\n			attr.d = path;\n		} else if (isObject(path)) { // attributes\n			extend(attr, path);\n		}\n		// create the shape\n		return this.createElement('shape').attr(attr);\n	},\n\n	/**\n	 * Create and return a circle element. In VML circles are implemented as\n	 * shapes, which is faster than v:oval\n	 * @param {Number} x\n	 * @param {Number} y\n	 * @param {Number} r\n	 */\n	circle: function (x, y, r) {\n		return this.symbol('circle').attr({ x: x - r, y: y - r, width: 2 * r, height: 2 * r });\n	},\n\n	/**\n	 * Create a group using an outer div and an inner v:group to allow rotating\n	 * and flipping. A simple v:group would have problems with positioning\n	 * child HTML elements and CSS clip.\n	 *\n	 * @param {String} name The name of the group\n	 */\n	g: function (name) {\n		var wrapper,\n			attribs;\n\n		// set the class name\n		if (name) {\n			attribs = { 'className': PREFIX + name, 'class': PREFIX + name };\n		}\n\n		// the div to hold HTML and clipping\n		wrapper = this.createElement(DIV).attr(attribs);\n\n		return wrapper;\n	},\n\n	/**\n	 * VML override to create a regular HTML image\n	 * @param {String} src\n	 * @param {Number} x\n	 * @param {Number} y\n	 * @param {Number} width\n	 * @param {Number} height\n	 */\n	image: function (src, x, y, width, height) {\n		var obj = this.createElement('img')\n			.attr({ src: src });\n\n		if (arguments.length > 1) {\n			obj.attr({\n				x: x,\n				y: y,\n				width: width,\n				height: height\n			});\n		}\n		return obj;\n	},\n\n	/**\n	 * VML uses a shape for rect to overcome bugs and rotation problems\n	 */\n	rect: function (x, y, width, height, r, strokeWidth) {\n\n		if (isObject(x)) {\n			y = x.y;\n			width = x.width;\n			height = x.height;\n			strokeWidth = x.strokeWidth;\n			x = x.x;\n		}\n		var wrapper = this.symbol('rect');\n		wrapper.r = r;\n\n		return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));\n	},\n\n	/**\n	 * In the VML renderer, each child of an inverted div (group) is inverted\n	 * @param {Object} element\n	 * @param {Object} parentNode\n	 */\n	invertChild: function (element, parentNode) {\n		var parentStyle = parentN");
        builder.append("ode.style;\n		css(element, {\n			flip: 'x',\n			left: pInt(parentStyle.width) - 1,\n			top: pInt(parentStyle.height) - 1,\n			rotation: -90\n		});\n	},\n\n	/**\n	 * Symbol definitions that override the parent SVG renderer's symbols\n	 *\n	 */\n	symbols: {\n		// VML specific arc function\n		arc: function (x, y, w, h, options) {\n			var start = options.start,\n				end = options.end,\n				radius = options.r || w || h,\n				cosStart = mathCos(start),\n				sinStart = mathSin(start),\n				cosEnd = mathCos(end),\n				sinEnd = mathSin(end),\n				innerRadius = options.innerR,\n				circleCorrection = 0.08 / radius, // #760\n				innerCorrection = (innerRadius && 0.1 / innerRadius) || 0,\n				ret;\n\n			if (end - start === 0) { // no angle, don't show it.\n				return ['x'];\n\n			} else if (2 * mathPI - end + start < circleCorrection) { // full circle\n				// empirical correction found by trying out the limits for different radii\n				cosEnd = -circleCorrection;\n			} else if (end - start < innerCorrection) { // issue #186, another mysterious VML arc problem\n				cosEnd = mathCos(start + innerCorrection);\n			}\n\n			ret = [\n				'wa', // clockwise arc to\n				x - radius, // left\n				y - radius, // top\n				x + radius, // right\n				y + radius, // bottom\n				x + radius * cosStart, // start x\n				y + radius * sinStart, // start y\n				x + radius * cosEnd, // end x\n				y + radius * sinEnd  // end y\n			];\n\n			if (options.open && !innerRadius) {\n				ret.push(\n					'e',\n					M, \n					x,// - innerRadius, \n					y// - innerRadius\n				);\n			}\n\n			ret.push(\n				'at', // anti clockwise arc to\n				x - innerRadius, // left\n				y - innerRadius, // top\n				x + innerRadius, // right\n				y + innerRadius, // bottom\n				x + innerRadius * cosEnd, // start x\n				y + innerRadius * sinEnd, // start y\n				x + innerRadius * cosStart, // end x\n				y + innerRadius * sinStart, // end y\n				'x', // finish path\n				'e' // close\n			);\n			\n			return ret;\n\n		},\n		// Add circle symbol path. This performs significantly faster than v:oval.\n		circle: function (x, y, w, h) {\n\n			return [\n				'wa', // clockwisearcto\n				x, // left\n				y, // top\n				x + w, // right\n				y + h, // bottom\n				x + w, // start x\n				y + h / 2,     // start y\n				x + w, // end x\n				y + h / 2,     // end y\n				//'x', // finish path\n				'e' // close\n			];\n		},\n		/**\n		 * Add rectangle symbol path which eases rotation and omits arcsize problems\n		 * compared to the built-in VML roundrect shape\n		 *\n		 * @param {Number} left Left position\n		 * @param {Number} top Top position\n		 * @param {Number} r Border radius\n		 * @param {Object} options Width and height\n		 */\n\n		rect: function (left, top, width, height, options) {\n			\n			var right = left + width,\n				bottom = top + height,\n				ret,\n				r;\n\n			// No radius, return the more lightweight square\n			if (!defined(options) || !options.r) {\n				ret = SVGRenderer.prototype.symbols.square.apply(0, arguments);\n				\n			// Has radius add arcs for the corners\n			} else {\n			\n				r = mathMin(options.r, width, height);\n				ret = [\n					M,\n					left + r, top,\n	\n					L,\n					right - r, top,\n					'wa',\n					right - 2 * r, top,\n					right, top + 2 * r,\n					right - r, top,\n					right, top + r,\n	\n					L,\n					right, bottom - r,\n					'wa',\n					right - 2 * r, bottom - 2 * r,\n					right, bottom,\n					right, bottom - r,\n					right - r, bottom,\n	\n					L,\n					left + r, bottom,\n					'wa',\n					left, bottom - 2 * r,\n					left + 2 * r, bottom,\n					left + r, bottom,\n					left, bottom - r,\n	\n					L,\n					left, top + r,\n					'wa',\n					left, top,\n					left + 2 * r, top + 2 * r,\n					left, top + r,\n					left + r, top,\n	\n	\n					'x',\n					'e'\n				];\n			}\n			return ret;\n		}\n	}\n};\nVMLRenderer = function () {\n	this.init.apply(this, arguments);\n};\nVMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);\n\n	// general renderer\n	Renderer = VMLRenderer;\n}\n\n/* ****************************************************************************\n *                                                                            *\n * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *\n *                                                                            *\n *****************************************************************************/\n/* ****************************************************************************\n *                                                                            *\n * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *\n * TARGETING THAT SYSTEM.                                                     *\n *                                                                            *\n *****************************************************************************/\nvar CanVGRenderer,\n	CanVGController;\n\nif (useCanVG) {\n	/**\n	 * The CanVGRenderer is empty from start to keep the source footprint small.\n	 * When requested, the CanVGController downloads the rest of the source packaged\n	 * together with the canvg library.\n	 */\n	CanVGRenderer = function () {\n		// Override the global SVG namespace to fake SVG/HTML that accepts CSS\n		SVG_NS = 'http://www.w3.org/1999/xhtml';\n	};\n\n	/**\n	 * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but \n	 * the implementation from SvgRenderer will not be merged in until first render.\n	 */\n	CanVGRenderer.prototype.symbols = {};\n\n	/**\n	 * Handles on demand download of canvg rendering support.\n	 */\n	CanVGController = (function () {\n		// List of renderering calls\n		var deferredRenderCalls = [];\n\n		/**\n		 * When downloaded, we are ready to draw deferred charts.\n		 */\n		function drawDeferred() {\n			var callLength = deferredRenderCalls.length,\n				callIndex;\n\n			// Draw all pending render calls\n			for (callIndex = 0; callIndex < callLength; callIndex++) {\n				deferredRenderCalls[callIndex]();\n			}\n			// Clear the list\n			deferredRenderCalls = [];\n		}\n\n		return {\n			push: function (func, scriptLocation) {\n				// Only get the script once\n				if (deferredRenderCalls.length === 0) {\n					getScript(scriptLocation, drawDeferred);\n				}\n				// Register render call\n				deferredRenderCalls.push(func);\n			}\n		};\n	}());\n} // end CanVGRenderer\n\n/* ****************************************************************************\n *                                                                            *\n * END OF ANDROID < 3 SPECIFIC CODE                                           *\n *                                                                            *\n *****************************************************************************/\n\n/**\n * General renderer\n */\nRenderer = VMLRenderer || CanVGRenderer || SVGRenderer;\n/**\n * The Tick class\n */\nfunction Tick(axis, pos, type) {\n	this.axis = axis;\n	this.pos = pos;\n	this.type = type || '';\n	this.isNew = true;\n\n	if (!type) {\n		this.addLabel();\n	}\n}\n\nTick.prototype = {\n	/**\n	 * Write the tick label\n	 */\n	addLabel: function () {\n		var tick = this,\n			axis = tick.axis,\n			options = axis.options,\n			chart = axis.chart,\n			horiz = axis.horiz,\n			categories = axis.categories,\n			pos = tick.pos,\n			labelOptions = options.labels,\n			str,\n			tickPositions = axis.tickPositions,\n			width = (categories && horiz && categories.length &&\n				!labelOptions.step && !labelOptions.staggerLines &&\n				!labelOptions.rotation &&\n				chart.plotWidth / tickPositions.length) ||\n				(!horiz && chart.plotWidth / 2),\n			isFirst = pos === tickPositions[0],\n			isLast = pos === tickPositions[tickPositions.length - 1],\n			css,\n			attr,\n			value = categories && defined(categories[pos]) ? categories[pos] : pos,\n			label = tick.label,\n			tickPositionInfo = tickPositions.info,\n			dateTimeLabelFormat;\n\n		// Set the datetime label format. If a higher rank is set for this position, use that. If not,\n		// use the general format.\n		if (axis.isDatetimeAxis && tickPositionInfo) {\n			dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];\n		}\n\n		// set properties for access in render method\n		tick.isFirst = isFirst;\n		tick.isLast = isLast;\n\n		// get the string\n		str = axis.labelFormatter.call({\n			axis: axis,\n			chart: chart,\n			isFirst: isFirst,\n			isLast: isLast,\n			dateTimeLabelFormat: dateTimeLabelFormat,\n			value: axis.isLog ? correctFloat(lin2log(value)) : value\n		});\n\n		// prepare CSS\n		css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };\n		css = extend(css, labelOptions.style);\n\n		// first call\n		if (!defined(label)) {\n			attr = {\n				align: labelOptions.align\n			};\n			if (isNumber(labelOptions.rotation)) {\n				attr.rotation = labelOptions.rotation;\n			}			\n			tick.label =\n				defined(str) && labelOptions.enabled ?\n					chart.renderer.text(\n							str,\n							0,\n							0,\n							labelOptions.useHTML\n						)\n						.attr(attr)\n						// without position absolute, IE export sometimes is wrong\n						.css(css)\n						.add(axis.labelGroup) :\n					null;\n\n		// update\n		} else if (label) {\n			label.attr({\n					text: str\n				})\n				.css(css);\n		}\n	},\n\n	/**\n	 * Get the offset height or width of the label\n	 */\n	getLabelSize: function () {\n		var label = this.label,\n			axis = this.axis;\n		return label ?\n			((this.labelBBox = label.getBBox()))[axis.horiz ? 'height' : 'width'] :\n			0;\n	},\n\n	/**\n	 * Find how far the labels extend to the right and left of the tick's x position. Used for anti-collision\n	 * detection with overflow logic.\n	 */\n	getLabelSides: function () {\n		var bBox = this.labelBBox, // assume getLabelSize has run at this point\n			axis = this.axis,\n			options = axis.options,\n			labelOptions = options.labels,\n			width = bBox.width,\n			leftSide = width * { left: 0, center: 0.5, right: 1 }[labelOptions.align] - labelOptions.x;\n\n		return [-leftSide, width - leftSide];\n	},\n\n	/**\n	 * Handle the label overflow by adjusting the labels to the left and right edge, or\n	 * hide them if they collide into the neighbour label.\n	 */\n	handleOverflow: function (index, xy) {\n		var show = true,\n			axis = this.axis,\n			chart = axis.chart,\n			isFirst = this.isFirst,\n			isLast = this.isLast,\n			x = xy.x,\n			reversed = axis.reversed,\n			tickPositions = axis.tickPositions;\n\n		if (isFirst || isLast) {\n\n			var sides = this.getLabelSides(),\n				leftSide = sides[0],\n				rightSide = sides[1],\n				plotLeft = chart.plotLeft,\n				plotRight = plotLeft + axis.len,\n				neighbour = axis.ticks[tickPositions[index + (isFirst ? 1 : -1)]],\n				neighbourEdge = neighbour && neighbour.label.xy && neighbour.label.xy.x + neighbour.getLabelSides()[isFirst ? 0 : 1];\n\n			if ((isFirst && !reversed) || (isLast && reversed)) {\n				// Is the label spilling out to the left of the plot area?\n				if (x + leftSide < plotLeft) {\n\n					// Align it to plot left\n					x = plotLeft - leftSide;\n\n					// Hide it if it now overlaps the neighbour label\n					if (neighbour && x + rightSide > neighbourEdge) {\n						show = false;\n					}\n				}\n\n			} else {\n				// Is the label spilling out to the right of the plot area?\n				if (x + rightSide > plotRight) {\n\n					// Align it to plot right\n					x = plotRight - rightSide;\n\n					// Hide it if it now overlaps the neighbour label\n					if (neighbour && x + leftSide < neighbourEdge) {\n						show = false;\n					}\n\n				}\n			}\n\n			// Set the modified x position of the label\n			xy.x = x;\n		}\n		return show;\n	},\n\n	/**\n	 * Get the x and y position for ticks and labels\n	 */\n	getPosition: function (horiz, pos, tickmarkOffset, old) {\n		var axis = this.axis,\n			chart = axis.chart,\n			cHeight = (old && chart.oldChartHeight) || chart.chartHeight;\n		\n		return {\n			x: horiz ?\n				axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :\n				axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),\n\n			y: horiz ?\n				cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :\n				cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB\n		};\n		\n	},\n	\n	/**\n	 * Get the x, y position of the tick label\n	 */\n	getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n		var axis = this.axis,\n			transA = axis.transA,\n			reversed = axis.reversed,\n			staggerLines = axis.staggerLines;\n			\n		x = x + labelOptions.x - (tickmarkOffset && horiz ?\n			tickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n		y = y + labelOptions.y - (tickmarkOffset && !horiz ?\n			tickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n		\n		// Vertically centered\n		if (!defined(labelOptions.y)) {\n			y += pInt(label.styles.lineHeight) * 0.9 - label.getBBox().height / 2;\n		}\n		\n		// Correct for staggered labels\n		if (staggerLines) {\n			y += (index / (step || 1) % staggerLines) * 16;\n		}\n		\n		return {\n			x: x,\n			y: y\n		};\n	},\n	\n	/**\n	 * Extendible method to return the path of the marker\n	 */\n	getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {\n		return renderer.crispLine([\n				M,\n				x,\n				y,\n				L,\n				x + (horiz ? 0 : -tickLength),\n				y + (horiz ? tickLength : 0)\n			], tickWidth);\n	},\n\n	/**\n	 * Put everything in place\n	 *\n	 * @param index {Number}\n	 * @param old {Boolean} Use old coordinates to prepare an animation into new position\n	 */\n	render: function (index, old) {\n		var tick = this,\n			axis = tick.axis,\n			options = axis.options,\n			chart = axis.chart,\n			renderer = chart.renderer,\n			horiz = axis.horiz,\n			type = tick.type,\n			label = tick.label,\n			pos = tick.pos,\n			labelOptions = options.labels,\n			gridLine = tick.gridLine,\n			gridPrefix = type ? type + 'Grid' : 'grid',\n			tickPrefix = type ? type + 'Tick' : 'tick',\n			gridLineWidth = options[gridPrefix + 'LineWidth'],\n			gridLineColor = options[gridPrefix + 'LineColor'],\n			dashStyle = options[gridPrefix + 'LineDashStyle'],\n			tickLength = options[tickPrefix + 'Length'],\n			tickWidth = options[tickPrefix + 'Width'] || 0,\n			tickColor = options[tickPrefix + 'Color'],\n			tickPosition = options[tickPrefix + 'Position'],\n			gridLinePath,\n			mark = tick.mark,\n			markPath,\n			step = labelOptions.step,\n			attribs,\n			show = true,\n			tickmarkOffset = axis.tickmarkOffset,\n			xy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n			x = xy.x,\n			y = xy.y,\n			staggerLines = axis.staggerLines;\n		\n		// create the grid line\n		if (gridLineWidth) {\n			gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth, old);\n\n			if (gridLine === UNDEFINED) {\n				attribs = {\n					stroke: gridLineColor,\n					'stroke-width': gridLineWidth\n				};\n				if (dashStyle) {\n					attribs.dashstyle = dashStyle;\n				}\n				if (!type) {\n					attribs.zIndex = 1;\n				}\n				tick.gridLine = gridLine =\n					gridLineWidth ?\n						renderer.path(gridLinePath)\n							.attr(attribs).add(axis.gridGroup) :\n						null;\n			}\n\n			// If the parameter 'old' is set, the current call will be followed\n			// by another call, therefore do not do any animations this time\n			if (!old && gridLine && gridLinePath) {\n				gridLine[tick.isNew ? 'attr' : 'animate']({\n					d: gridLinePath\n				});\n			}\n		}\n\n		// create the tick mark\n		if (tickWidth && tickLength) {\n\n			// negate the length\n			if (tickPosition === 'inside') {\n				tickLength = -tickLength;\n			}\n			if (axis.opposite) {\n				tickLength = -tickLength;\n			}\n\n			markPath = tick.getMarkPath(x, y, tickLength, tickWidth, horiz, renderer);\n\n			if (mark) { // updating\n				mark.animate({\n					d: markPath\n				});\n			} else { // first time\n				tick.mark = renderer.path(\n					markPath\n				).attr({\n					stroke: tickColor,\n					'stroke-width': tickWidth\n				}).add(axis.axisGroup);\n			}\n		}\n\n		// the label is created on init - now move it into place\n		if (label && !isNaN(x)) {\n			label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n\n			// apply show first and show last\n			if ((tick.isFirst && !pick(options.showFirstLabel, 1)) ||\n					(tick.isLast && !pick(options.showLastLabel, 1))) {\n				show = false;\n\n			// Handle label overflow and show or hide accordingly\n			} else if (!staggerLines && horiz && labelOptions.overflow === 'justify' && !tick.handleOverflow(index, xy)) {\n				show = false;\n			}\n\n			// apply step\n			if (step && index % step) {\n				// show those indices dividable by step\n				show = false;\n			}\n\n			// Set the new position, and show or hide\n			if (show) {\n				label[tick.isNew ? 'attr' : 'animate'](xy);\n				tick.isNew = false;\n			");
        builder.append("} else {\n				label.attr('y', -9999); // #1338\n			}\n		}\n	},\n\n	/**\n	 * Destructor for the tick prototype\n	 */\n	destroy: function () {\n		destroyObjectProperties(this, this.axis);\n	}\n};\n\n/**\n * The object wrapper for plot lines and plot bands\n * @param {Object} options\n */\nfunction PlotLineOrBand(axis, options) {\n	this.axis = axis;\n\n	if (options) {\n		this.options = options;\n		this.id = options.id;\n	}\n\n	//plotLine.render()\n	return this;\n}\n\nPlotLineOrBand.prototype = {\n	\n	/**\n	 * Render the plot line or plot band. If it is already existing,\n	 * move it.\n	 */\n	render: function () {\n		var plotLine = this,\n			axis = plotLine.axis,\n			horiz = axis.horiz,\n			halfPointRange = (axis.pointRange || 0) / 2,\n			options = plotLine.options,\n			optionsLabel = options.label,\n			label = plotLine.label,\n			width = options.width,\n			to = options.to,\n			from = options.from,\n			isBand = defined(from) && defined(to),\n			value = options.value,\n			dashStyle = options.dashStyle,\n			svgElem = plotLine.svgElem,\n			path = [],\n			addEvent,\n			eventType,\n			xs,\n			ys,\n			x,\n			y,\n			color = options.color,\n			zIndex = options.zIndex,\n			events = options.events,\n			attribs,\n			renderer = axis.chart.renderer;\n\n		// logarithmic conversion\n		if (axis.isLog) {\n			from = log2lin(from);\n			to = log2lin(to);\n			value = log2lin(value);\n		}\n\n		// plot line\n		if (width) {\n			path = axis.getPlotLinePath(value, width);\n			attribs = {\n				stroke: color,\n				'stroke-width': width\n			};\n			if (dashStyle) {\n				attribs.dashstyle = dashStyle;\n			}\n		} else if (isBand) { // plot band\n			\n			// keep within plot area\n			from = mathMax(from, axis.min - halfPointRange);\n			to = mathMin(to, axis.max + halfPointRange);\n			\n			path = axis.getPlotBandPath(from, to, options);\n			attribs = {\n				fill: color\n			};\n			if (options.borderWidth) {\n				attribs.stroke = options.borderColor;\n				attribs['stroke-width'] = options.borderWidth;\n			}\n		} else {\n			return;\n		}\n		// zIndex\n		if (defined(zIndex)) {\n			attribs.zIndex = zIndex;\n		}\n\n		// common for lines and bands\n		if (svgElem) {\n			if (path) {\n				svgElem.animate({\n					d: path\n				}, null, svgElem.onGetPath);\n			} else {\n				svgElem.hide();\n				svgElem.onGetPath = function () {\n					svgElem.show();\n				};\n			}\n		} else if (path && path.length) {\n			plotLine.svgElem = svgElem = renderer.path(path)\n				.attr(attribs).add();\n\n			// events\n			if (events) {\n				addEvent = function (eventType) {\n					svgElem.on(eventType, function (e) {\n						events[eventType].apply(plotLine, [e]);\n					});\n				};\n				for (eventType in events) {\n					addEvent(eventType);\n				}\n			}\n		}\n\n		// the plot band/line label\n		if (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {\n			// apply defaults\n			optionsLabel = merge({\n				align: horiz && isBand && 'center',\n				x: horiz ? !isBand && 4 : 10,\n				verticalAlign : !horiz && isBand && 'middle',\n				y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,\n				rotation: horiz && !isBand && 90\n			}, optionsLabel);\n\n			// add the SVG element\n			if (!label) {\n				plotLine.label = label = renderer.text(\n						optionsLabel.text,\n						0,\n						0\n					)\n					.attr({\n						align: optionsLabel.textAlign || optionsLabel.align,\n						rotation: optionsLabel.rotation,\n						zIndex: zIndex\n					})\n					.css(optionsLabel.style)\n					.add();\n			}\n\n			// get the bounding box and align the label\n			xs = [path[1], path[4], pick(path[6], path[1])];\n			ys = [path[2], path[5], pick(path[7], path[2])];\n			x = arrayMin(xs);\n			y = arrayMin(ys);\n\n			label.align(optionsLabel, false, {\n				x: x,\n				y: y,\n				width: arrayMax(xs) - x,\n				height: arrayMax(ys) - y\n			});\n			label.show();\n\n		} else if (label) { // move out of sight\n			label.hide();\n		}\n\n		// chainable\n		return plotLine;\n	},\n\n	/**\n	 * Remove the plot line or band\n	 */\n	destroy: function () {\n		var plotLine = this,\n			axis = plotLine.axis;\n\n		// remove it from the lookup\n		erase(axis.plotLinesAndBands, plotLine);\n\n		destroyObjectProperties(plotLine, this.axis);\n	}\n};\n/**\n * The class for stack items\n */\nfunction StackItem(axis, options, isNegative, x, stackOption, stacking) {\n	\n	var inverted = axis.chart.inverted;\n\n	this.axis = axis;\n\n	// Tells if the stack is negative\n	this.isNegative = isNegative;\n\n	// Save the options to be able to style the label\n	this.options = options;\n\n	// Save the x value to be able to position the label later\n	this.x = x;\n\n	// Save the stack option on the series configuration object, and whether to treat it as percent\n	this.stack = stackOption;\n	this.percent = stacking === 'percent';\n\n	// The align options and text align varies on whether the stack is negative and\n	// if the chart is inverted or not.\n	// First test the user supplied value, then use the dynamic.\n	this.alignOptions = {\n		align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),\n		verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),\n		y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),\n		x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)\n	};\n\n	this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');\n}\n\nStackItem.prototype = {\n	destroy: function () {\n		destroyObjectProperties(this, this.axis);\n	},\n\n	/**\n	 * Sets the total of this stack. Should be called when a serie is hidden or shown\n	 * since that will affect the total of other stacks.\n	 */\n	setTotal: function (total) {\n		this.total = total;\n		this.cum = total;\n	},\n\n	/**\n	 * Renders the stack total label and adds it to the stack label group.\n	 */\n	render: function (group) {\n		var str = this.options.formatter.call(this);  // format the text in the label\n\n		// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden\n		if (this.label) {\n			this.label.attr({text: str, visibility: HIDDEN});\n		// Create new label\n		} else {\n			this.label =\n				this.axis.chart.renderer.text(str, 0, 0)		// dummy positions, actual position updated with setOffset method in columnseries\n					.css(this.options.style)				// apply style\n					.attr({\n						align: this.textAlign,				// fix the text-anchor\n						rotation: this.options.rotation,	// rotation\n						visibility: HIDDEN					// hidden until setOffset is called\n					})				\n					.add(group);							// add to the labels-group\n		}\n	},\n\n	/**\n	 * Sets the offset that the stack has from the x value and repositions the label.\n	 */\n	setOffset: function (xOffset, xWidth) {\n		var stackItem = this,\n			axis = stackItem.axis,\n			chart = axis.chart,\n			inverted = chart.inverted,\n			neg = this.isNegative,							// special treatment is needed for negative stacks\n			y = axis.translate(this.percent ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates\n			yZero = axis.translate(0),						// stack origin\n			h = mathAbs(y - yZero),							// stack height\n			x = chart.xAxis[0].translate(this.x) + xOffset,	// stack x position\n			plotHeight = chart.plotHeight,\n			stackBox = {	// this is the box for the complete stack\n				x: inverted ? (neg ? y : y - h) : x,\n				y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),\n				width: inverted ? h : xWidth,\n				height: inverted ? xWidth : h\n			},\n			label = this.label,\n			alignAttr;\n		\n		if (label) {\n			label.align(this.alignOptions, null, stackBox);	// align the label to the box\n				\n			// Set visibility (#678)\n			alignAttr = label.alignAttr;\n			label.attr({ \n				visibility: this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? \n					(hasSVG ? 'inherit' : VISIBLE) : \n					HIDDEN\n			});\n		}\n	}\n};\n/**\n * Create a new axis object\n * @param {Object} chart\n * @param {Object} options\n */\nfunction Axis() {\n	this.init.apply(this, arguments);\n}\n\nAxis.prototype = {\n	\n	/**\n	 * Default options for the X axis - the Y axis has extended defaults \n	 */\n	defaultOptions: {\n		// allowDecimals: null,\n		// alternateGridColor: null,\n		// categories: [],\n		dateTimeLabelFormats: {\n			millisecond: '%H:%M:%S.%L',\n			second: '%H:%M:%S',\n			minute: '%H:%M',\n			hour: '%H:%M',\n			day: '%e. %b',\n			week: '%e. %b',\n			month: '%b \\'%y',\n			year: '%Y'\n		},\n		endOnTick: false,\n		gridLineColor: '#C0C0C0',\n		// gridLineDashStyle: 'solid',\n		// gridLineWidth: 0,\n		// reversed: false,\n	\n		labels: defaultLabelOptions,\n			// { step: null },\n		lineColor: '#C0D0E0',\n		lineWidth: 1,\n		//linkedTo: null,\n		//max: undefined,\n		//min: undefined,\n		minPadding: 0.01,\n		maxPadding: 0.01,\n		//minRange: null,\n		minorGridLineColor: '#E0E0E0',\n		// minorGridLineDashStyle: null,\n		minorGridLineWidth: 1,\n		minorTickColor: '#A0A0A0',\n		//minorTickInterval: null,\n		minorTickLength: 2,\n		minorTickPosition: 'outside', // inside or outside\n		//minorTickWidth: 0,\n		//opposite: false,\n		//offset: 0,\n		//plotBands: [{\n		//	events: {},\n		//	zIndex: 1,\n		//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }\n		//}],\n		//plotLines: [{\n		//	events: {}\n		//  dashStyle: {}\n		//	zIndex:\n		//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }\n		//}],\n		//reversed: false,\n		// showFirstLabel: true,\n		// showLastLabel: true,\n		startOfWeek: 1,\n		startOnTick: false,\n		tickColor: '#C0D0E0',\n		//tickInterval: null,\n		tickLength: 5,\n		tickmarkPlacement: 'between', // on or between\n		tickPixelInterval: 100,\n		tickPosition: 'outside',\n		tickWidth: 1,\n		title: {\n			//text: null,\n			align: 'middle', // low, middle or high\n			//margin: 0 for horizontal, 10 for vertical axes,\n			//rotation: 0,\n			//side: 'outside',\n			style: {\n				color: '#6D869F',\n				//font: defaultFont.replace('normal', 'bold')\n				fontWeight: 'bold'\n			}\n			//x: 0,\n			//y: 0\n		},\n		type: 'linear' // linear, logarithmic or datetime\n	},\n	\n	/**\n	 * This options set extends the defaultOptions for Y axes\n	 */\n	defaultYAxisOptions: {\n		endOnTick: true,\n		gridLineWidth: 1,\n		tickPixelInterval: 72,\n		showLastLabel: true,\n		labels: {\n			align: 'right',\n			x: -8,\n			y: 3\n		},\n		lineWidth: 0,\n		maxPadding: 0.05,\n		minPadding: 0.05,\n		startOnTick: true,\n		tickWidth: 0,\n		title: {\n			rotation: 270,\n			text: 'Y-values'\n		},\n		stackLabels: {\n			enabled: false,\n			//align: dynamic,\n			//y: dynamic,\n			//x: dynamic,\n			//verticalAlign: dynamic,\n			//textAlign: dynamic,\n			//rotation: 0,\n			formatter: function () {\n				return this.total;\n			},\n			style: defaultLabelOptions.style\n		}\n	},\n	\n	/**\n	 * These options extend the defaultOptions for left axes\n	 */\n	defaultLeftAxisOptions: {\n		labels: {\n			align: 'right',\n			x: -8,\n			y: null\n		},\n		title: {\n			rotation: 270\n		}\n	},\n	\n	/**\n	 * These options extend the defaultOptions for right axes\n	 */\n	defaultRightAxisOptions: {\n		labels: {\n			align: 'left',\n			x: 8,\n			y: null\n		},\n		title: {\n			rotation: 90\n		}\n	},\n	\n	/**\n	 * These options extend the defaultOptions for bottom axes\n	 */\n	defaultBottomAxisOptions: {\n		labels: {\n			align: 'center',\n			x: 0,\n			y: 14\n			// overflow: undefined,\n			// staggerLines: null\n		},\n		title: {\n			rotation: 0\n		}\n	},\n	/**\n	 * These options extend the defaultOptions for left axes\n	 */\n	defaultTopAxisOptions: {\n		labels: {\n			align: 'center',\n			x: 0,\n			y: -5\n			// overflow: undefined\n			// staggerLines: null\n		},\n		title: {\n			rotation: 0\n		}\n	},\n	\n	/**\n	 * Initialize the axis\n	 */\n	init: function (chart, userOptions) {\n			\n		\n		var isXAxis = userOptions.isX,\n			axis = this;\n	\n		// Flag, is the axis horizontal\n		axis.horiz = chart.inverted ? !isXAxis : isXAxis;\n		\n		// Flag, isXAxis\n		axis.isXAxis = isXAxis;\n		axis.xOrY = isXAxis ? 'x' : 'y';\n	\n	\n		axis.opposite = userOptions.opposite; // needed in setOptions\n		axis.side = axis.horiz ?\n				(axis.opposite ? 0 : 2) : // top : bottom\n				(axis.opposite ? 1 : 3);  // right : left\n	\n		axis.setOptions(userOptions);\n		\n	\n		var options = this.options,\n			type = options.type,\n			isDatetimeAxis = type === 'datetime';\n	\n		axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format\n	\n	\n		// Flag, stagger lines or not\n		axis.staggerLines = axis.horiz && options.labels.staggerLines;\n		axis.userOptions = userOptions;\n	\n		//axis.axisTitleMargin = UNDEFINED,// = options.title.margin,\n		axis.minPixelPadding = 0;\n		//axis.ignoreMinPadding = UNDEFINED; // can be set to true by a column or bar series\n		//axis.ignoreMaxPadding = UNDEFINED;\n	\n		axis.chart = chart;\n		axis.reversed = options.reversed;\n	\n		// Initial categories\n		axis.categories = options.categories;\n	\n		// Elements\n		//axis.axisGroup = UNDEFINED;\n		//axis.gridGroup = UNDEFINED;\n		//axis.axisTitle = UNDEFINED;\n		//axis.axisLine = UNDEFINED;\n	\n		// Flag if type === logarithmic\n		axis.isLog = type === 'logarithmic';\n	\n		// Flag, if axis is linked to another axis\n		axis.isLinked = defined(options.linkedTo);\n		// Linked axis.\n		//axis.linkedParent = UNDEFINED;\n	\n		// Flag if type === datetime\n		axis.isDatetimeAxis = isDatetimeAxis;\n	\n		// Flag if percentage mode\n		//axis.usePercentage = UNDEFINED;\n	\n		\n		// Tick positions\n		//axis.tickPositions = UNDEFINED; // array containing predefined positions\n		// Tick intervals\n		//axis.tickInterval = UNDEFINED;\n		//axis.minorTickInterval = UNDEFINED;\n		\n		axis.tickmarkOffset = (options.categories && options.tickmarkPlacement === 'between') ? 0.5 : 0;\n	\n		// Major ticks\n		axis.ticks = {};\n		// Minor ticks\n		axis.minorTicks = {};\n		//axis.tickAmount = UNDEFINED;\n	\n		// List of plotLines/Bands\n		axis.plotLinesAndBands = [];\n	\n		// Alternate bands\n		axis.alternateBands = {};\n	\n		// Axis metrics\n		//axis.left = UNDEFINED;\n		//axis.top = UNDEFINED;\n		//axis.width = UNDEFINED;\n		//axis.height = UNDEFINED;\n		//axis.bottom = UNDEFINED;\n		//axis.right = UNDEFINED;\n		//axis.transA = UNDEFINED;\n		//axis.transB = UNDEFINED;\n		//axis.oldTransA = UNDEFINED;\n		axis.len = 0;\n		//axis.oldMin = UNDEFINED;\n		//axis.oldMax = UNDEFINED;\n		//axis.oldUserMin = UNDEFINED;\n		//axis.oldUserMax = UNDEFINED;\n		//axis.oldAxisLength = UNDEFINED;\n		axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n		axis.range = options.range;\n		axis.offset = options.offset || 0;\n	\n	\n		// Dictionary for stacks\n		axis.stacks = {};\n	\n		// Min and max in the data\n		//axis.dataMin = UNDEFINED,\n		//axis.dataMax = UNDEFINED,\n	\n		// The axis range\n		axis.max = null;\n		axis.min = null;\n	\n		// User set min and max\n		//axis.userMin = UNDEFINED,\n		//axis.userMax = UNDEFINED,\n\n		// Run Axis\n		\n		var eventType,\n			events = axis.options.events;\n\n		// Register\n		chart.axes.push(axis);\n		chart[isXAxis ? 'xAxis' : 'yAxis'].push(axis);\n\n		axis.series = []; // populated by Series\n\n		// inverted charts have reversed xAxes as default\n		if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {\n			axis.reversed = true;\n		}\n\n		axis.removePlotBand = axis.removePlotBandOrLine;\n		axis.removePlotLine = axis.removePlotBandOrLine;\n		axis.addPlotBand = axis.addPlotBandOrLine;\n		axis.addPlotLine = axis.addPlotBandOrLine;\n\n\n		// register event listeners\n		for (eventType in events) {\n			addEvent(axis, eventType, events[eventType]);\n		}\n\n		// extend logarithmic axis\n		if (axis.isLog) {\n			axis.val2lin = log2lin;\n			axis.lin2val = lin2log;\n		}\n	},\n	\n	/**\n	 * Merge and set options\n	 */\n	setOptions: function (userOptions) {\n		this.options = merge(\n			this.defaultOptions,\n			this.isXAxis ? {} : this.defaultYAxisOptions,\n			[this.defaultTopAxisOptions, this.defaultRightAxisOptions,\n				this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],\n			merge(\n				defaultOptions[this.isXAxis ? 'xAxis' : 'yAxis'], // if set in setOptions (#1053)\n				userOptions\n			)\n		);\n	},\n	\n	\n	/** \n	 * The default label formatter. The context is a special config object for the label.\n	 */\n	defaultLabelFormatter: function () {\n		var axis = this.axis,\n			value = this.value,\n			categories = axis.categories, \n			dateTimeLabelFormat = this.dateTimeLabelFormat,\n			numericSymbols = defaultOptions.lang.numericSymbols,\n			i = numericSymbols && numericSymbols.length,\n			multi,\n			ret,\n			\n			// make sure the same symbol is added for all labels on a linear axis\n			numericSymbolDetector = axis.isLog ? value : axis.tickInterval;\n\n		if (categories) {\n			ret = value;\n		\n		} else if (dateTimeLabelFormat) { // datetime axis\n			ret = dateFormat(dateTimeLabelFormat, value);\n		\n		} else if (i && numericSymbolDetector >= 1000) {\n			// Decide whether we should add a numeric symbo");
        builder.append("l like k (thousands) or M (millions).\n			// If we are to enable this in tooltip or other places as well, we can move this\n			// logic to the numberFormatter and enable it by a parameter.\n			while (i-- && ret === UNDEFINED) {\n				multi = Math.pow(1000, i + 1);\n				if (numericSymbolDetector >= multi && numericSymbols[i] !== null) {\n					ret = numberFormat(value / multi, -1) + numericSymbols[i];\n				}\n			}\n		}\n		\n		if (ret === UNDEFINED) {\n			if (value >= 1000) { // add thousands separators\n				ret = numberFormat(value, 0);\n\n			} else { // small numbers\n				ret = numberFormat(value, -1);\n			}\n		}\n		\n		return ret;\n	},\n	\n	/**\n	 * Get the minimum and maximum for the series of each axis\n	 */\n	getSeriesExtremes: function () {\n		var axis = this,\n			chart = axis.chart,\n			stacks = axis.stacks,\n			posStack = [],\n			negStack = [],\n			i;\n		\n		axis.hasVisibleSeries = false;\n\n		// reset dataMin and dataMax in case we're redrawing\n		axis.dataMin = axis.dataMax = null;\n\n		// loop through this axis' series\n		each(axis.series, function (series) {\n\n			if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n\n				var seriesOptions = series.options,\n					stacking,\n					posPointStack,\n					negPointStack,\n					stackKey,\n					stackOption,\n					negKey,\n					xData,\n					yData,\n					x,\n					y,\n					threshold = seriesOptions.threshold,\n					yDataLength,\n					activeYData = [],\n					activeCounter = 0;\n					\n				axis.hasVisibleSeries = true;	\n					\n				// Validate threshold in logarithmic axes\n				if (axis.isLog && threshold <= 0) {\n					threshold = seriesOptions.threshold = null;\n				}\n\n				// Get dataMin and dataMax for X axes\n				if (axis.isXAxis) {\n					xData = series.xData;\n					if (xData.length) {\n						axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));\n						axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));\n					}\n\n				// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data\n				} else {\n					var isNegative,\n						pointStack,\n						key,\n						cropped = series.cropped,\n						xExtremes = series.xAxis.getExtremes(),\n						//findPointRange,\n						//pointRange,\n						j,\n						hasModifyValue = !!series.modifyValue;\n\n\n					// Handle stacking\n					stacking = seriesOptions.stacking;\n					axis.usePercentage = stacking === 'percent';\n\n					// create a stack for this particular series type\n					if (stacking) {\n						stackOption = seriesOptions.stack;\n						stackKey = series.type + pick(stackOption, '');\n						negKey = '-' + stackKey;\n						series.stackKey = stackKey; // used in translate\n\n						posPointStack = posStack[stackKey] || []; // contains the total values for each x\n						posStack[stackKey] = posPointStack;\n\n						negPointStack = negStack[negKey] || [];\n						negStack[negKey] = negPointStack;\n					}\n					if (axis.usePercentage) {\n						axis.dataMin = 0;\n						axis.dataMax = 99;\n					}\n\n					// processData can alter series.pointRange, so this goes after\n					//findPointRange = series.pointRange === null;\n\n					xData = series.processedXData;\n					yData = series.processedYData;\n					yDataLength = yData.length;\n\n					// loop over the non-null y values and read them into a local array\n					for (i = 0; i < yDataLength; i++) {\n						x = xData[i];\n						y = yData[i];\n						\n						// Read stacked values into a stack based on the x value,\n						// the sign of y and the stack key. Stacking is also handled for null values (#739)\n						if (stacking) {\n							isNegative = y < threshold;\n							pointStack = isNegative ? negPointStack : posPointStack;\n							key = isNegative ? negKey : stackKey;\n\n							// Set the stack value and y for extremes\n							if (defined(pointStack[x])) { // we're adding to the stack\n								pointStack[x] = correctFloat(pointStack[x] + y);\n								y = [y, pointStack[x]]; // consider both the actual value and the stack (#1376)\n\n							} else { // it's the first point in the stack\n								pointStack[x] = y;\n							}\n\n							// add the series\n							if (!stacks[key]) {\n								stacks[key] = {};\n							}\n\n							// If the StackItem is there, just update the values,\n							// if not, create one first\n							if (!stacks[key][x]) {\n								stacks[key][x] = new StackItem(axis, axis.options.stackLabels, isNegative, x, stackOption, stacking);\n							}\n							stacks[key][x].setTotal(pointStack[x]);\n						}\n						\n						// Handle non null values\n						if (y !== null && y !== UNDEFINED) {							\n\n							// general hook, used for Highstock compare values feature\n							if (hasModifyValue) {\n								y = series.modifyValue(y);\n							}\n\n							// for points within the visible range, including the first point outside the\n							// visible range, consider y extremes\n							if (cropped || ((xData[i + 1] || x) >= xExtremes.min && (xData[i - 1] || x) <= xExtremes.max)) {\n\n								j = y.length;\n								if (j) { // array, like ohlc or range data\n									while (j--) {\n										if (y[j] !== null) {\n											activeYData[activeCounter++] = y[j];\n										}\n									}\n								} else {\n									activeYData[activeCounter++] = y;\n								}\n							}\n						}\n					}\n\n					// Get the dataMin and dataMax so far. If percentage is used, the min and max are\n					// always 0 and 100. If the length of activeYData is 0, continue with null values.\n					if (!axis.usePercentage && activeYData.length) {\n						axis.dataMin = mathMin(pick(axis.dataMin, activeYData[0]), arrayMin(activeYData));\n						axis.dataMax = mathMax(pick(axis.dataMax, activeYData[0]), arrayMax(activeYData));\n					}\n\n					// Adjust to threshold\n					if (defined(threshold)) {\n						if (axis.dataMin >= threshold) {\n							axis.dataMin = threshold;\n							axis.ignoreMinPadding = true;\n						} else if (axis.dataMax < threshold) {\n							axis.dataMax = threshold;\n							axis.ignoreMaxPadding = true;\n						}\n					}\n				}\n			}\n		});\n		\n	},\n\n	/**\n	 * Translate from axis value to pixel position on the chart, or back\n	 *\n	 */\n	translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacementBetween) {\n		var axis = this,\n			axisLength = axis.len,\n			sign = 1,\n			cvsOffset = 0,\n			localA = old ? axis.oldTransA : axis.transA,\n			localMin = old ? axis.oldMin : axis.min,\n			returnValue,\n			postTranslate = axis.options.ordinal || (axis.isLog && handleLog);\n\n		if (!localA) {\n			localA = axis.transA;\n		}\n\n		if (cvsCoord) {\n			sign *= -1; // canvas coordinates inverts the value\n			cvsOffset = axisLength;\n		}\n		if (axis.reversed) { // reversed axis\n			sign *= -1;\n			cvsOffset -= sign * axisLength;\n		}\n\n		if (backwards) { // reverse translation\n			if (axis.reversed) {\n				val = axisLength - val;\n			}\n			returnValue = val / localA + localMin; // from chart pixel to value\n			if (postTranslate) { // log and ordinal axes\n				returnValue = axis.lin2val(returnValue);\n			}\n\n		} else { // normal translation, from axis value to pixel, relative to plot\n			if (postTranslate) { // log and ordinal axes\n				val = axis.val2lin(val);\n			}\n\n			returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * axis.minPixelPadding) +\n				(pointPlacementBetween ? localA * axis.pointRange / 2 : 0);\n		}\n\n		return returnValue;\n	},\n\n	/**\n	 * Create the path for a plot line that goes from the given value on\n	 * this axis, across the plot to the opposite side\n	 * @param {Number} value\n	 * @param {Number} lineWidth Used for calculation crisp line\n	 * @param {Number] old Use old coordinates (for resizing and rescaling)\n	 */\n	getPlotLinePath: function (value, lineWidth, old) {\n		var axis = this,\n			chart = axis.chart,\n			axisLeft = axis.left,\n			axisTop = axis.top,\n			x1,\n			y1,\n			x2,\n			y2,\n			translatedValue = axis.translate(value, null, null, old),\n			cHeight = (old && chart.oldChartHeight) || chart.chartHeight,\n			cWidth = (old && chart.oldChartWidth) || chart.chartWidth,\n			skip,\n			transB = axis.transB;\n\n		x1 = x2 = mathRound(translatedValue + transB);\n		y1 = y2 = mathRound(cHeight - translatedValue - transB);\n\n		if (isNaN(translatedValue)) { // no min or max\n			skip = true;\n\n		} else if (axis.horiz) {\n			y1 = axisTop;\n			y2 = cHeight - axis.bottom;\n			if (x1 < axisLeft || x1 > axisLeft + axis.width) {\n				skip = true;\n			}\n		} else {\n			x1 = axisLeft;\n			x2 = cWidth - axis.right;\n\n			if (y1 < axisTop || y1 > axisTop + axis.height) {\n				skip = true;\n			}\n		}\n		return skip ?\n			null :\n			chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 0);\n	},\n	\n	/**\n	 * Create the path for a plot band\n	 */\n	getPlotBandPath: function (from, to) {\n\n		var toPath = this.getPlotLinePath(to),\n			path = this.getPlotLinePath(from);\n			\n		if (path && toPath) {\n			path.push(\n				toPath[4],\n				toPath[5],\n				toPath[1],\n				toPath[2]\n			);\n		} else { // outside the axis area\n			path = null;\n		}\n		\n		return path;\n	},\n	\n	/**\n	 * Set the tick positions of a linear axis to round values like whole tens or every five.\n	 */\n	getLinearTickPositions: function (tickInterval, min, max) {\n		var pos,\n			lastPos,\n			roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),\n			roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),\n			tickPositions = [];\n\n		// Populate the intermediate values\n		pos = roundedMin;\n		while (pos <= roundedMax) {\n\n			// Place the tick on the rounded value\n			tickPositions.push(pos);\n\n			// Always add the raw tickInterval, not the corrected one.\n			pos = correctFloat(pos + tickInterval);\n\n			// If the interval is not big enough in the current min - max range to actually increase\n			// the loop variable, we need to break out to prevent endless loop. Issue #619\n			if (pos === lastPos) {\n				break;\n			}\n\n			// Record the last value\n			lastPos = pos;\n		}\n		return tickPositions;\n	},\n	\n	/**\n	 * Set the tick positions of a logarithmic axis\n	 */\n	getLogTickPositions: function (interval, min, max, minor) {\n		var axis = this,\n			options = axis.options,\n			axisLength = axis.len;\n\n		// Since we use this method for both major and minor ticks,\n		// use a local variable and return the result\n		var positions = []; \n		\n		// Reset\n		if (!minor) {\n			axis._minorAutoInterval = null;\n		}\n		\n		// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.\n		if (interval >= 0.5) {\n			interval = mathRound(interval);\n			positions = axis.getLinearTickPositions(interval, min, max);\n			\n		// Second case: We need intermediary ticks. For example \n		// 1, 2, 4, 6, 8, 10, 20, 40 etc. \n		} else if (interval >= 0.08) {\n			var roundedMin = mathFloor(min),\n				intermediate,\n				i,\n				j,\n				len,\n				pos,\n				lastPos,\n				break2;\n				\n			if (interval > 0.3) {\n				intermediate = [1, 2, 4];\n			} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc\n				intermediate = [1, 2, 4, 6, 8];\n			} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc\n				intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n			}\n			\n			for (i = roundedMin; i < max + 1 && !break2; i++) {\n				len = intermediate.length;\n				for (j = 0; j < len && !break2; j++) {\n					pos = log2lin(lin2log(i) * intermediate[j]);\n					\n					if (pos > min) {\n						positions.push(lastPos);\n					}\n					\n					if (lastPos > max) {\n						break2 = true;\n					}\n					lastPos = pos;\n				}\n			}\n			\n		// Third case: We are so deep in between whole logarithmic values that\n		// we might as well handle the tick positions like a linear axis. For\n		// example 1.01, 1.02, 1.03, 1.04.\n		} else {\n			var realMin = lin2log(min),\n				realMax = lin2log(max),\n				tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],\n				filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,\n				tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),\n				totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;\n			\n			interval = pick(\n				filteredTickIntervalOption,\n				axis._minorAutoInterval,\n				(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)\n			);\n			\n			interval = normalizeTickInterval(\n				interval, \n				null, \n				math.pow(10, mathFloor(math.log(interval) / math.LN10))\n			);\n			\n			positions = map(axis.getLinearTickPositions(\n				interval, \n				realMin,\n				realMax	\n			), log2lin);\n			\n			if (!minor) {\n				axis._minorAutoInterval = interval / 5;\n			}\n		}\n		\n		// Set the axis-level tickInterval variable \n		if (!minor) {\n			axis.tickInterval = interval;\n		}\n		return positions;\n	},\n\n	/**\n	 * Return the minor tick positions. For logarithmic axes, reuse the same logic\n	 * as for major ticks.\n	 */\n	getMinorTickPositions: function () {\n		var axis = this,\n			options = axis.options,\n			tickPositions = axis.tickPositions,\n			minorTickInterval = axis.minorTickInterval;\n\n		var minorTickPositions = [],\n			pos,\n			i,\n			len;\n		\n		if (axis.isLog) {\n			len = tickPositions.length;\n			for (i = 1; i < len; i++) {\n				minorTickPositions = minorTickPositions.concat(\n					axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)\n				);	\n			}\n		} else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314\n			minorTickPositions = minorTickPositions.concat(\n				getTimeTicks(\n					normalizeTimeTickInterval(minorTickInterval),\n					axis.min,\n					axis.max,\n					options.startOfWeek\n				)\n			);\n		} else {			\n			for (pos = axis.min + (tickPositions[0] - axis.min) % minorTickInterval; pos <= axis.max; pos += minorTickInterval) {\n				minorTickPositions.push(pos);	\n			}\n		}\n		return minorTickPositions;\n	},\n\n	/**\n	 * Adjust the min and max for the minimum range. Keep in mind that the series data is \n	 * not yet processed, so we don't have information on data cropping and grouping, or \n	 * updated axis.pointRange or series.pointRange. The data can't be processed until\n	 * we have finally established min and max.\n	 */\n	adjustForMinRange: function () {\n		var axis = this,\n			options = axis.options,\n			min = axis.min,\n			max = axis.max,\n			zoomOffset,\n			spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,\n			closestDataRange,\n			i,\n			distance,\n			xData,\n			loopLength,\n			minArgs,\n			maxArgs;\n\n		// Set the automatic minimum range based on the closest point distance\n		if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {\n\n			if (defined(options.min) || defined(options.max)) {\n				axis.minRange = null; // don't do this again\n\n			} else {\n\n				// Find the closest distance between raw data points, as opposed to\n				// closestPointRange that applies to processed points (cropped and grouped)\n				each(axis.series, function (series) {\n					xData = series.xData;\n					loopLength = series.xIncrement ? 1 : xData.length - 1;\n					for (i = loopLength; i > 0; i--) {\n						distance = xData[i] - xData[i - 1];\n						if (closestDataRange === UNDEFINED || distance < closestDataRange) {\n							closestDataRange = distance;\n						}\n					}\n				});\n				axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);\n			}\n		}\n\n		// if minRange is exceeded, adjust\n		if (max - min < axis.minRange) {\n			var minRange = axis.minRange;\n			zoomOffset = (minRange - max + min) / 2;\n\n			// if min and max options have been set, don't go beyond it\n			minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];\n			if (spaceAvailable) { // if space is available, stay within the data range\n				minArgs[2] = axis.dataMin;\n			}\n			min = arrayMax(minArgs);\n\n			maxArgs = [min + minRange, pick(options.max, min + minRange)];\n			if (spaceAvailable) { // if space is availabe, stay within the data range\n				maxArgs[2] = axis.dataMax;\n			}\n\n			max = arrayMin(maxArgs);\n\n			// now if the max is adjusted, adjust the min back\n			if (max - min < minRange) {\n				minArgs[0] = max - minRange;\n				minArgs[1] = pick(options.min, max - minRange);\n				min = arrayMax(minArgs);\n			}\n		}\n		\n		// Record modified extremes\n		axis.min = min;\n		axis.max = max;\n	},\n\n	/**\n	 * Update translation information\n	 */\n	setAxisTranslation: function () {\n		var axis = this,\n			range = axis.max - axis.min,\n			pointRange = 0,\n			closestPointRange,\n			minPointOffset = 0,\n			pointRangePadding = 0,\n			linkedParent = axis.linkedParent,\n			transA = axis.transA;\n\n		// adjust translation for padding\n		if (axis.isXAxis) {\n			if (linkedParent) {\n				minPointOffset = linkedParent.minPointOffset;\n				pointRangePadding = linkedParent.pointRangePadding;\n				\n			} else {\n				each(axis.series, function (series) {\n					var seriesPointRange = series.pointRange,\n						pointPlacement = series.options.pointPlacement");
        builder.append(",\n						seriesClosestPointRange = series.closestPointRange;\n						\n					pointRange = mathMax(pointRange, seriesPointRange);\n					\n					// minPointOffset is the value padding to the left of the axis in order to make\n					// room for points with a pointRange, typically columns. When the pointPlacement option\n					// is 'between' or 'on', this padding does not apply.\n					minPointOffset = mathMax(\n						minPointOffset, \n						pointPlacement ? 0 : seriesPointRange / 2\n					);\n					\n					// Determine the total padding needed to the length of the axis to make room for the \n					// pointRange. If the series' pointPlacement is 'on', no padding is added.\n					pointRangePadding = mathMax(\n						pointRangePadding,\n						pointPlacement === 'on' ? 0 : seriesPointRange\n					);\n\n					// Set the closestPointRange\n					if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {\n						closestPointRange = defined(closestPointRange) ?\n							mathMin(closestPointRange, seriesClosestPointRange) :\n							seriesClosestPointRange;\n					}\n				});\n			}\n			\n			// Record minPointOffset and pointRangePadding\n			axis.minPointOffset = minPointOffset;\n			axis.pointRangePadding = pointRangePadding;\n\n			// pointRange means the width reserved for each point, like in a column chart\n			axis.pointRange = pointRange;\n\n			// closestPointRange means the closest distance between points. In columns\n			// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange\n			// is some other value\n			axis.closestPointRange = closestPointRange;\n		}\n		\n		// secondary values\n		axis.oldTransA = transA;\n		//axis.translationSlope = axis.transA = transA = axis.len / ((range + (2 * minPointOffset)) || 1);\n		axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);\n		axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend\n		axis.minPixelPadding = transA * minPointOffset;\n	},\n\n	/**\n	 * Set the tick positions to round values and optionally extend the extremes\n	 * to the nearest tick\n	 */\n	setTickPositions: function (secondPass) {\n		var axis = this,\n			chart = axis.chart,\n			options = axis.options,\n			isLog = axis.isLog,\n			isDatetimeAxis = axis.isDatetimeAxis,\n			isXAxis = axis.isXAxis,\n			isLinked = axis.isLinked,\n			tickPositioner = axis.options.tickPositioner,\n			magnitude,\n			maxPadding = options.maxPadding,\n			minPadding = options.minPadding,\n			length,\n			linkedParentExtremes,\n			tickIntervalOption = options.tickInterval,\n			minTickIntervalOption = options.minTickInterval,\n			tickPixelIntervalOption = options.tickPixelInterval,\n			tickPositions,\n			categories = axis.categories;\n\n		// linked axis gets the extremes from the parent axis\n		if (isLinked) {\n			axis.linkedParent = chart[isXAxis ? 'xAxis' : 'yAxis'][options.linkedTo];\n			linkedParentExtremes = axis.linkedParent.getExtremes();\n			axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n			axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n			if (options.type !== axis.linkedParent.options.type) {\n				error(11, 1); // Can't link axes of different type\n			}\n		} else { // initial min and max from the extreme data values\n			axis.min = pick(axis.userMin, options.min, axis.dataMin);\n			axis.max = pick(axis.userMax, options.max, axis.dataMax);\n		}\n\n		if (isLog) {\n			if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978\n				error(10, 1); // Can't plot negative values on log axis\n			}\n			axis.min = correctFloat(log2lin(axis.min)); // correctFloat cures #934\n			axis.max = correctFloat(log2lin(axis.max));\n		}\n\n		// handle zoomed range\n		if (axis.range) {\n			axis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range); // #618\n			axis.userMax = axis.max;\n			if (secondPass) {\n				axis.range = null;  // don't use it when running setExtremes\n			}\n		}\n\n		// adjust min and max for the minimum range\n		axis.adjustForMinRange();\n		\n		// Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding\n		// into account, we do this after computing tick interval (#1337).\n		if (!categories && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {\n			length = axis.max - axis.min;\n			if (length) {\n				if (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {\n					axis.min -= length * minPadding;\n				}\n				if (!defined(options.max) && !defined(axis.userMax)  && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {\n					axis.max += length * maxPadding;\n				}\n			}\n		}\n\n		// get tickInterval\n		if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {\n			axis.tickInterval = 1;\n		} else if (isLinked && !tickIntervalOption &&\n				tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n			axis.tickInterval = axis.linkedParent.tickInterval;\n		} else {\n			axis.tickInterval = pick(\n				tickIntervalOption,\n				categories ? // for categoried axis, 1 is default, for linear axis use tickPix\n					1 :\n					(axis.max - axis.min) * tickPixelIntervalOption / (axis.len || 1)\n			);\n		}\n\n		// Now we're finished detecting min and max, crop and group series data. This\n		// is in turn needed in order to find tick positions in ordinal axes. \n		if (isXAxis && !secondPass) {\n			each(axis.series, function (series) {\n				series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);\n			});\n		}\n\n		// set the translation factor used in translate function\n		axis.setAxisTranslation(secondPass);\n\n		// hook for ordinal axes and radial axes\n		if (axis.beforeSetTickPositions) {\n			axis.beforeSetTickPositions();\n		}\n		\n		// hook for extensions, used in Highstock ordinal axes\n		if (axis.postProcessTickInterval) {\n			axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n		}\n		\n		// Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.\n		if (!tickIntervalOption && axis.tickInterval < minTickIntervalOption) {\n			axis.tickInterval = minTickIntervalOption;\n		}\n\n		// for linear axes, get magnitude and normalize the interval\n		if (!isDatetimeAxis && !isLog) { // linear\n			magnitude = math.pow(10, mathFloor(math.log(axis.tickInterval) / math.LN10));\n			if (!tickIntervalOption) {\n				axis.tickInterval = normalizeTickInterval(axis.tickInterval, null, magnitude, options);\n			}\n		}\n\n		// get minorTickInterval\n		axis.minorTickInterval = options.minorTickInterval === 'auto' && axis.tickInterval ?\n				axis.tickInterval / 5 : options.minorTickInterval;\n\n		// find the tick positions\n		axis.tickPositions = tickPositions = options.tickPositions || (tickPositioner && tickPositioner.apply(axis, [axis.min, axis.max]));\n		if (!tickPositions) {\n			if (isDatetimeAxis) {\n				tickPositions = (axis.getNonLinearTimeTicks || getTimeTicks)(\n					normalizeTimeTickInterval(axis.tickInterval, options.units),\n					axis.min,\n					axis.max,\n					options.startOfWeek,\n					axis.ordinalPositions,\n					axis.closestPointRange,\n					true\n				);\n			} else if (isLog) {\n				tickPositions = axis.getLogTickPositions(axis.tickInterval, axis.min, axis.max);\n			} else {\n				tickPositions = axis.getLinearTickPositions(axis.tickInterval, axis.min, axis.max);\n			}\n			axis.tickPositions = tickPositions;\n		}\n\n		if (!isLinked) {\n\n			// reset min/max or remove extremes based on start/end on tick\n			var roundedMin = tickPositions[0],\n				roundedMax = tickPositions[tickPositions.length - 1],\n				minPointOffset = axis.minPointOffset || 0,\n				singlePad;\n\n			if (options.startOnTick) {\n				axis.min = roundedMin;\n			} else if (axis.min - minPointOffset > roundedMin) {\n				tickPositions.shift();\n			}\n\n			if (options.endOnTick) {\n				axis.max = roundedMax;\n			} else if (axis.max + minPointOffset < roundedMax) {\n				tickPositions.pop();\n			}\n			\n			// When there is only one point, or all points have the same value on this axis, then min\n			// and max are equal and tickPositions.length is 1. In this case, add some padding\n			// in order to center the point, but leave it with one tick. #1337.\n			if (tickPositions.length === 1) {\n				singlePad = 1e-9; // The lowest possible number to avoid extra padding on columns\n				axis.min -= singlePad;\n				axis.max += singlePad;\n			}\n		}\n	},\n	\n	/**\n	 * Set the max ticks of either the x and y axis collection\n	 */\n	setMaxTicks: function () {\n		\n		var chart = this.chart,\n			maxTicks = chart.maxTicks,\n			tickPositions = this.tickPositions,\n			xOrY = this.xOrY;\n		\n		if (!maxTicks) { // first call, or maxTicks have been reset after a zoom operation\n			maxTicks = {\n				x: 0,\n				y: 0\n			};\n		}\n\n		if (!this.isLinked && !this.isDatetimeAxis && tickPositions.length > maxTicks[xOrY] && this.options.alignTicks !== false) {\n			maxTicks[xOrY] = tickPositions.length;\n		}\n		chart.maxTicks = maxTicks;\n	},\n\n	/**\n	 * When using multiple axes, adjust the number of ticks to match the highest\n	 * number of ticks in that group\n	 */\n	adjustTickAmount: function () {\n		var axis = this,\n			chart = axis.chart,\n			xOrY = axis.xOrY,\n			tickPositions = axis.tickPositions,\n			maxTicks = chart.maxTicks;\n\n		if (maxTicks && maxTicks[xOrY] && !axis.isDatetimeAxis && !axis.categories && !axis.isLinked && axis.options.alignTicks !== false) { // only apply to linear scale\n			var oldTickAmount = axis.tickAmount,\n				calculatedTickAmount = tickPositions.length,\n				tickAmount;\n\n			// set the axis-level tickAmount to use below\n			axis.tickAmount = tickAmount = maxTicks[xOrY];\n\n			if (calculatedTickAmount < tickAmount) {\n				while (tickPositions.length < tickAmount) {\n					tickPositions.push(correctFloat(\n						tickPositions[tickPositions.length - 1] + axis.tickInterval\n					));\n				}\n				axis.transA *= (calculatedTickAmount - 1) / (tickAmount - 1);\n				axis.max = tickPositions[tickPositions.length - 1];\n\n			}\n			if (defined(oldTickAmount) && tickAmount !== oldTickAmount) {\n				axis.isDirty = true;\n			}\n		}\n	},\n\n	/**\n	 * Set the scale based on data min and max, user set min and max or options\n	 *\n	 */\n	setScale: function () {\n		var axis = this,\n			stacks = axis.stacks,\n			type,\n			i,\n			isDirtyData,\n			isDirtyAxisLength;\n\n		axis.oldMin = axis.min;\n		axis.oldMax = axis.max;\n		axis.oldAxisLength = axis.len;\n\n		// set the new axisLength\n		axis.setAxisSize();\n		//axisLength = horiz ? axisWidth : axisHeight;\n		isDirtyAxisLength = axis.len !== axis.oldAxisLength;\n\n		// is there new data?\n		each(axis.series, function (series) {\n			if (series.isDirtyData || series.isDirty ||\n					series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well\n				isDirtyData = true;\n			}\n		});\n		\n		// do we really need to go through all this?\n		if (isDirtyAxisLength || isDirtyData || axis.isLinked ||\n			axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {\n\n			// get data extremes if needed\n			axis.getSeriesExtremes();\n\n			// get fixed positions based on tickInterval\n			axis.setTickPositions();\n\n			// record old values to decide whether a rescale is necessary later on (#540)\n			axis.oldUserMin = axis.userMin;\n			axis.oldUserMax = axis.userMax;\n\n			// Mark as dirty if it is not already set to dirty and extremes have changed. #595.\n			if (!axis.isDirty) {\n				axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;\n			}\n		}\n		\n		\n		// reset stacks\n		if (!axis.isXAxis) {\n			for (type in stacks) {\n				for (i in stacks[type]) {\n					stacks[type][i].cum = stacks[type][i].total;\n				}\n			}\n		}\n		\n		// Set the maximum tick amount\n		axis.setMaxTicks();\n	},\n\n	/**\n	 * Set the extremes and optionally redraw\n	 * @param {Number} newMin\n	 * @param {Number} newMax\n	 * @param {Boolean} redraw\n	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n	 *    configuration\n	 * @param {Object} eventArguments \n	 *\n	 */\n	setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {\n		var axis = this,\n			chart = axis.chart;\n\n		redraw = pick(redraw, true); // defaults to true\n\n		// Extend the arguments with min and max\n		eventArguments = extend(eventArguments, {\n			min: newMin,\n			max: newMax\n		});\n\n		// Fire the event\n		fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler\n\n			axis.userMin = newMin;\n			axis.userMax = newMax;\n\n			// Mark for running afterSetExtremes\n			axis.isDirtyExtremes = true;\n\n			// redraw\n			if (redraw) {\n				chart.redraw(animation);\n			}\n		});\n	},\n	\n	/**\n	 * Overridable method for zooming chart. Pulled out in a separate method to allow overriding\n	 * in stock charts.\n	 */\n	zoom: function (newMin, newMax) {\n		this.setExtremes(newMin, newMax, false, UNDEFINED, { trigger: 'zoom' });\n		return true;\n	},\n	\n	/**\n	 * Update the axis metrics\n	 */\n	setAxisSize: function () {\n		var axis = this,\n			chart = axis.chart,\n			options = axis.options;\n\n		var offsetLeft = options.offsetLeft || 0,\n			offsetRight = options.offsetRight || 0;\n\n		// basic values\n		// expose to use in Series object and navigator\n		axis.left = pick(options.left, chart.plotLeft + offsetLeft);\n		axis.top = pick(options.top, chart.plotTop);\n		axis.width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight);\n		axis.height = pick(options.height, chart.plotHeight);\n		axis.bottom = chart.chartHeight - axis.height - axis.top;\n		axis.right = chart.chartWidth - axis.width - axis.left;\n		axis.len = mathMax(axis.horiz ? axis.width : axis.height, 0); // mathMax fixes #905\n	},\n\n	/**\n	 * Get the actual axis extremes\n	 */\n	getExtremes: function () {\n		var axis = this,\n			isLog = axis.isLog;\n\n		return {\n			min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,\n			max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,\n			dataMin: axis.dataMin,\n			dataMax: axis.dataMax,\n			userMin: axis.userMin,\n			userMax: axis.userMax\n		};\n	},\n\n	/**\n	 * Get the zero plane either based on zero or on the min or max value.\n	 * Used in bar and area plots\n	 */\n	getThreshold: function (threshold) {\n		var axis = this,\n			isLog = axis.isLog;\n\n		var realMin = isLog ? lin2log(axis.min) : axis.min,\n			realMax = isLog ? lin2log(axis.max) : axis.max;\n		\n		if (realMin > threshold || threshold === null) {\n			threshold = realMin;\n		} else if (realMax < threshold) {\n			threshold = realMax;\n		}\n\n		return axis.translate(threshold, 0, 1, 0, 1);\n	},\n\n	/**\n	 * Add a plot band or plot line after render time\n	 *\n	 * @param options {Object} The plotBand or plotLine configuration object\n	 */\n	addPlotBandOrLine: function (options) {\n		var obj = new PlotLineOrBand(this, options).render();\n		this.plotLinesAndBands.push(obj);\n		return obj;\n	},\n\n	/**\n	 * Render the tick labels to a preliminary position to get their sizes\n	 */\n	getOffset: function () {\n		var axis = this,\n			chart = axis.chart,\n			renderer = chart.renderer,\n			options = axis.options,\n			tickPositions = axis.tickPositions,\n			ticks = axis.ticks,\n			horiz = axis.horiz,\n			side = axis.side,\n			hasData,\n			showAxis,\n			titleOffset = 0,\n			titleOffsetOption,\n			titleMargin = 0,\n			axisTitleOptions = options.title,\n			labelOptions = options.labels,\n			labelOffset = 0, // reset\n			axisOffset = chart.axisOffset,\n			directionFactor = [-1, 1, 1, -1][side],\n			n;\n			\n			\n		// For reuse in Axis.render\n		axis.hasData = hasData = (axis.hasVisibleSeries || (defined(axis.min) && defined(axis.max) && !!tickPositions));\n		axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);\n		\n		\n		// Create the axisGroup and gridGroup elements on first iteration\n		if (!axis.axisGroup) {\n			axis.gridGroup = renderer.g('grid')\n				.attr({ zIndex: options.gridZIndex || 1 })\n				.add();\n			axis.axisGroup = renderer.g('axis')\n				.attr({ zIndex: options.zIndex || 2 })\n				.add();\n			axis.labelGroup = renderer.g('axis-labels')\n				.attr({ zIndex: labelOptions.zIndex || 7 })\n				.add();\n		}\n\n		if (hasData || axis.isLinked) {\n			each(tickPositions, function (pos) {\n				if (!ticks[pos]) {\n					ticks[pos] = new Tick(axis, pos);\n				} else {\n					ticks[pos].addLabel(); // update labels depending on tick interval\n				}\n\n			});\n\n			each(tickPositions, function (pos) {\n				// left side must be align: right and right side must have align: left for labels\n				if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === labelOptions.align) {\n\n					// get the highest offset\n					labelOffset = mathMax(\n						ticks[pos].getLabelSi");
        builder.append("ze(),\n						labelOffset\n					);\n				}\n\n			});\n\n			if (axis.staggerLines) {\n				labelOffset += (axis.staggerLines - 1) * 16;\n			}\n\n		} else { // doesn't have data\n			for (n in ticks) {\n				ticks[n].destroy();\n				delete ticks[n];\n			}\n		}\n\n		if (axisTitleOptions && axisTitleOptions.text) {\n			if (!axis.axisTitle) {\n				axis.axisTitle = renderer.text(\n					axisTitleOptions.text,\n					0,\n					0,\n					axisTitleOptions.useHTML\n				)\n				.attr({\n					zIndex: 7,\n					rotation: axisTitleOptions.rotation || 0,\n					align:\n						axisTitleOptions.textAlign ||\n						{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]\n				})\n				.css(axisTitleOptions.style)\n				.add(axis.axisGroup);\n				axis.axisTitle.isNew = true;\n			}\n\n			if (showAxis) {\n				titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n				titleMargin = pick(axisTitleOptions.margin, horiz ? 5 : 10);\n				titleOffsetOption = axisTitleOptions.offset;\n			}\n\n			// hide or show the title depending on whether showEmpty is set\n			axis.axisTitle[showAxis ? 'show' : 'hide']();\n		}\n		\n		// handle automatic or user set offset\n		axis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n		\n		\n		axis.axisTitleMargin =\n			pick(titleOffsetOption,\n				labelOffset + titleMargin +\n				(side !== 2 && labelOffset && directionFactor * options.labels[horiz ? 'y' : 'x'])\n			);\n\n		axisOffset[side] = mathMax(\n			axisOffset[side],\n			axis.axisTitleMargin + titleOffset + directionFactor * axis.offset\n		);\n\n	},\n	\n	/**\n	 * Get the path for the axis line\n	 */\n	getLinePath: function (lineWidth) {\n		var chart = this.chart,\n			opposite = this.opposite,\n			offset = this.offset,\n			horiz = this.horiz,\n			lineLeft = this.left + (opposite ? this.width : 0) + offset,\n			lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;\n			\n		this.lineTop = lineTop; // used by flag series\n\n		return chart.renderer.crispLine([\n				M,\n				horiz ?\n					this.left :\n					lineLeft,\n				horiz ?\n					lineTop :\n					this.top,\n				L,\n				horiz ?\n					chart.chartWidth - this.right :\n					lineLeft,\n				horiz ?\n					lineTop :\n					chart.chartHeight - this.bottom\n			], lineWidth);\n	},\n	\n	/**\n	 * Position the title\n	 */\n	getTitlePosition: function () {\n		// compute anchor points for each of the title align options\n		var horiz = this.horiz,\n			axisLeft = this.left,\n			axisTop = this.top,\n			axisLength = this.len,\n			axisTitleOptions = this.options.title,			\n			margin = horiz ? axisLeft : axisTop,\n			opposite = this.opposite,\n			offset = this.offset,\n			fontSize = pInt(axisTitleOptions.style.fontSize || 12),\n			\n			// the position in the length direction of the axis\n			alongAxis = {\n				low: margin + (horiz ? 0 : axisLength),\n				middle: margin + axisLength / 2,\n				high: margin + (horiz ? axisLength : 0)\n			}[axisTitleOptions.align],\n	\n			// the position in the perpendicular direction of the axis\n			offAxis = (horiz ? axisTop + this.height : axisLeft) +\n				(horiz ? 1 : -1) * // horizontal axis reverses the margin\n				(opposite ? -1 : 1) * // so does opposite axes\n				this.axisTitleMargin +\n				(this.side === 2 ? fontSize : 0);\n\n		return {\n			x: horiz ?\n				alongAxis :\n				offAxis + (opposite ? this.width : 0) + offset +\n					(axisTitleOptions.x || 0), // x\n			y: horiz ?\n				offAxis - (opposite ? this.height : 0) + offset :\n				alongAxis + (axisTitleOptions.y || 0) // y\n		};\n	},\n	\n	/**\n	 * Render the axis\n	 */\n	render: function () {\n		var axis = this,\n			chart = axis.chart,\n			renderer = chart.renderer,\n			options = axis.options,\n			isLog = axis.isLog,\n			isLinked = axis.isLinked,\n			tickPositions = axis.tickPositions,\n			axisTitle = axis.axisTitle,\n			stacks = axis.stacks,\n			ticks = axis.ticks,\n			minorTicks = axis.minorTicks,\n			alternateBands = axis.alternateBands,\n			stackLabelOptions = options.stackLabels,\n			alternateGridColor = options.alternateGridColor,\n			tickmarkOffset = axis.tickmarkOffset,\n			lineWidth = options.lineWidth,\n			linePath,\n			hasRendered = chart.hasRendered,\n			slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),\n			hasData = axis.hasData,\n			showAxis = axis.showAxis,\n			from,\n			to;\n\n		// If the series has data draw the ticks. Else only the line and title\n		if (hasData || isLinked) {\n\n			// minor ticks\n			if (axis.minorTickInterval && !axis.categories) {\n				each(axis.getMinorTickPositions(), function (pos) {\n					if (!minorTicks[pos]) {\n						minorTicks[pos] = new Tick(axis, pos, 'minor');\n					}\n\n					// render new ticks in old position\n					if (slideInTicks && minorTicks[pos].isNew) {\n						minorTicks[pos].render(null, true);\n					}\n\n\n					minorTicks[pos].isActive = true;\n					minorTicks[pos].render();\n				});\n			}\n\n			// Major ticks. Pull out the first item and render it last so that\n			// we can get the position of the neighbour label. #808.\n			if (tickPositions.length) { // #1300\n				each(tickPositions.slice(1).concat([tickPositions[0]]), function (pos, i) {\n	\n					// Reorganize the indices\n					i = (i === tickPositions.length - 1) ? 0 : i + 1;\n	\n					// linked axes need an extra check to find out if\n					if (!isLinked || (pos >= axis.min && pos <= axis.max)) {\n	\n						if (!ticks[pos]) {\n							ticks[pos] = new Tick(axis, pos);\n						}\n	\n						// render new ticks in old position\n						if (slideInTicks && ticks[pos].isNew) {\n							ticks[pos].render(i, true);\n						}\n	\n						ticks[pos].isActive = true;\n						ticks[pos].render(i);\n					}\n	\n				});\n			}\n\n			// alternate grid color\n			if (alternateGridColor) {\n				each(tickPositions, function (pos, i) {\n					if (i % 2 === 0 && pos < axis.max) {\n						if (!alternateBands[pos]) {\n							alternateBands[pos] = new PlotLineOrBand(axis);\n						}\n						from = pos + tickmarkOffset; // #949\n						to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;\n						alternateBands[pos].options = {\n							from: isLog ? lin2log(from) : from,\n							to: isLog ? lin2log(to) : to,\n							color: alternateGridColor\n						};\n						alternateBands[pos].render();\n						alternateBands[pos].isActive = true;\n					}\n				});\n			}\n\n			// custom plot lines and bands\n			if (!axis._addedPlotLB) { // only first time\n				each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {\n					//plotLinesAndBands.push(new PlotLineOrBand(plotLineOptions).render());\n					axis.addPlotBandOrLine(plotLineOptions);\n				});\n				axis._addedPlotLB = true;\n			}\n\n		} // end if hasData\n\n		// remove inactive ticks\n		each([ticks, minorTicks, alternateBands], function (coll) {\n			var pos;\n			for (pos in coll) {\n				if (!coll[pos].isActive) {\n					coll[pos].destroy();\n					delete coll[pos];\n				} else {\n					coll[pos].isActive = false; // reset\n				}\n			}\n		});\n\n		// Static items. As the axis group is cleared on subsequent calls\n		// to render, these items are added outside the group.\n		// axis line\n		if (lineWidth) {\n			linePath = axis.getLinePath(lineWidth);\n			if (!axis.axisLine) {\n				axis.axisLine = renderer.path(linePath)\n					.attr({\n						stroke: options.lineColor,\n						'stroke-width': lineWidth,\n						zIndex: 7\n					})\n					.add(axis.axisGroup);\n			} else {\n				axis.axisLine.animate({ d: linePath });\n			}\n\n			// show or hide the line depending on options.showEmpty\n			axis.axisLine[showAxis ? 'show' : 'hide']();\n		}\n\n		if (axisTitle && showAxis) {\n			\n			axisTitle[axisTitle.isNew ? 'attr' : 'animate'](\n				axis.getTitlePosition()\n			);\n			axisTitle.isNew = false;\n		}\n\n		// Stacked totals:\n		if (stackLabelOptions && stackLabelOptions.enabled) {\n			var stackKey, oneStack, stackCategory,\n				stackTotalGroup = axis.stackTotalGroup;\n\n			// Create a separate group for the stack total labels\n			if (!stackTotalGroup) {\n				axis.stackTotalGroup = stackTotalGroup =\n					renderer.g('stack-labels')\n						.attr({\n							visibility: VISIBLE,\n							zIndex: 6\n						})\n						.add();\n			}\n\n			// plotLeft/Top will change when y axis gets wider so we need to translate the\n			// stackTotalGroup at every render call. See bug #506 and #516\n			stackTotalGroup.translate(chart.plotLeft, chart.plotTop);\n\n			// Render each stack total\n			for (stackKey in stacks) {\n				oneStack = stacks[stackKey];\n				for (stackCategory in oneStack) {\n					oneStack[stackCategory].render(stackTotalGroup);\n				}\n			}\n		}\n		// End stacked totals\n\n		axis.isDirty = false;\n	},\n\n	/**\n	 * Remove a plot band or plot line from the chart by id\n	 * @param {Object} id\n	 */\n	removePlotBandOrLine: function (id) {\n		var plotLinesAndBands = this.plotLinesAndBands,\n			i = plotLinesAndBands.length;\n		while (i--) {\n			if (plotLinesAndBands[i].id === id) {\n				plotLinesAndBands[i].destroy();\n			}\n		}\n	},\n\n	/**\n	 * Update the axis title by options\n	 */\n	setTitle: function (newTitleOptions, redraw) {\n		var chart = this.chart,\n			options = this.options,\n			axisTitle = this.axisTitle;\n\n		options.title = merge(options.title, newTitleOptions);\n\n		this.axisTitle = axisTitle && axisTitle.destroy(); // #922\n		this.isDirty = true;\n\n		if (pick(redraw, true)) {\n			chart.redraw();\n		}\n	},\n\n	/**\n	 * Redraw the axis to reflect changes in the data or axis extremes\n	 */\n	redraw: function () {\n		var axis = this,\n			chart = axis.chart;\n\n		// hide tooltip and hover states\n		if (chart.tracker.resetTracker) {\n			chart.tracker.resetTracker(true);\n		}\n\n		// render the axis\n		axis.render();\n\n		// move plot lines and bands\n		each(axis.plotLinesAndBands, function (plotLine) {\n			plotLine.render();\n		});\n\n		// mark associated series as dirty and ready for redraw\n		each(axis.series, function (series) {\n			series.isDirty = true;\n		});\n\n	},\n\n	/**\n	 * Set new axis categories and optionally redraw\n	 * @param {Array} newCategories\n	 * @param {Boolean} doRedraw\n	 */\n	setCategories: function (newCategories, doRedraw) {\n		var axis = this,\n			chart = axis.chart;\n\n		// set the categories\n		axis.categories = axis.userOptions.categories = newCategories;\n\n		// force reindexing tooltips\n		each(axis.series, function (series) {\n			series.translate();\n			series.setTooltipPoints(true);\n		});\n\n\n		// optionally redraw\n		axis.isDirty = true;\n\n		if (pick(doRedraw, true)) {\n			chart.redraw();\n		}\n	},\n\n	/**\n	 * Destroys an Axis instance.\n	 */\n	destroy: function () {\n		var axis = this,\n			stacks = axis.stacks,\n			stackKey;\n\n		// Remove the events\n		removeEvent(axis);\n\n		// Destroy each stack total\n		for (stackKey in stacks) {\n			destroyObjectProperties(stacks[stackKey]);\n\n			stacks[stackKey] = null;\n		}\n\n		// Destroy collections\n		each([axis.ticks, axis.minorTicks, axis.alternateBands, axis.plotLinesAndBands], function (coll) {\n			destroyObjectProperties(coll);\n		});\n\n		// Destroy local variables\n		each(['stackTotalGroup', 'axisLine', 'axisGroup', 'gridGroup', 'labelGroup', 'axisTitle'], function (prop) {\n			if (axis[prop]) {\n				axis[prop] = axis[prop].destroy();\n			}\n		});\n	}\n\n	\n}; // end Axis\n\n/**\n * The tooltip object\n * @param {Object} chart The chart instance\n * @param {Object} options Tooltip options\n */\nfunction Tooltip(chart, options) {\n	var borderWidth = options.borderWidth,\n		style = options.style,\n		padding = pInt(style.padding);\n\n	// Save the chart and options\n	this.chart = chart;\n	this.options = options;\n\n	// Keep track of the current series\n	//this.currentSeries = UNDEFINED;\n\n	// List of crosshairs\n	this.crosshairs = [];\n\n	// Current values of x and y when animating\n	this.now = { x: 0, y: 0 };\n\n	// The tooltip is initially hidden\n	this.isHidden = true;\n\n	// create the label\n	this.label = chart.renderer.label('', 0, 0, options.shape, null, null, options.useHTML, null, 'tooltip')\n		.attr({\n			padding: padding,\n			fill: options.backgroundColor,\n			'stroke-width': borderWidth,\n			r: options.borderRadius,\n			zIndex: 8\n		})\n		.css(style)\n		.css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)\n		.hide()\n		.add();\n\n	// When using canVG the shadow shows up as a gray circle\n	// even if the tooltip is hidden.\n	if (!useCanVG) {\n		this.label.shadow(options.shadow);\n	}\n\n	// Public property for getting the shared state.\n	this.shared = options.shared;\n}\n\nTooltip.prototype = {\n	/**\n	 * Destroy the tooltip and its elements.\n	 */\n	destroy: function () {\n		each(this.crosshairs, function (crosshair) {\n			if (crosshair) {\n				crosshair.destroy();\n			}\n		});\n\n		// Destroy and clear local variables\n		if (this.label) {\n			this.label = this.label.destroy();\n		}\n	},\n\n	/**\n	 * Provide a soft movement for the tooltip\n	 *\n	 * @param {Number} x\n	 * @param {Number} y\n	 * @private\n	 */\n	move: function (x, y, anchorX, anchorY) {\n		var tooltip = this,\n			now = tooltip.now,\n			animate = tooltip.options.animation !== false && !tooltip.isHidden;\n\n		// get intermediate values for animation\n		extend(now, {\n			x: animate ? (2 * now.x + x) / 3 : x,\n			y: animate ? (now.y + y) / 2 : y,\n			anchorX: animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n			anchorY: animate ? (now.anchorY + anchorY) / 2 : anchorY\n		});\n\n		// move to the intermediate value\n		tooltip.label.attr(now);\n\n		\n		// run on next tick of the mouse tracker\n		if (animate && (mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1)) {\n		\n			// never allow two timeouts\n			clearTimeout(this.tooltipTimeout);\n			\n			// set the fixed interval ticking for the smooth tooltip\n			this.tooltipTimeout = setTimeout(function () {\n				// The interval function may still be running during destroy, so check that the chart is really there before calling.\n				if (tooltip) {\n					tooltip.move(x, y, anchorX, anchorY);\n				}\n			}, 32);\n			\n		}\n	},\n\n	/**\n	 * Hide the tooltip\n	 */\n	hide: function () {\n		if (!this.isHidden) {\n			var hoverPoints = this.chart.hoverPoints;\n\n			this.label.hide();\n\n			// hide previous hoverPoints and set new\n			if (hoverPoints) {\n				each(hoverPoints, function (point) {\n					point.setState();\n				});\n			}\n\n			this.chart.hoverPoints = null;\n			this.isHidden = true;\n		}\n	},\n\n	/**\n	 * Hide the crosshairs\n	 */\n	hideCrosshairs: function () {\n		each(this.crosshairs, function (crosshair) {\n			if (crosshair) {\n				crosshair.hide();\n			}\n		});\n	},\n	\n	/** \n	 * Extendable method to get the anchor position of the tooltip\n	 * from a point or set of points\n	 */\n	getAnchor: function (points, mouseEvent) {\n		var ret,\n			chart = this.chart,\n			inverted = chart.inverted,\n			plotX = 0,\n			plotY = 0,\n			yAxis;\n		\n		points = splat(points);\n		\n		// Pie uses a special tooltipPos\n		ret = points[0].tooltipPos;\n		\n		// When shared, use the average position\n		if (!ret) {\n			each(points, function (point) {\n				yAxis = point.series.yAxis;\n				plotX += point.plotX;\n				plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +\n					(!inverted && yAxis ? yAxis.top - chart.plotTop : 0); // #1151\n			});\n			\n			plotX /= points.length;\n			plotY /= points.length;\n			\n			ret = [\n				inverted ? chart.plotWidth - plotY : plotX,\n				this.shared && !inverted && points.length > 1 && mouseEvent ? \n					mouseEvent.chartY - chart.plotTop : // place shared tooltip next to the mouse (#424)\n					inverted ? chart.plotHeight - plotX : plotY\n			];\n		}\n\n		return map(ret, mathRound);\n	},\n	\n	/**\n	 * Place the tooltip in a chart without spilling over\n	 * and not covering the point it self.\n	 */\n	getPosition: function (boxWidth, boxHeight, point) {\n		\n		// Set up the variables\n		var chart = this.chart,\n			plotLeft = chart.plotLeft,\n			plotTop = chart.plotTop,\n			plotWidth = chart.plotWidth,\n			plotHeight = chart.plotHeight,\n			distance = pick(this.options.distance, 12),\n			pointX = point.plotX,\n			pointY = point.plotY,\n			x = pointX + plotLeft + (chart.inverted ? distance : -boxWidth - distance),\n			y = pointY - boxHeight + plotTop + 15, // 15 means the point is 15 pixels up from the bottom of the tooltip\n			alignedRight;\n	\n		// It is too far to the left, adjust it\n		if (x < 7) {\n			x = plotLeft + mathMax(pointX, 0) + distance;\n		}\n	\n		// Test to see if the tooltip is too far to the right,\n		// if it is, move it back to be inside and then up to not cover the point.\n		if ((x + boxWidth) > (plotLeft + plotWidth)) {\n			x -= (x + boxWidth) - (plotLeft + plotWidth);\n			y = pointY - boxHeight + plotTop - distance;\n			alignedRight = true;\n		}\n	\n		// If it is now above the plot area, align it to the top of the plot area\n		if (y < plotTop + 5) {\n			y = plotTop + 5;\n	\n			// If the tooltip is still covering the point, move it below instead\n			if (alignedRight && pointY >= y && point");
        builder.append("Y <= (y + boxHeight)) {\n				y = pointY + plotTop + distance; // below\n			}\n		} \n	\n		// Now if the tooltip is below the chart, move it up. It's better to cover the\n		// point than to disappear outside the chart. #834.\n		if (y + boxHeight > plotTop + plotHeight) {\n			y = mathMax(plotTop, plotTop + plotHeight - boxHeight - distance); // below\n		}\n	\n		return {x: x, y: y};\n	},\n\n	/**\n	 * Refresh the tooltip's text and position.\n	 * @param {Object} point\n	 */\n	refresh: function (point, mouseEvent) {\n		var tooltip = this,\n			chart = tooltip.chart,\n			label = tooltip.label,\n			options = tooltip.options;\n\n		/**\n		 * In case no user defined formatter is given, this will be used\n		 */\n		function defaultFormatter() {\n			var pThis = this,\n				items = pThis.points || splat(pThis),\n				series = items[0].series,\n				s;\n\n			// build the header\n			s = [series.tooltipHeaderFormatter(items[0].key)];\n\n			// build the values\n			each(items, function (item) {\n				series = item.series;\n				s.push((series.tooltipFormatter && series.tooltipFormatter(item)) ||\n					item.point.tooltipFormatter(series.tooltipOptions.pointFormat));\n			});\n\n			// footer\n			s.push(options.footerFormat || '');\n\n			return s.join('');\n		}\n\n		var x,\n			y,\n			show,\n			anchor,\n			textConfig = {},\n			text,\n			pointConfig = [],\n			formatter = options.formatter || defaultFormatter,\n			hoverPoints = chart.hoverPoints,\n			placedTooltipPoint,\n			borderColor,\n			crosshairsOptions = options.crosshairs,\n			shared = tooltip.shared,\n			currentSeries;\n			\n		// get the reference point coordinates (pie charts use tooltipPos)\n		anchor = tooltip.getAnchor(point, mouseEvent);\n		x = anchor[0];\n		y = anchor[1];\n\n		// shared tooltip, array is sent over\n		if (shared && !(point.series && point.series.noSharedTooltip)) {\n			\n			// hide previous hoverPoints and set new\n			\n			chart.hoverPoints = point;\n			if (hoverPoints) {\n				each(hoverPoints, function (point) {\n					point.setState();\n				});\n			}\n\n			each(point, function (item) {\n				item.setState(HOVER_STATE);\n\n				pointConfig.push(item.getLabelConfig());\n			});\n\n			textConfig = {\n				x: point[0].category,\n				y: point[0].y\n			};\n			textConfig.points = pointConfig;\n			point = point[0];\n\n		// single point tooltip\n		} else {\n			textConfig = point.getLabelConfig();\n		}\n		text = formatter.call(textConfig);\n\n		// register the current series\n		currentSeries = point.series;\n\n\n		// For line type series, hide tooltip if the point falls outside the plot\n		show = shared || !currentSeries.isCartesian || currentSeries.tooltipOutsidePlot || chart.isInsidePlot(x, y);\n\n		// update the inner HTML\n		if (text === false || !show) {\n			this.hide();\n		} else {\n\n			// show it\n			if (tooltip.isHidden) {\n				label.show();\n			}\n\n			// update text\n			label.attr({\n				text: text\n			});\n\n			// set the stroke color of the box\n			borderColor = options.borderColor || point.color || currentSeries.color || '#606060';\n			label.attr({\n				stroke: borderColor\n			});\n\n			placedTooltipPoint = (options.positioner || tooltip.getPosition).call(\n				tooltip,\n				label.width,\n				label.height,\n				{ plotX: x, plotY: y }\n			);\n\n			// do the move\n			tooltip.move(\n				mathRound(placedTooltipPoint.x), \n				mathRound(placedTooltipPoint.y), \n				x + chart.plotLeft, \n				y + chart.plotTop\n			);\n			\n			\n			tooltip.isHidden = false;\n		}\n\n		// crosshairs\n		if (crosshairsOptions) {\n			crosshairsOptions = splat(crosshairsOptions); // [x, y]\n\n			var path,\n				i = crosshairsOptions.length,\n				attribs,\n				axis;\n\n			while (i--) {\n				axis = point.series[i ? 'yAxis' : 'xAxis'];\n				if (crosshairsOptions[i] && axis) {\n\n					path = axis.getPlotLinePath(\n						i ? pick(point.stackY, point.y) : point.x, // #814\n						1\n					);\n\n					if (tooltip.crosshairs[i]) {\n						tooltip.crosshairs[i].attr({ d: path, visibility: VISIBLE });\n					} else {\n						attribs = {\n							'stroke-width': crosshairsOptions[i].width || 1,\n							stroke: crosshairsOptions[i].color || '#C0C0C0',\n							zIndex: crosshairsOptions[i].zIndex || 2\n						};\n						if (crosshairsOptions[i].dashStyle) {\n							attribs.dashstyle = crosshairsOptions[i].dashStyle;\n						}\n						tooltip.crosshairs[i] = chart.renderer.path(path)\n							.attr(attribs)\n							.add();\n					}\n				}\n			}\n		}\n		fireEvent(chart, 'tooltipRefresh', {\n				text: text,\n				x: x + chart.plotLeft,\n				y: y + chart.plotTop,\n				borderColor: borderColor\n			});\n	}\n};\n/**\n * The mouse tracker object\n * @param {Object} chart The Chart instance\n * @param {Object} options The root options object\n */\nfunction MouseTracker(chart, options) {\n	var zoomType = useCanVG ? '' : options.chart.zoomType;\n\n	// Zoom status\n	this.zoomX = /x/.test(zoomType);\n	this.zoomY = /y/.test(zoomType);\n\n	// Store reference to options\n	this.options = options;\n\n	// Reference to the chart\n	this.chart = chart;\n\n	// The interval id\n	//this.tooltipTimeout = UNDEFINED;\n\n	// The cached x hover position\n	//this.hoverX = UNDEFINED;\n\n	// The chart position\n	//this.chartPosition = UNDEFINED;\n\n	// The selection marker element\n	//this.selectionMarker = UNDEFINED;\n\n	// False or a value > 0 if a dragging operation\n	//this.mouseDownX = UNDEFINED;\n	//this.mouseDownY = UNDEFINED;\n	this.init(chart, options.tooltip);\n}\n\nMouseTracker.prototype = {\n	/**\n	 * Add crossbrowser support for chartX and chartY\n	 * @param {Object} e The event object in standard browsers\n	 */\n	normalizeMouseEvent: function (e) {\n		var chartPosition,\n			chartX,\n			chartY,\n			ePos;\n\n		// common IE normalizing\n		e = e || win.event;\n		if (!e.target) {\n			e.target = e.srcElement;\n		}\n\n		// Framework specific normalizing (#1165)\n		e = washMouseEvent(e);\n		\n		// iOS\n		ePos = e.touches ? e.touches.item(0) : e;\n\n		// get mouse position\n		this.chartPosition = chartPosition = offset(this.chart.container);\n\n		// chartX and chartY\n		if (ePos.pageX === UNDEFINED) { // IE < 9. #886.\n			chartX = e.x;\n			chartY = e.y;\n		} else {\n			chartX = ePos.pageX - chartPosition.left;\n			chartY = ePos.pageY - chartPosition.top;\n		}\n\n		return extend(e, {\n			chartX: mathRound(chartX),\n			chartY: mathRound(chartY)\n		});\n	},\n\n	/**\n	 * Get the click position in terms of axis values.\n	 *\n	 * @param {Object} e A mouse event\n	 */\n	getMouseCoordinates: function (e) {\n		var coordinates = {\n				xAxis: [],\n				yAxis: []\n			},\n			chart = this.chart;\n\n		each(chart.axes, function (axis) {\n			var isXAxis = axis.isXAxis,\n				isHorizontal = chart.inverted ? !isXAxis : isXAxis;\n\n			coordinates[isXAxis ? 'xAxis' : 'yAxis'].push({\n				axis: axis,\n				value: axis.translate(\n					(isHorizontal ?\n						e.chartX - chart.plotLeft :\n						axis.top + axis.len - e.chartY) - axis.minPixelPadding, // #1051\n					true\n				)\n			});\n		});\n		return coordinates;\n	},\n	\n	/**\n	 * Return the index in the tooltipPoints array, corresponding to pixel position in \n	 * the plot area.\n	 */\n	getIndex: function (e) {\n		var chart = this.chart;\n		return chart.inverted ? \n			chart.plotHeight + chart.plotTop - e.chartY : \n			e.chartX - chart.plotLeft;\n	},\n\n	/**\n	 * With line type charts with a single tracker, get the point closest to the mouse\n	 */\n	onmousemove: function (e) {\n		var mouseTracker = this,\n			chart = mouseTracker.chart,\n			series = chart.series,\n			tooltip = chart.tooltip,\n			point,\n			points,\n			hoverPoint = chart.hoverPoint,\n			hoverSeries = chart.hoverSeries,\n			i,\n			j,\n			distance = chart.chartWidth,\n			index = mouseTracker.getIndex(e);\n\n		// shared tooltip\n		if (tooltip && mouseTracker.options.tooltip.shared && !(hoverSeries && hoverSeries.noSharedTooltip)) {\n			points = [];\n\n			// loop over all series and find the ones with points closest to the mouse\n			i = series.length;\n			for (j = 0; j < i; j++) {\n				if (series[j].visible &&\n						series[j].options.enableMouseTracking !== false &&\n						!series[j].noSharedTooltip && series[j].tooltipPoints && series[j].tooltipPoints.length) {\n					point = series[j].tooltipPoints[index];\n					point._dist = mathAbs(index - point[series[j].xAxis.tooltipPosName || 'plotX']);\n					distance = mathMin(distance, point._dist);\n					points.push(point);\n				}\n			}\n			// remove furthest points\n			i = points.length;\n			while (i--) {\n				if (points[i]._dist > distance) {\n					points.splice(i, 1);\n				}\n			}\n			// refresh the tooltip if necessary\n			if (points.length && (points[0].plotX !== mouseTracker.hoverX)) {\n				tooltip.refresh(points, e);\n				mouseTracker.hoverX = points[0].plotX;\n			}\n		}\n\n		// separate tooltip and general mouse events\n		if (hoverSeries && hoverSeries.tracker) { // only use for line-type series with common tracker\n\n			// get the point\n			point = hoverSeries.tooltipPoints[index];\n\n			// a new point is hovered, refresh the tooltip\n			if (point && point !== hoverPoint) {\n\n				// trigger the events\n				point.onMouseOver();\n\n			}\n		}\n	},\n\n\n\n	/**\n	 * Reset the tracking by hiding the tooltip, the hover series state and the hover point\n	 * \n	 * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible\n	 */\n	resetTracker: function (allowMove) {\n		var mouseTracker = this,\n			chart = mouseTracker.chart,\n			hoverSeries = chart.hoverSeries,\n			hoverPoint = chart.hoverPoint,\n			tooltip = chart.tooltip,\n			tooltipPoints = tooltip && tooltip.shared ? chart.hoverPoints : hoverPoint;\n			\n		// Narrow in allowMove\n		allowMove = allowMove && tooltip && tooltipPoints;\n			\n		// Check if the points have moved outside the plot area, #1003\n		if (allowMove && splat(tooltipPoints)[0].plotX === UNDEFINED) {\n			allowMove = false;\n		}	\n\n		// Just move the tooltip, #349\n		if (allowMove) {\n			tooltip.refresh(tooltipPoints);\n\n		// Full reset\n		} else {\n\n			if (hoverPoint) {\n				hoverPoint.onMouseOut();\n			}\n\n			if (hoverSeries) {\n				hoverSeries.onMouseOut();\n			}\n\n			if (tooltip) {\n				tooltip.hide();\n				tooltip.hideCrosshairs();\n			}\n\n			mouseTracker.hoverX = null;\n\n		}\n	},\n\n	/**\n	 * Set the JS events on the container element\n	 */\n	setDOMEvents: function () {\n		var lastWasOutsidePlot = true,\n			mouseTracker = this,\n			chart = mouseTracker.chart,\n			container = chart.container,\n			hasDragged,\n			zoomHor = (mouseTracker.zoomX && !chart.inverted) || (mouseTracker.zoomY && chart.inverted),\n			zoomVert = (mouseTracker.zoomY && !chart.inverted) || (mouseTracker.zoomX && chart.inverted);\n\n		/**\n		 * Mouse up or outside the plot area\n		 */\n		function drop() {\n			if (mouseTracker.selectionMarker) {\n				var selectionData = {\n						xAxis: [],\n						yAxis: []\n					},\n					selectionBox = mouseTracker.selectionMarker.getBBox(),\n					selectionLeft = selectionBox.x - chart.plotLeft,\n					selectionTop = selectionBox.y - chart.plotTop,\n					runZoom;\n\n				// a selection has been made\n				if (hasDragged) {\n\n					// record each axis' min and max\n					each(chart.axes, function (axis) {\n						if (axis.options.zoomEnabled !== false) {\n							var isXAxis = axis.isXAxis,\n								isHorizontal = chart.inverted ? !isXAxis : isXAxis,\n								selectionMin = axis.translate(\n									isHorizontal ?\n										selectionLeft :\n										chart.plotHeight - selectionTop - selectionBox.height,\n									true,\n									0,\n									0,\n									1\n								),\n								selectionMax = axis.translate(\n									(isHorizontal ?\n											selectionLeft + selectionBox.width :\n											chart.plotHeight - selectionTop) -  \n										2 * axis.minPixelPadding, // #875\n									true,\n									0,\n									0,\n									1\n								);\n\n								if (!isNaN(selectionMin) && !isNaN(selectionMax)) { // #859\n									selectionData[isXAxis ? 'xAxis' : 'yAxis'].push({\n										axis: axis,\n										min: mathMin(selectionMin, selectionMax), // for reversed axes,\n										max: mathMax(selectionMin, selectionMax)\n									});\n									runZoom = true;\n								}\n						}\n					});\n					if (runZoom) {\n						fireEvent(chart, 'selection', selectionData, function (args) { chart.zoom(args); });\n					}\n\n				}\n				mouseTracker.selectionMarker = mouseTracker.selectionMarker.destroy();\n			}\n\n			if (chart) { // it may be destroyed on mouse up - #877\n				css(container, { cursor: 'auto' });\n				chart.cancelClick = hasDragged; // #370\n				chart.mouseIsDown = hasDragged = false;\n			}\n\n			removeEvent(doc, 'mouseup', drop);\n			if (hasTouch) {\n				removeEvent(doc, 'touchend', drop);\n			}\n		}\n\n		/**\n		 * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.\n		 */\n		mouseTracker.hideTooltipOnMouseMove = function (e) {\n\n			// Get e.pageX and e.pageY back in MooTools\n			e = washMouseEvent(e);\n\n			// If we're outside, hide the tooltip\n			if (mouseTracker.chartPosition && chart.hoverSeries && chart.hoverSeries.isCartesian &&\n				!chart.isInsidePlot(e.pageX - mouseTracker.chartPosition.left - chart.plotLeft,\n				e.pageY - mouseTracker.chartPosition.top - chart.plotTop)) {\n					mouseTracker.resetTracker();\n			}\n		};\n\n		/**\n		 * When mouse leaves the container, hide the tooltip.\n		 */\n		mouseTracker.hideTooltipOnMouseLeave = function () {\n			mouseTracker.resetTracker();\n			mouseTracker.chartPosition = null; // also reset the chart position, used in #149 fix\n		};\n\n\n		/*\n		 * Record the starting position of a dragoperation\n		 */\n		container.onmousedown = function (e) {\n			e = mouseTracker.normalizeMouseEvent(e);\n\n			// issue #295, dragging not always working in Firefox\n			if (e.type.indexOf('touch') === -1 && e.preventDefault) {\n				e.preventDefault();\n			}\n\n			// record the start position\n			chart.mouseIsDown = true;\n			chart.cancelClick = false;\n			chart.mouseDownX = mouseTracker.mouseDownX = e.chartX;\n			mouseTracker.mouseDownY = e.chartY;\n\n			addEvent(doc, 'mouseup', drop);\n			if (hasTouch) {\n				addEvent(doc, 'touchend', drop);\n			}\n		};\n\n		// The mousemove, touchmove and touchstart event handler\n		var mouseMove = function (e) {\n			\n			// let the system handle multitouch operations like two finger scroll\n			// and pinching\n			if (e && e.touches && e.touches.length > 1) {\n				return;\n			}\n\n			// normalize\n			e = mouseTracker.normalizeMouseEvent(e);\n\n			var type = e.type,\n				chartX = e.chartX,\n				chartY = e.chartY,\n				isOutsidePlot = !chart.isInsidePlot(chartX - chart.plotLeft, chartY - chart.plotTop);\n				\n			\n			if (type.indexOf('touch') === -1) {  // not for touch actions\n				e.returnValue = false;\n			}\n\n			// on touch devices, only trigger click if a handler is defined\n			if (type === 'touchstart') {\n				if (attr(e.target, 'isTracker')) {\n					if (!chart.runTrackerClick) {\n						e.preventDefault();\n					}\n				} else if (!chart.runChartClick && !isOutsidePlot) {\n					e.preventDefault();\n				}\n			}\n\n			// cancel on mouse outside\n			if (isOutsidePlot) {\n\n				/*if (!lastWasOutsidePlot) {\n					// reset the tracker\n					resetTracker();\n				}*/\n\n				// drop the selection if any and reset mouseIsDown and hasDragged\n				//drop();\n				if (chartX < chart.plotLeft) {\n					chartX = chart.plotLeft;\n				} else if (chartX > chart.plotLeft + chart.plotWidth) {\n					chartX = chart.plotLeft + chart.plotWidth;\n				}\n\n				if (chartY < chart.plotTop) {\n					chartY = chart.plotTop;\n				} else if (chartY > chart.plotTop + chart.plotHeight) {\n					chartY = chart.plotTop + chart.plotHeight;\n				}\n			}\n\n			if (chart.mouseIsDown && type !== 'touchstart') { // make selection\n\n				// determine if the mouse has moved more than 10px\n				hasDragged = Math.sqrt(\n					Math.pow(mouseTracker.mouseDownX - chartX, 2) +\n					Math.pow(mouseTracker.mouseDownY - chartY, 2)\n				);\n				if (hasDragged > 10) {\n					var clickedInside = chart.isInsidePlot(mouseTracker.mouseDownX - chart.plotLeft, mouseTracker.mouseDownY - chart.plotTop);\n\n					// make a selection\n					if (chart.hasCartesianSeries && (mouseTracker.zoomX || mouseTracker.zoomY) && clickedInside) {\n						if (!mouseTracker.selectionMarker) {\n							mouseTracker.selectionMarker = chart.renderer.rect(\n								chart.plotLeft,\n								chart.plotTop,\n								zoomHor ? 1 : chart.plotWidth,\n								zoomVert ? 1 : chart.plotHeight,\n								0\n							)\n							.attr({\n								fill: mouseTracker.options.chart.selectionMarkerFill || 'rgba(69,114,167,0.25)',\n								zIndex: 7\n							})\n							.add();\n						}\n					}\n\n					// adjust the width of the selection marker\n					if (mouseTracker.selectionMarker && zoomHor) {\n						var xSize = chartX - mouseTracker.mouseDownX;\n						mouseTracker.selectionMarker.attr({\n							width: mathAbs(xSize),\n							x: (xSize > 0 ? 0 : xSize) + mouseTracker.mouseDownX\n						});\n					}\n					// adjust the height of the selection m");
        builder.append("arker\n					if (mouseTracker.selectionMarker && zoomVert) {\n						var ySize = chartY - mouseTracker.mouseDownY;\n						mouseTracker.selectionMarker.attr({\n							height: mathAbs(ySize),\n							y: (ySize > 0 ? 0 : ySize) + mouseTracker.mouseDownY\n						});\n					}\n\n					// panning\n					if (clickedInside && !mouseTracker.selectionMarker && mouseTracker.options.chart.panning) {\n						chart.pan(chartX);\n					}\n				}\n\n			} \n			\n			// Show the tooltip and run mouse over events (#977)			\n			if (!isOutsidePlot) {\n				mouseTracker.onmousemove(e);\n			}\n\n			lastWasOutsidePlot = isOutsidePlot;\n\n			// when outside plot, allow touch-drag by returning true\n			return isOutsidePlot || !chart.hasCartesianSeries;\n		};\n\n		// When the mouse enters the container, run mouseMove\n		if (!/Android 4\\.0/.test(userAgent)) { // This hurts. Best effort for #1385.\n			container.onmousemove = mouseMove;\n		}\n\n		/*\n		 * When the mouse leaves the container, hide the tracking (tooltip).\n		 */\n		addEvent(container, 'mouseleave', mouseTracker.hideTooltipOnMouseLeave);\n\n		// issue #149 workaround\n		// The mouseleave event above does not always fire. Whenever the mouse is moving\n		// outside the plotarea, hide the tooltip\n		if (!hasTouch) { // #1385\n			addEvent(doc, 'mousemove', mouseTracker.hideTooltipOnMouseMove);\n		}\n\n		container.ontouchstart = function (e) {\n			// For touch devices, use touchmove to zoom\n			if (mouseTracker.zoomX || mouseTracker.zoomY) {\n				container.onmousedown(e);\n			}\n			// Show tooltip and prevent the lower mouse pseudo event\n			mouseMove(e);\n		};\n\n		/*\n		 * Allow dragging the finger over the chart to read the values on touch\n		 * devices\n		 */\n		container.ontouchmove = mouseMove;\n\n		/*\n		 * Allow dragging the finger over the chart to read the values on touch\n		 * devices\n		 */\n		container.ontouchend = function () {\n			if (hasDragged) {\n				mouseTracker.resetTracker();\n			}\n		};\n\n\n		// MooTools 1.2.3 doesn't fire this in IE when using addEvent\n		container.onclick = function (e) {\n			var hoverPoint = chart.hoverPoint, \n				plotX,\n				plotY;\n			e = mouseTracker.normalizeMouseEvent(e);\n\n			e.cancelBubble = true; // IE specific\n\n\n			if (!chart.cancelClick) {\n				// Detect clicks on trackers or tracker groups, #783\n				if (hoverPoint && (attr(e.target, 'isTracker') || attr(e.target.parentNode, 'isTracker'))) {\n					plotX = hoverPoint.plotX;\n					plotY = hoverPoint.plotY;\n\n					// add page position info\n					extend(hoverPoint, {\n						pageX: mouseTracker.chartPosition.left + chart.plotLeft +\n							(chart.inverted ? chart.plotWidth - plotY : plotX),\n						pageY: mouseTracker.chartPosition.top + chart.plotTop +\n							(chart.inverted ? chart.plotHeight - plotX : plotY)\n					});\n\n					// the series click event\n					fireEvent(hoverPoint.series, 'click', extend(e, {\n						point: hoverPoint\n					}));\n\n					// the point click event\n					hoverPoint.firePointEvent('click', e);\n\n				} else {\n					extend(e, mouseTracker.getMouseCoordinates(e));\n\n					// fire a click event in the chart\n					if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n						fireEvent(chart, 'click', e);\n					}\n				}\n\n\n			}\n		};\n\n	},\n\n	/**\n	 * Destroys the MouseTracker object and disconnects DOM events.\n	 */\n	destroy: function () {\n		var mouseTracker = this,\n			chart = mouseTracker.chart,\n			container = chart.container;\n\n		// Destroy the tracker group element\n		if (chart.trackerGroup) {\n			chart.trackerGroup = chart.trackerGroup.destroy();\n		}\n\n		removeEvent(container, 'mouseleave', mouseTracker.hideTooltipOnMouseLeave);\n		removeEvent(doc, 'mousemove', mouseTracker.hideTooltipOnMouseMove);\n		container.onclick = container.onmousedown = container.onmousemove = container.ontouchstart = container.ontouchend = container.ontouchmove = null;\n\n		// memory and CPU leak\n		clearInterval(this.tooltipTimeout);\n	},\n\n	// Run MouseTracker\n	init: function (chart, options) {\n		if (!chart.trackerGroup) {\n			chart.trackerGroup = chart.renderer.g('tracker')\n				.attr({ zIndex: 9 })\n				.add();\n		}\n\n		if (options.enabled) {\n			chart.tooltip = new Tooltip(chart, options);\n		}\n\n		this.setDOMEvents();\n	}\n};\n/**\n * The overview of the chart's series\n */\nfunction Legend(chart) {\n\n	this.init(chart);\n}\n\nLegend.prototype = {\n	\n	/**\n	 * Initialize the legend\n	 */\n	init: function (chart) {\n		var legend = this,\n			options = legend.options = chart.options.legend;\n	\n		if (!options.enabled) {\n			return;\n		}\n	\n		var //style = options.style || {}, // deprecated\n			itemStyle = options.itemStyle,\n			padding = pick(options.padding, 8),\n			itemMarginTop = options.itemMarginTop || 0;\n	\n		legend.baseline = pInt(itemStyle.fontSize) + 3 + itemMarginTop; // used in Series prototype\n		legend.itemStyle = itemStyle;\n		legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);\n		legend.itemMarginTop = itemMarginTop;\n		legend.padding = padding;\n		legend.initialItemX = padding;\n		legend.initialItemY = padding - 5; // 5 is the number of pixels above the text\n		legend.maxItemWidth = 0;\n		legend.chart = chart;\n		//legend.allItems = UNDEFINED;\n		//legend.legendWidth = UNDEFINED;\n		//legend.legendHeight = UNDEFINED;\n		//legend.offsetWidth = UNDEFINED;\n		legend.itemHeight = 0;\n		legend.lastLineHeight = 0;\n		//legend.itemX = UNDEFINED;\n		//legend.itemY = UNDEFINED;\n		//legend.lastItemY = UNDEFINED;\n	\n		// Elements\n		//legend.group = UNDEFINED;\n		//legend.box = UNDEFINED;\n\n		// run legend\n		legend.render();\n\n		// move checkboxes\n		addEvent(legend.chart, 'endResize', function () { legend.positionCheckboxes(); });\n\n/*		// expose\n		return {\n			colorizeItem: colorizeItem,\n			destroyItem: destroyItem,\n			render: render,\n			destroy: destroy,\n			getLegendWidth: getLegendWidth,\n			getLegendHeight: getLegendHeight\n		};*/\n	},\n\n	/**\n	 * Set the colors for the legend item\n	 * @param {Object} item A Series or Point instance\n	 * @param {Object} visible Dimmed or colored\n	 */\n	colorizeItem: function (item, visible) {\n		var legend = this,\n			options = legend.options,\n			legendItem = item.legendItem,\n			legendLine = item.legendLine,\n			legendSymbol = item.legendSymbol,\n			hiddenColor = legend.itemHiddenStyle.color,\n			textColor = visible ? options.itemStyle.color : hiddenColor,\n			symbolColor = visible ? item.color : hiddenColor,\n			markerOptions = item.options && item.options.marker,\n			symbolAttr = {\n				stroke: symbolColor,\n				fill: symbolColor\n			},\n			key,\n			val;\n\n		\n		if (legendItem) {\n			legendItem.css({ fill: textColor });\n		}\n		if (legendLine) {\n			legendLine.attr({ stroke: symbolColor });\n		}\n		\n		if (legendSymbol) {\n			\n			// Apply marker options\n			if (markerOptions) {\n				markerOptions = item.convertAttribs(markerOptions);\n				for (key in markerOptions) {\n					val = markerOptions[key];\n					if (val !== UNDEFINED) {\n						symbolAttr[key] = val;\n					}\n				}\n			}\n\n			legendSymbol.attr(symbolAttr);\n		}\n	},\n\n	/**\n	 * Position the legend item\n	 * @param {Object} item A Series or Point instance\n	 */\n	positionItem: function (item) {\n		var legend = this,\n			options = legend.options,\n			symbolPadding = options.symbolPadding,\n			ltr = !options.rtl,\n			legendItemPos = item._legendItemPos,\n			itemX = legendItemPos[0],\n			itemY = legendItemPos[1],\n			checkbox = item.checkbox;\n\n		if (item.legendGroup) {\n			item.legendGroup.translate(\n				ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,\n				itemY\n			);\n		}\n\n		if (checkbox) {\n			checkbox.x = itemX;\n			checkbox.y = itemY;\n		}\n	},\n\n	/**\n	 * Destroy a single legend item\n	 * @param {Object} item The series or point\n	 */\n	destroyItem: function (item) {\n		var checkbox = item.checkbox;\n\n		// destroy SVG elements\n		each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {\n			if (item[key]) {\n				item[key].destroy();\n			}\n		});\n\n		if (checkbox) {\n			discardElement(item.checkbox);\n		}\n	},\n\n	/**\n	 * Destroys the legend.\n	 */\n	destroy: function () {\n		var legend = this,\n			legendGroup = legend.group,\n			box = legend.box;\n\n		if (box) {\n			legend.box = box.destroy();\n		}\n\n		if (legendGroup) {\n			legend.group = legendGroup.destroy();\n		}\n	},\n\n	/**\n	 * Position the checkboxes after the width is determined\n	 */\n	positionCheckboxes: function (scrollOffset) {\n		var alignAttr = this.group.alignAttr,\n			translateY,\n			clipHeight = this.clipHeight || this.legendHeight;\n\n		if (alignAttr) {\n			translateY = alignAttr.translateY;\n			each(this.allItems, function (item) {\n				var checkbox = item.checkbox,\n					top;\n				\n				if (checkbox) {\n					top = (translateY + checkbox.y + (scrollOffset || 0) + 3);\n					css(checkbox, {\n						left: (alignAttr.translateX + item.legendItemWidth + checkbox.x - 20) + PX,\n						top: top + PX,\n						display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE\n					});\n				}\n			});\n		}\n	},\n\n	/**\n	 * Render a single specific legend item\n	 * @param {Object} item A series or point\n	 */\n	renderItem: function (item) {\n		var legend = this,\n			chart = legend.chart,\n			renderer = chart.renderer,\n			options = legend.options,\n			horizontal = options.layout === 'horizontal',\n			symbolWidth = options.symbolWidth,\n			symbolPadding = options.symbolPadding,\n			itemStyle = legend.itemStyle,\n			itemHiddenStyle = legend.itemHiddenStyle,\n			padding = legend.padding,\n			ltr = !options.rtl,\n			itemHeight,\n			widthOption = options.width,\n			itemMarginBottom = options.itemMarginBottom || 0,\n			itemMarginTop = legend.itemMarginTop,\n			initialItemX = legend.initialItemX,\n			bBox,\n			itemWidth,\n			li = item.legendItem,\n			series = item.series || item,\n			itemOptions = series.options,\n			showCheckbox = itemOptions.showCheckbox,\n			useHTML = options.useHTML;\n\n		if (!li) { // generate it once, later move it\n\n			// Generate the group box\n			// A group to hold the symbol and text. Text is to be appended in Legend class.\n			item.legendGroup = renderer.g('legend-item')\n				.attr({ zIndex: 1 })\n				.add(legend.scrollGroup);\n\n			// Draw the legend symbol inside the group box\n			series.drawLegendSymbol(legend, item);\n\n			// Generate the list item text and add it to the group\n			item.legendItem = li = renderer.text(\n					options.labelFormatter.call(item),\n					ltr ? symbolWidth + symbolPadding : -symbolPadding,\n					legend.baseline,\n					useHTML\n				)\n				.css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)\n				.attr({\n					align: ltr ? 'left' : 'right',\n					zIndex: 2\n				})\n				.add(item.legendGroup);\n\n			// Set the events on the item group, or in case of useHTML, the item itself (#1249)\n			(useHTML ? li : item.legendGroup).on('mouseover', function () {\n					item.setState(HOVER_STATE);\n					li.css(legend.options.itemHoverStyle);\n				})\n				.on('mouseout', function () {\n					li.css(item.visible ? itemStyle : itemHiddenStyle);\n					item.setState();\n				})\n				.on('click', function (event) {\n					var strLegendItemClick = 'legendItemClick',\n						fnLegendItemClick = function () {\n							item.setVisible();\n						};\n						\n					// Pass over the click/touch event. #4.\n					event = {\n						browserEvent: event\n					};\n\n					// click the name or symbol\n					if (item.firePointEvent) { // point\n						item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n					} else {\n						fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n					}\n				});\n\n			// Colorize the items\n			legend.colorizeItem(item, item.visible);\n\n			// add the HTML checkbox on top\n			if (itemOptions && showCheckbox) {\n				item.checkbox = createElement('input', {\n					type: 'checkbox',\n					checked: item.selected,\n					defaultChecked: item.selected // required by IE7\n				}, options.itemCheckboxStyle, chart.container);\n\n				addEvent(item.checkbox, 'click', function (event) {\n					var target = event.target;\n					fireEvent(item, 'checkboxClick', {\n							checked: target.checked\n						},\n						function () {\n							item.select();\n						}\n					);\n				});\n			}\n		}\n\n		// calculate the positions for the next line\n		bBox = li.getBBox();\n\n		itemWidth = item.legendItemWidth =\n			options.itemWidth || symbolWidth + symbolPadding + bBox.width + padding +\n			(showCheckbox ? 20 : 0);\n		legend.itemHeight = itemHeight = bBox.height;\n\n		// if the item exceeds the width, start a new line\n		if (horizontal && legend.itemX - initialItemX + itemWidth >\n				(widthOption || (chart.chartWidth - 2 * padding - initialItemX))) {\n			legend.itemX = initialItemX;\n			legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;\n			legend.lastLineHeight = 0; // reset for next line\n		}\n\n		// If the item exceeds the height, start a new column\n		/*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {\n			legend.itemY = legend.initialItemY;\n			legend.itemX += legend.maxItemWidth;\n			legend.maxItemWidth = 0;\n		}*/\n\n		// Set the edge positions\n		legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);\n		legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;\n		legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915\n\n		// cache the position of the newly generated or reordered items\n		item._legendItemPos = [legend.itemX, legend.itemY];\n\n		// advance\n		if (horizontal) {\n			legend.itemX += itemWidth;\n\n		} else {\n			legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n			legend.lastLineHeight = itemHeight;\n		}\n\n		// the width of the widest item\n		legend.offsetWidth = widthOption || mathMax(\n			horizontal ? legend.itemX - initialItemX : itemWidth,\n			legend.offsetWidth\n		);\n	},\n\n	/**\n	 * Render the legend. This method can be called both before and after\n	 * chart.render. If called after, it will only rearrange items instead\n	 * of creating new ones.\n	 */\n	render: function () {\n		var legend = this,\n			chart = legend.chart,\n			renderer = chart.renderer,\n			legendGroup = legend.group,\n			allItems,\n			display,\n			legendWidth,\n			legendHeight,\n			box = legend.box,\n			options = legend.options,\n			padding = legend.padding,\n			legendBorderWidth = options.borderWidth,\n			legendBackgroundColor = options.backgroundColor;\n\n		legend.itemX = legend.initialItemX;\n		legend.itemY = legend.initialItemY;\n		legend.offsetWidth = 0;\n		legend.lastItemY = 0;\n\n		if (!legendGroup) {\n			legend.group = legendGroup = renderer.g('legend')\n				// #414, #759. Trackers will be drawn above the legend, but we have \n				// to sacrifice that because tooltips need to be above the legend\n				// and trackers above tooltips\n				.attr({ zIndex: 7 }) \n				.add();\n			legend.contentGroup = renderer.g()\n				.attr({ zIndex: 1 }) // above background\n				.add(legendGroup);\n			legend.scrollGroup = renderer.g()\n				.add(legend.contentGroup);\n			legend.clipRect = renderer.clipRect(0, 0, 9999, chart.chartHeight);\n			legend.contentGroup.clip(legend.clipRect);\n		}\n\n		// add each series or point\n		allItems = [];\n		each(chart.series, function (serie) {\n			var seriesOptions = serie.options;\n\n			if (!seriesOptions.showInLegend) {\n				return;\n			}\n\n			// use points or series for the legend item depending on legendType\n			allItems = allItems.concat(\n					serie.legendItems ||\n					(seriesOptions.legendType === 'point' ?\n							serie.data :\n							serie)\n			);\n		});\n\n		// sort by legendIndex\n		stableSort(allItems, function (a, b) {\n			return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);\n		});\n\n		// reversed legend\n		if (options.reversed) {\n			allItems.reverse();\n		}\n\n		legend.allItems = allItems;\n		legend.display = display = !!allItems.length;\n\n		// render the items\n		each(allItems, function (item) {\n			legend.renderItem(item); \n		});\n\n		// Draw the border\n		legendWidth = options.width || legend.offsetWidth;\n		legendHeight = legend.lastItemY + legend.lastLineHeight;\n		\n		\n		legendHeight = legend.handleOverflow(legendHeight);\n\n		if (legendBorderWidth || legendBackgroundColor) {\n			legendWidth += padding;\n			legendHeight += padding;\n\n			if (!box) {\n				legend.box = box = renderer.rect(\n					0,\n					0,\n					legendWidth,\n					legendHeight,\n					options.borderRadius,\n					legendBorderWidth || 0\n				).attr({\n					stroke: options.borderColor,\n					'stroke-width': legendBorderWidth || 0,\n					fill: legendBackgroundColor || NONE\n				})\n				.add(legendGroup)\n				.shadow(options.shadow);\n				box.isNew = true;\n\n			} else if (legendWidth > 0 && legendHeight > 0) {\n				box[box.isNew ? 'attr' : 'animate'](\n					box.crisp(null, null, null, le");
        builder.append("gendWidth, legendHeight)\n				);\n				box.isNew = false;\n			}\n\n			// hide the border if no items\n			box[display ? 'show' : 'hide']();\n		}\n		\n		legend.legendWidth = legendWidth;\n		legend.legendHeight = legendHeight;\n\n		// Now that the legend width and height are established, put the items in the \n		// final position\n		each(allItems, function (item) {\n			legend.positionItem(item);\n		});\n\n		// 1.x compatibility: positioning based on style\n		/*var props = ['left', 'right', 'top', 'bottom'],\n			prop,\n			i = 4;\n		while (i--) {\n			prop = props[i];\n			if (options.style[prop] && options.style[prop] !== 'auto') {\n				options[i < 2 ? 'align' : 'verticalAlign'] = prop;\n				options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);\n			}\n		}*/\n\n		if (display) {\n			legendGroup.align(extend({\n				width: legendWidth,\n				height: legendHeight\n			}, options), true, chart.spacingBox);\n		}\n\n		if (!chart.isResizing) {\n			this.positionCheckboxes();\n		}\n	},\n	\n	/**\n	 * Set up the overflow handling by adding navigation with up and down arrows below the\n	 * legend.\n	 */\n	handleOverflow: function (legendHeight) {\n		var legend = this,\n			chart = this.chart,\n			renderer = chart.renderer,\n			pageCount,\n			options = this.options,\n			optionsY = options.y,\n			alignTop = options.verticalAlign === 'top',\n			spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,\n			maxHeight = options.maxHeight,\n			clipHeight,\n			clipRect = this.clipRect,\n			navOptions = options.navigation,\n			animation = pick(navOptions.animation, true),\n			arrowSize = navOptions.arrowSize || 12,\n			nav = this.nav;\n			\n		// Adjust the height\n		if (options.layout === 'horizontal') {\n			spaceHeight /= 2;\n		}\n		if (maxHeight) {\n			spaceHeight = mathMin(spaceHeight, maxHeight);\n		}\n		\n		// Reset the legend height and adjust the clipping rectangle\n		if (legendHeight > spaceHeight) {\n			\n			this.clipHeight = clipHeight = spaceHeight - 20;\n			this.pageCount = pageCount = mathCeil(legendHeight / clipHeight);\n			this.currentPage = pick(this.currentPage, 1);\n			this.fullHeight = legendHeight;\n			\n			clipRect.attr({\n				height: clipHeight\n			});\n			\n			// Add navigation elements\n			if (!nav) {\n				this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);\n				this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)\n					.on('click', function () {\n						legend.scroll(-1, animation);\n					})\n					.add(nav);\n				this.pager = renderer.text('', 15, 10)\n					.css(navOptions.style)\n					.add(nav);\n				this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)\n					.on('click', function () {\n						legend.scroll(1, animation);\n					})\n					.add(nav);\n			}\n			\n			// Set initial position\n			legend.scroll(0);\n			\n			legendHeight = spaceHeight;\n			\n		} else if (nav) {\n			clipRect.attr({\n				height: chart.chartHeight\n			});\n			nav.hide();\n			this.scrollGroup.attr({\n				translateY: 1\n			});\n			this.clipHeight = 0; // #1379\n		}\n		\n		return legendHeight;\n	},\n	\n	/**\n	 * Scroll the legend by a number of pages\n	 * @param {Object} scrollBy\n	 * @param {Object} animation\n	 */\n	scroll: function (scrollBy, animation) {\n		var pageCount = this.pageCount,\n			currentPage = this.currentPage + scrollBy,\n			clipHeight = this.clipHeight,\n			navOptions = this.options.navigation,\n			activeColor = navOptions.activeColor,\n			inactiveColor = navOptions.inactiveColor,\n			pager = this.pager,\n			padding = this.padding,\n			scrollOffset;\n		\n		// When resizing while looking at the last page\n		if (currentPage > pageCount) {\n			currentPage = pageCount;\n		}\n		\n		if (currentPage > 0) {\n			\n			if (animation !== UNDEFINED) {\n				setAnimation(animation, this.chart);\n			}\n			\n			this.nav.attr({\n				translateX: padding,\n				translateY: clipHeight + 7,\n				visibility: VISIBLE\n			});\n			this.up.attr({\n					fill: currentPage === 1 ? inactiveColor : activeColor\n				})\n				.css({\n					cursor: currentPage === 1 ? 'default' : 'pointer'\n				});\n			pager.attr({\n				text: currentPage + '/' + this.pageCount\n			});\n			this.down.attr({\n					x: 18 + this.pager.getBBox().width, // adjust to text width\n					fill: currentPage === pageCount ? inactiveColor : activeColor\n				})\n				.css({\n					cursor: currentPage === pageCount ? 'default' : 'pointer'\n				});\n			\n			scrollOffset = -mathMin(clipHeight * (currentPage - 1), this.fullHeight - clipHeight + padding) + 1;\n			this.scrollGroup.animate({\n				translateY: scrollOffset\n			});\n			pager.attr({\n				text: currentPage + '/' + pageCount\n			});\n			\n			\n			this.currentPage = currentPage;\n			this.positionCheckboxes(scrollOffset);\n		}\n			\n	}\n	\n};\n\n\n/**\n * The chart class\n * @param {Object} options\n * @param {Function} callback Function to run when the chart has loaded\n */\nfunction Chart() {\n	this.init.apply(this, arguments);\n}\n\nChart.prototype = {\n\n	/**\n	 * Initialize the chart\n	 */\n	init: function (userOptions, callback) {\n\n		// Handle regular options\n		var options,\n			seriesOptions = userOptions.series; // skip merging data points to increase performance\n\n		userOptions.series = null;\n		options = merge(defaultOptions, userOptions); // do the merge\n		options.series = userOptions.series = seriesOptions; // set back the series data\n\n		var optionsChart = options.chart,\n			optionsMargin = optionsChart.margin,\n			margin = isObject(optionsMargin) ?\n				optionsMargin :\n				[optionsMargin, optionsMargin, optionsMargin, optionsMargin];\n\n		this.optionsMarginTop = pick(optionsChart.marginTop, margin[0]);\n		this.optionsMarginRight = pick(optionsChart.marginRight, margin[1]);\n		this.optionsMarginBottom = pick(optionsChart.marginBottom, margin[2]);\n		this.optionsMarginLeft = pick(optionsChart.marginLeft, margin[3]);\n\n		var chartEvents = optionsChart.events;\n\n		this.runChartClick = chartEvents && !!chartEvents.click;\n		this.callback = callback;\n		this.isResizing = 0;\n		this.options = options;\n		//chartTitleOptions = UNDEFINED;\n		//chartSubtitleOptions = UNDEFINED;\n\n		this.axes = [];\n		this.series = [];\n		this.hasCartesianSeries = optionsChart.showAxes;\n		//this.axisOffset = UNDEFINED;\n		//this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes\n		//this.inverted = UNDEFINED;\n		//this.loadingShown = UNDEFINED;\n		//this.container = UNDEFINED;\n		//this.chartWidth = UNDEFINED;\n		//this.chartHeight = UNDEFINED;\n		//this.marginRight = UNDEFINED;\n		//this.marginBottom = UNDEFINED;\n		//this.containerWidth = UNDEFINED;\n		//this.containerHeight = UNDEFINED;\n		//this.oldChartWidth = UNDEFINED;\n		//this.oldChartHeight = UNDEFINED;\n\n		//this.renderTo = UNDEFINED;\n		//this.renderToClone = UNDEFINED;\n		//this.tracker = UNDEFINED;\n\n		//this.spacingBox = UNDEFINED\n\n		//this.legend = UNDEFINED;\n\n		// Elements\n		//this.chartBackground = UNDEFINED;\n		//this.plotBackground = UNDEFINED;\n		//this.plotBGImage = UNDEFINED;\n		//this.plotBorder = UNDEFINED;\n		//this.loadingDiv = UNDEFINED;\n		//this.loadingSpan = UNDEFINED;\n\n		var chart = this,\n			eventType;\n\n		// Add the chart to the global lookup\n		chart.index = charts.length;\n		charts.push(chart);\n\n		// Set up auto resize\n		if (optionsChart.reflow !== false) {\n			addEvent(chart, 'load', chart.initReflow);\n		}\n\n		// Chart event handlers\n		if (chartEvents) {\n			for (eventType in chartEvents) {\n				addEvent(chart, eventType, chartEvents[eventType]);\n			}\n		}\n\n		chart.xAxis = [];\n		chart.yAxis = [];\n\n		// Expose methods and variables\n		chart.animation = useCanVG ? false : pick(optionsChart.animation, true);\n		chart.pointCount = 0;\n		chart.counters = new ChartCounters();\n\n		chart.firstRender();\n	},\n\n	/**\n	 * Initialize an individual series, called internally before render time\n	 */\n	initSeries: function (options) {\n		var chart = this,\n			optionsChart = chart.options.chart,\n			type = options.type || optionsChart.type || optionsChart.defaultSeriesType,\n			series = new seriesTypes[type]();\n\n		series.init(this, options);\n		return series;\n	},\n\n	/**\n	 * Add a series dynamically after  time\n	 *\n	 * @param {Object} options The config options\n	 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.\n	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n	 *    configuration\n	 *\n	 * @return {Object} series The newly created series object\n	 */\n	addSeries: function (options, redraw, animation) {\n		var series,\n			chart = this;\n\n		if (options) {\n			setAnimation(animation, chart);\n			redraw = pick(redraw, true); // defaults to true\n\n			fireEvent(chart, 'addSeries', { options: options }, function () {\n				series = chart.initSeries(options);\n				\n				chart.isDirtyLegend = true; // the series array is out of sync with the display\n				if (redraw) {\n					chart.redraw();\n				}\n			});\n		}\n\n		return series;\n	},\n\n	/**\n	 * Check whether a given point is within the plot area\n	 *\n	 * @param {Number} plotX Pixel x relative to the plot area\n	 * @param {Number} plotY Pixel y relative to the plot area\n	 * @param {Boolean} inverted Whether the chart is inverted\n	 */\n	isInsidePlot: function (plotX, plotY, inverted) {\n		var x = inverted ? plotY : plotX,\n			y = inverted ? plotX : plotY;\n			\n		return x >= 0 &&\n			x <= this.plotWidth &&\n			y >= 0 &&\n			y <= this.plotHeight;\n	},\n\n	/**\n	 * Adjust all axes tick amounts\n	 */\n	adjustTickAmounts: function () {\n		if (this.options.chart.alignTicks !== false) {\n			each(this.axes, function (axis) {\n				axis.adjustTickAmount();\n			});\n		}\n		this.maxTicks = null;\n	},\n\n	/**\n	 * Redraw legend, axes or series based on updated data\n	 *\n	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n	 *    configuration\n	 */\n	redraw: function (animation) {\n		var chart = this,\n			axes = chart.axes,\n			series = chart.series,\n			tracker = chart.tracker,\n			legend = chart.legend,\n			redrawLegend = chart.isDirtyLegend,\n			hasStackedSeries,\n			isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?\n			seriesLength = series.length,\n			i = seriesLength,\n			serie,\n			renderer = chart.renderer,\n			isHiddenChart = renderer.isHidden(),\n			afterRedraw = [];\n			\n		setAnimation(animation, chart);\n		\n		if (isHiddenChart) {\n			chart.cloneRenderTo();\n		}\n\n		// link stacked series\n		while (i--) {\n			serie = series[i];\n			if (serie.isDirty && serie.options.stacking) {\n				hasStackedSeries = true;\n				break;\n			}\n		}\n		if (hasStackedSeries) { // mark others as dirty\n			i = seriesLength;\n			while (i--) {\n				serie = series[i];\n				if (serie.options.stacking) {\n					serie.isDirty = true;\n				}\n			}\n		}\n\n		// handle updated data in the series\n		each(series, function (serie) {\n			if (serie.isDirty) { // prepare the data so axis can read it\n				if (serie.options.legendType === 'point') {\n					redrawLegend = true;\n				}\n			}\n		});\n\n		// handle added or removed series\n		if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed\n			// draw legend graphics\n			legend.render();\n\n			chart.isDirtyLegend = false;\n		}\n\n\n		if (chart.hasCartesianSeries) {\n			if (!chart.isResizing) {\n\n				// reset maxTicks\n				chart.maxTicks = null;\n\n				// set axes scales\n				each(axes, function (axis) {\n					axis.setScale();\n				});\n			}\n			chart.adjustTickAmounts();\n			chart.getMargins();\n\n			// redraw axes\n			each(axes, function (axis) {\n				\n				// Fire 'afterSetExtremes' only if extremes are set\n				if (axis.isDirtyExtremes) { // #821\n					axis.isDirtyExtremes = false;\n					afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)\n						fireEvent(axis, 'afterSetExtremes', axis.getExtremes()); // #747, #751\n					});\n				}\n								\n				if (axis.isDirty || isDirtyBox || hasStackedSeries) {\n					axis.redraw();\n					isDirtyBox = true; // #792\n				}\n			});\n\n\n		}\n		// the plot areas size has changed\n		if (isDirtyBox) {\n			chart.drawChartBox();\n		}\n\n\n\n		// redraw affected series\n		each(series, function (serie) {\n			if (serie.isDirty && serie.visible &&\n					(!serie.isCartesian || serie.xAxis)) { // issue #153\n				serie.redraw();\n			}\n		});\n\n		// move tooltip or reset\n		if (tracker && tracker.resetTracker) {\n			tracker.resetTracker(true);\n		}\n\n		// redraw if canvas\n		renderer.draw();\n\n		// fire the event\n		fireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw\n		\n		if (isHiddenChart) {\n			chart.cloneRenderTo(true);\n		}\n		\n		// Fire callbacks that are put on hold until after the redraw\n		each(afterRedraw, function (callback) {\n			callback.call();\n		});\n	},\n\n\n\n	/**\n	 * Dim the chart and show a loading text or symbol\n	 * @param {String} str An optional text to show in the loading label instead of the default one\n	 */\n	showLoading: function (str) {\n		var chart = this,\n			options = chart.options,\n			loadingDiv = chart.loadingDiv;\n\n		var loadingOptions = options.loading;\n\n		// create the layer at the first call\n		if (!loadingDiv) {\n			chart.loadingDiv = loadingDiv = createElement(DIV, {\n				className: PREFIX + 'loading'\n			}, extend(loadingOptions.style, {\n				left: chart.plotLeft + PX,\n				top: chart.plotTop + PX,\n				width: chart.plotWidth + PX,\n				height: chart.plotHeight + PX,\n				zIndex: 10,\n				display: NONE\n			}), chart.container);\n\n			chart.loadingSpan = createElement(\n				'span',\n				null,\n				loadingOptions.labelStyle,\n				loadingDiv\n			);\n\n		}\n\n		// update text\n		chart.loadingSpan.innerHTML = str || options.lang.loading;\n\n		// show it\n		if (!chart.loadingShown) {\n			css(loadingDiv, { opacity: 0, display: '' });\n			animate(loadingDiv, {\n				opacity: loadingOptions.style.opacity\n			}, {\n				duration: loadingOptions.showDuration || 0\n			});\n			chart.loadingShown = true;\n		}\n	},\n\n	/**\n	 * Hide the loading layer\n	 */\n	hideLoading: function () {\n		var options = this.options,\n			loadingDiv = this.loadingDiv;\n\n		if (loadingDiv) {\n			animate(loadingDiv, {\n				opacity: 0\n			}, {\n				duration: options.loading.hideDuration || 100,\n				complete: function () {\n					css(loadingDiv, { display: NONE });\n				}\n			});\n		}\n		this.loadingShown = false;\n	},\n\n	/**\n	 * Get an axis, series or point object by id.\n	 * @param id {String} The id as given in the configuration options\n	 */\n	get: function (id) {\n		var chart = this,\n			axes = chart.axes,\n			series = chart.series;\n\n		var i,\n			j,\n			points;\n\n		// search axes\n		for (i = 0; i < axes.length; i++) {\n			if (axes[i].options.id === id) {\n				return axes[i];\n			}\n		}\n\n		// search series\n		for (i = 0; i < series.length; i++) {\n			if (series[i].options.id === id) {\n				return series[i];\n			}\n		}\n\n		// search points\n		for (i = 0; i < series.length; i++) {\n			points = series[i].points || [];\n			for (j = 0; j < points.length; j++) {\n				if (points[j].id === id) {\n					return points[j];\n				}\n			}\n		}\n		return null;\n	},\n\n	/**\n	 * Create the Axis instances based on the config options\n	 */\n	getAxes: function () {\n		var chart = this,\n			options = this.options;\n\n		var xAxisOptions = options.xAxis || {},\n			yAxisOptions = options.yAxis || {},\n			optionsArray,\n			axis;\n\n		// make sure the options are arrays and add some members\n		xAxisOptions = splat(xAxisOptions);\n		each(xAxisOptions, function (axis, i) {\n			axis.index = i;\n			axis.isX = true;\n		});\n\n		yAxisOptions = splat(yAxisOptions);\n		each(yAxisOptions, function (axis, i) {\n			axis.index = i;\n		});\n\n		// concatenate all axis options into one array\n		optionsArray = xAxisOptions.concat(yAxisOptions);\n\n		each(optionsArray, function (axisOptions) {\n			axis = new Axis(chart, axisOptions);\n		});\n\n		chart.adjustTickAmounts();\n	},\n\n\n	/**\n	 * Get the currently selected points from all series\n	 */\n	getSelectedPoints: function () {\n		var points = [];\n		each(this.series, function (serie) {\n			points = points.concat(grep(serie.points, function (point) {\n				return point.selected;\n			}));\n		});\n		return points;\n	},\n\n	/**\n	 * Get the currently selected series\n	 */\n	getSelectedSeries: function () {\n		return grep(this.series, function (serie) {\n			return serie.selected;\n		});\n	},\n\n	/**\n	 * Display the zoom button\n	 */\n	showResetZoom: function () {\n		var chart = this,\n			lang = defaultOptions.lang,\n			btnOptions = chart.options.chart.resetZoomButton,\n			theme = btnOptions.theme,\n			states = theme.states,\n			alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n			\n		this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states && states.hover)\n			.attr({\n				align: btnOptions.position");
        builder.append(".align,\n				title: lang.resetZoomTitle\n			})\n			.add()\n			.align(btnOptions.position, false, chart[alignTo]);\n		this.resetZoomButton.alignTo = alignTo;	\n			\n	},\n\n	/**\n	 * Zoom out to 1:1\n	 */\n	zoomOut: function () {\n		var chart = this,\n			resetZoomButton = chart.resetZoomButton;\n\n		fireEvent(chart, 'selection', { resetSelection: true }, function () { chart.zoom(); });\n		if (resetZoomButton) {\n			chart.resetZoomButton = resetZoomButton.destroy();\n		}\n	},\n\n	/**\n	 * Zoom into a given portion of the chart given by axis coordinates\n	 * @param {Object} event\n	 */\n	zoom: function (event) {\n		var chart = this,\n			hasZoomed;\n\n		// if zoom is called with no arguments, reset the axes\n		if (!event || event.resetSelection) {\n			each(chart.axes, function (axis) {\n				hasZoomed = axis.zoom();\n			});\n		} else { // else, zoom in on all axes\n			each(event.xAxis.concat(event.yAxis), function (axisData) {\n				var axis = axisData.axis;\n\n				// don't zoom more than minRange\n				if (chart.tracker[axis.isXAxis ? 'zoomX' : 'zoomY']) {\n					hasZoomed = axis.zoom(axisData.min, axisData.max);\n				}\n			});\n		}\n		\n		// Show the Reset zoom button\n		if (!chart.resetZoomButton) {\n			chart.showResetZoom();\n		}\n		\n\n		// Redraw\n		if (hasZoomed) {\n			chart.redraw(\n				pick(chart.options.chart.animation, chart.pointCount < 100) // animation\n			);\n		}\n	},\n\n	/**\n	 * Pan the chart by dragging the mouse across the pane. This function is called\n	 * on mouse move, and the distance to pan is computed from chartX compared to\n	 * the first chartX position in the dragging operation.\n	 */\n	pan: function (chartX) {\n		var chart = this;\n\n		var xAxis = chart.xAxis[0],\n			mouseDownX = chart.mouseDownX,\n			halfPointRange = xAxis.pointRange / 2,\n			extremes = xAxis.getExtremes(),\n			newMin = xAxis.translate(mouseDownX - chartX, true) + halfPointRange,\n			newMax = xAxis.translate(mouseDownX + chart.plotWidth - chartX, true) - halfPointRange,\n			hoverPoints = chart.hoverPoints;\n\n		// remove active points for shared tooltip\n		if (hoverPoints) {\n			each(hoverPoints, function (point) {\n				point.setState();\n			});\n		}\n\n		if (xAxis.series.length && newMin > mathMin(extremes.dataMin, extremes.min) && newMax < mathMax(extremes.dataMax, extremes.max)) {\n			xAxis.setExtremes(newMin, newMax, true, false, { trigger: 'pan' });\n		}\n\n		chart.mouseDownX = chartX; // set new reference for next run\n		css(chart.container, { cursor: 'move' });\n	},\n\n	/**\n	 * Show the title and subtitle of the chart\n	 *\n	 * @param titleOptions {Object} New title options\n	 * @param subtitleOptions {Object} New subtitle options\n	 *\n	 */\n	setTitle: function (titleOptions, subtitleOptions) {\n		var chart = this,\n			options = chart.options,\n			chartTitleOptions,\n			chartSubtitleOptions;\n\n		chart.chartTitleOptions = chartTitleOptions = merge(options.title, titleOptions);\n		chart.chartSubtitleOptions = chartSubtitleOptions = merge(options.subtitle, subtitleOptions);\n\n		// add title and subtitle\n		each([\n			['title', titleOptions, chartTitleOptions],\n			['subtitle', subtitleOptions, chartSubtitleOptions]\n		], function (arr) {\n			var name = arr[0],\n				title = chart[name],\n				titleOptions = arr[1],\n				chartTitleOptions = arr[2];\n\n			if (title && titleOptions) {\n				chart[name] = title = title.destroy(); // remove old\n			}\n			\n			if (chartTitleOptions && chartTitleOptions.text && !title) {\n				chart[name] = chart.renderer.text(\n					chartTitleOptions.text,\n					0,\n					0,\n					chartTitleOptions.useHTML\n				)\n				.attr({\n					align: chartTitleOptions.align,\n					'class': PREFIX + name,\n					zIndex: chartTitleOptions.zIndex || 4\n				})\n				.css(chartTitleOptions.style)\n				.add()\n				.align(chartTitleOptions, false, chart.spacingBox);\n			}\n		});\n\n	},\n\n	/**\n	 * Get chart width and height according to options and container size\n	 */\n	getChartSize: function () {\n		var chart = this,\n			optionsChart = chart.options.chart,\n			renderTo = chart.renderToClone || chart.renderTo;\n\n		// get inner width and height from jQuery (#824)\n		chart.containerWidth = adapterRun(renderTo, 'width');\n		chart.containerHeight = adapterRun(renderTo, 'height');\n		\n		chart.chartWidth = mathMax(0, pick(optionsChart.width, chart.containerWidth, 600));\n		chart.chartHeight = mathMax(0, pick(optionsChart.height,\n			// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:\n			chart.containerHeight > 19 ? chart.containerHeight : 400));\n	},\n\n	/**\n	 * Create a clone of the chart's renderTo div and place it outside the viewport to allow\n	 * size computation on chart.render and chart.redraw\n	 */\n	cloneRenderTo: function (revert) {\n		var clone = this.renderToClone,\n			container = this.container;\n		\n		// Destroy the clone and bring the container back to the real renderTo div\n		if (revert) {\n			if (clone) {\n				this.renderTo.appendChild(container);\n				discardElement(clone);\n				delete this.renderToClone;\n			}\n		\n		// Set up the clone\n		} else {\n			if (container) {\n				this.renderTo.removeChild(container); // do not clone this\n			}\n			this.renderToClone = clone = this.renderTo.cloneNode(0);\n			css(clone, {\n				position: ABSOLUTE,\n				top: '-9999px',\n				display: 'block' // #833\n			});\n			doc.body.appendChild(clone);\n			if (container) {\n				clone.appendChild(container);\n			}\n		}\n	},\n\n	/**\n	 * Get the containing element, determine the size and create the inner container\n	 * div to hold the chart\n	 */\n	getContainer: function () {\n		var chart = this,\n			container,\n			optionsChart = chart.options.chart,\n			chartWidth,\n			chartHeight,\n			renderTo,\n			indexAttrName = 'data-highcharts-chart',\n			oldChartIndex,\n			containerId;\n\n		chart.renderTo = renderTo = optionsChart.renderTo;\n		containerId = PREFIX + idCounter++;\n\n		if (isString(renderTo)) {\n			chart.renderTo = renderTo = doc.getElementById(renderTo);\n		}\n		\n		// Display an error if the renderTo is wrong\n		if (!renderTo) {\n			error(13, true);\n		}\n		\n		// If the container already holds a chart, destroy it\n		oldChartIndex = pInt(attr(renderTo, indexAttrName));\n		if (!isNaN(oldChartIndex) && charts[oldChartIndex]) {\n			charts[oldChartIndex].destroy();\n		}		\n		\n		// Make a reference to the chart from the div\n		attr(renderTo, indexAttrName, chart.index);\n\n		// remove previous chart\n		renderTo.innerHTML = '';\n\n		// If the container doesn't have an offsetWidth, it has or is a child of a node\n		// that has display:none. We need to temporarily move it out to a visible\n		// state to determine the size, else the legend and tooltips won't render\n		// properly\n		if (!renderTo.offsetWidth) {\n			chart.cloneRenderTo();\n		}\n\n		// get the width and height\n		chart.getChartSize();\n		chartWidth = chart.chartWidth;\n		chartHeight = chart.chartHeight;\n\n		// create the inner container\n		chart.container = container = createElement(DIV, {\n				className: PREFIX + 'container' +\n					(optionsChart.className ? ' ' + optionsChart.className : ''),\n				id: containerId\n			}, extend({\n				position: RELATIVE,\n				overflow: HIDDEN, // needed for context menu (avoid scrollbars) and\n					// content overflow in IE\n				width: chartWidth + PX,\n				height: chartHeight + PX,\n				textAlign: 'left',\n				lineHeight: 'normal', // #427\n				zIndex: 0 // #1072\n			}, optionsChart.style),\n			chart.renderToClone || renderTo\n		);\n\n		chart.renderer =\n			optionsChart.forExport ? // force SVG, used for SVG export\n				new SVGRenderer(container, chartWidth, chartHeight, true) :\n				new Renderer(container, chartWidth, chartHeight);\n\n		if (useCanVG) {\n			// If we need canvg library, extend and configure the renderer\n			// to get the tracker for translating mouse events\n			chart.renderer.create(chart, container, chartWidth, chartHeight);\n		}\n	},\n\n	/**\n	 * Calculate margins by rendering axis labels in a preliminary position. Title,\n	 * subtitle and legend have already been rendered at this stage, but will be\n	 * moved into their final positions\n	 */\n	getMargins: function () {\n		var chart = this,\n			optionsChart = chart.options.chart,\n			spacingTop = optionsChart.spacingTop,\n			spacingRight = optionsChart.spacingRight,\n			spacingBottom = optionsChart.spacingBottom,\n			spacingLeft = optionsChart.spacingLeft,\n			axisOffset,\n			legend = chart.legend,\n			optionsMarginTop = chart.optionsMarginTop,\n			optionsMarginLeft = chart.optionsMarginLeft,\n			optionsMarginRight = chart.optionsMarginRight,\n			optionsMarginBottom = chart.optionsMarginBottom,\n			chartTitleOptions = chart.chartTitleOptions,\n			chartSubtitleOptions = chart.chartSubtitleOptions,\n			legendOptions = chart.options.legend,\n			legendMargin = pick(legendOptions.margin, 10),\n			legendX = legendOptions.x,\n			legendY = legendOptions.y,\n			align = legendOptions.align,\n			verticalAlign = legendOptions.verticalAlign,\n			titleOffset;\n\n		chart.resetMargins();\n		axisOffset = chart.axisOffset;\n\n		// adjust for title and subtitle\n		if ((chart.title || chart.subtitle) && !defined(chart.optionsMarginTop)) {\n			titleOffset = mathMax(\n				(chart.title && !chartTitleOptions.floating && !chartTitleOptions.verticalAlign && chartTitleOptions.y) || 0,\n				(chart.subtitle && !chartSubtitleOptions.floating && !chartSubtitleOptions.verticalAlign && chartSubtitleOptions.y) || 0\n			);\n			if (titleOffset) {\n				chart.plotTop = mathMax(chart.plotTop, titleOffset + pick(chartTitleOptions.margin, 15) + spacingTop);\n			}\n		}\n		// adjust for legend\n		if (legend.display && !legendOptions.floating) {\n			if (align === 'right') { // horizontal alignment handled first\n				if (!defined(optionsMarginRight)) {\n					chart.marginRight = mathMax(\n						chart.marginRight,\n						legend.legendWidth - legendX + legendMargin + spacingRight\n					);\n				}\n			} else if (align === 'left') {\n				if (!defined(optionsMarginLeft)) {\n					chart.plotLeft = mathMax(\n						chart.plotLeft,\n						legend.legendWidth + legendX + legendMargin + spacingLeft\n					);\n				}\n\n			} else if (verticalAlign === 'top') {\n				if (!defined(optionsMarginTop)) {\n					chart.plotTop = mathMax(\n						chart.plotTop,\n						legend.legendHeight + legendY + legendMargin + spacingTop\n					);\n				}\n\n			} else if (verticalAlign === 'bottom') {\n				if (!defined(optionsMarginBottom)) {\n					chart.marginBottom = mathMax(\n						chart.marginBottom,\n						legend.legendHeight - legendY + legendMargin + spacingBottom\n					);\n				}\n			}\n		}\n\n		// adjust for scroller\n		if (chart.extraBottomMargin) {\n			chart.marginBottom += chart.extraBottomMargin;\n		}\n		if (chart.extraTopMargin) {\n			chart.plotTop += chart.extraTopMargin;\n		}\n\n		// pre-render axes to get labels offset width\n		if (chart.hasCartesianSeries) {\n			each(chart.axes, function (axis) {\n				axis.getOffset();\n			});\n		}\n		\n		if (!defined(optionsMarginLeft)) {\n			chart.plotLeft += axisOffset[3];\n		}\n		if (!defined(optionsMarginTop)) {\n			chart.plotTop += axisOffset[0];\n		}\n		if (!defined(optionsMarginBottom)) {\n			chart.marginBottom += axisOffset[2];\n		}\n		if (!defined(optionsMarginRight)) {\n			chart.marginRight += axisOffset[1];\n		}\n\n		chart.setChartSize();\n\n	},\n\n	/**\n	 * Add the event handlers necessary for auto resizing\n	 *\n	 */\n	initReflow: function () {\n		var chart = this,\n			optionsChart = chart.options.chart,\n			renderTo = chart.renderTo,\n			reflowTimeout;\n			\n		function reflow(e) {\n			var width = optionsChart.width || adapterRun(renderTo, 'width'),\n				height = optionsChart.height || adapterRun(renderTo, 'height'),\n				target = e ? e.target : win; // #805 - MooTools doesn't supply e\n				\n			// Width and height checks for display:none. Target is doc in IE8 and Opera,\n			// win in Firefox, Chrome and IE9.\n			if (!chart.hasUserSize && width && height && (target === win || target === doc)) {\n				\n				if (width !== chart.containerWidth || height !== chart.containerHeight) {\n					clearTimeout(reflowTimeout);\n					chart.reflowTimeout = reflowTimeout = setTimeout(function () {\n						if (chart.container) { // It may have been destroyed in the meantime (#1257)\n							chart.setSize(width, height, false);\n							chart.hasUserSize = null;\n						}\n					}, 100);\n				}\n				chart.containerWidth = width;\n				chart.containerHeight = height;\n			}\n		}\n		addEvent(win, 'resize', reflow);\n		addEvent(chart, 'destroy', function () {\n			removeEvent(win, 'resize', reflow);\n		});\n	},\n\n	/**\n	 * Resize the chart to a given width and height\n	 * @param {Number} width\n	 * @param {Number} height\n	 * @param {Object|Boolean} animation\n	 */\n	setSize: function (width, height, animation) {\n		var chart = this,\n			chartWidth,\n			chartHeight,\n			spacingBox,\n			resetZoomButton = chart.resetZoomButton,\n			chartTitle = chart.title,\n			chartSubtitle = chart.subtitle,\n			fireEndResize;\n\n		// Handle the isResizing counter\n		chart.isResizing += 1;\n		fireEndResize = function () {\n			if (chart) {\n				fireEvent(chart, 'endResize', null, function () {\n					chart.isResizing -= 1;\n				});\n			}\n		};\n\n		// set the animation for the current process\n		setAnimation(animation, chart);\n\n		chart.oldChartHeight = chart.chartHeight;\n		chart.oldChartWidth = chart.chartWidth;\n		if (defined(width)) {\n			chart.chartWidth = chartWidth = mathMax(0, mathRound(width));\n			chart.hasUserSize = !!chartWidth;\n		}\n		if (defined(height)) {\n			chart.chartHeight = chartHeight = mathMax(0, mathRound(height));\n		}\n\n		css(chart.container, {\n			width: chartWidth + PX,\n			height: chartHeight + PX\n		});\n		chart.renderer.setSize(chartWidth, chartHeight, animation);\n\n		// update axis lengths for more correct tick intervals:\n		chart.plotWidth = chartWidth - chart.plotLeft - chart.marginRight;\n		chart.plotHeight = chartHeight - chart.plotTop - chart.marginBottom;\n\n		// handle axes\n		chart.maxTicks = null;\n		each(chart.axes, function (axis) {\n			axis.isDirty = true;\n			axis.setScale();\n		});\n\n		// make sure non-cartesian series are also handled\n		each(chart.series, function (serie) {\n			serie.isDirty = true;\n		});\n\n		chart.isDirtyLegend = true; // force legend redraw\n		chart.isDirtyBox = true; // force redraw of plot and chart border\n\n		chart.getMargins();\n\n		// move titles\n		spacingBox = chart.spacingBox;\n		if (chartTitle) {\n			chartTitle.align(null, null, spacingBox);\n		}\n		if (chartSubtitle) {\n			chartSubtitle.align(null, null, spacingBox);\n		}\n		\n		// Move resize button (#1115)\n		if (resetZoomButton && resetZoomButton.align) {\n			resetZoomButton.align(null, null, chart[resetZoomButton.alignTo]);\n		}\n\n		chart.redraw(animation);\n\n\n		chart.oldChartHeight = null;\n		fireEvent(chart, 'resize');\n\n		// fire endResize and set isResizing back\n		// If animation is disabled, fire without delay\n		if (globalAnimation === false) {\n			fireEndResize();\n		} else { // else set a timeout with the animation duration\n			setTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);\n		}\n	},\n\n	/**\n	 * Set the public chart properties. This is done before and after the pre-render\n	 * to determine margin sizes\n	 */\n	setChartSize: function () {\n		var chart = this,\n			inverted = chart.inverted,\n			chartWidth = chart.chartWidth,\n			chartHeight = chart.chartHeight,\n			optionsChart = chart.options.chart,\n			spacingTop = optionsChart.spacingTop,\n			spacingRight = optionsChart.spacingRight,\n			spacingBottom = optionsChart.spacingBottom,\n			spacingLeft = optionsChart.spacingLeft,\n			plotLeft,\n			plotTop,\n			plotWidth,\n			plotHeight,\n			plotBorderWidth;\n\n		chart.plotLeft = plotLeft = mathRound(chart.plotLeft);\n		chart.plotTop = plotTop = mathRound(chart.plotTop);\n		chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));\n		chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));\n\n		chart.plotSizeX = inverted ? plotHeight : plotWidth;\n		chart.plotSizeY = inverted ? plotWidth : plotHeight;\n		\n		chart.plotBorderWidth = plotBorderWidth = optionsChart.plotBorderWidth || 0;\n\n		// Set boxes used for alignment\n		chart.spacingBox = {\n			x: spacingLeft,\n			y: spacingTop,\n			width: chartWidth - spacingLeft - spacingRight,\n			height: chartHeight - spacingTop - spacingBottom\n		};\n		chart.plotBox = {\n			x: plotLeft,\n			y: plotTop,\n			width: plotWidth,\n			height: plotHeight\n		};\n		chart.clipBox = {\n			x: plotBorderWidth / 2, \n			y: plotBorderWidth / 2, \n			width: chart.plotSizeX - plotBorderWidth, \n			height: chart.plotSizeY - plotBorderWidth\n		};\n\n		each(chart.axes, function (axis) {\n			axis.setAxisSize();\n			axis.setAxisTranslation();\n		});\n	},\n\n	/**\n	 * Initial margins before auto size margins are applied\n	 */\n	resetMargins");
        builder.append(": function () {\n		var chart = this,\n			optionsChart = chart.options.chart,\n			spacingTop = optionsChart.spacingTop,\n			spacingRight = optionsChart.spacingRight,\n			spacingBottom = optionsChart.spacingBottom,\n			spacingLeft = optionsChart.spacingLeft;\n\n		chart.plotTop = pick(chart.optionsMarginTop, spacingTop);\n		chart.marginRight = pick(chart.optionsMarginRight, spacingRight);\n		chart.marginBottom = pick(chart.optionsMarginBottom, spacingBottom);\n		chart.plotLeft = pick(chart.optionsMarginLeft, spacingLeft);\n		chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n	},\n\n	/**\n	 * Draw the borders and backgrounds for chart and plot area\n	 */\n	drawChartBox: function () {\n		var chart = this,\n			optionsChart = chart.options.chart,\n			renderer = chart.renderer,\n			chartWidth = chart.chartWidth,\n			chartHeight = chart.chartHeight,\n			chartBackground = chart.chartBackground,\n			plotBackground = chart.plotBackground,\n			plotBorder = chart.plotBorder,\n			plotBGImage = chart.plotBGImage,\n			chartBorderWidth = optionsChart.borderWidth || 0,\n			chartBackgroundColor = optionsChart.backgroundColor,\n			plotBackgroundColor = optionsChart.plotBackgroundColor,\n			plotBackgroundImage = optionsChart.plotBackgroundImage,\n			plotBorderWidth = optionsChart.plotBorderWidth || 0,\n			mgn,\n			bgAttr,\n			plotLeft = chart.plotLeft,\n			plotTop = chart.plotTop,\n			plotWidth = chart.plotWidth,\n			plotHeight = chart.plotHeight,\n			plotBox = chart.plotBox,\n			clipRect = chart.clipRect,\n			clipBox = chart.clipBox;\n\n		// Chart area\n		mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);\n\n		if (chartBorderWidth || chartBackgroundColor) {\n			if (!chartBackground) {\n				\n				bgAttr = {\n					fill: chartBackgroundColor || NONE\n				};\n				if (chartBorderWidth) { // #980\n					bgAttr.stroke = optionsChart.borderColor;\n					bgAttr['stroke-width'] = chartBorderWidth;\n				}\n				chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,\n						optionsChart.borderRadius, chartBorderWidth)\n					.attr(bgAttr)\n					.add()\n					.shadow(optionsChart.shadow);\n\n			} else { // resize\n				chartBackground.animate(\n					chartBackground.crisp(null, null, null, chartWidth - mgn, chartHeight - mgn)\n				);\n			}\n		}\n\n\n		// Plot background\n		if (plotBackgroundColor) {\n			if (!plotBackground) {\n				chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)\n					.attr({\n						fill: plotBackgroundColor\n					})\n					.add()\n					.shadow(optionsChart.plotShadow);\n			} else {\n				plotBackground.animate(plotBox);\n			}\n		}\n		if (plotBackgroundImage) {\n			if (!plotBGImage) {\n				chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)\n					.add();\n			} else {\n				plotBGImage.animate(plotBox);\n			}\n		}\n		\n		// Plot clip\n		if (!clipRect) {\n			chart.clipRect = renderer.clipRect(clipBox);\n		} else {\n			clipRect.animate({\n				width: clipBox.width,\n				height: clipBox.height\n			});\n		}\n\n		// Plot area border\n		if (plotBorderWidth) {\n			if (!plotBorder) {\n				chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, plotBorderWidth)\n					.attr({\n						stroke: optionsChart.plotBorderColor,\n						'stroke-width': plotBorderWidth,\n						zIndex: 1\n					})\n					.add();\n			} else {\n				plotBorder.animate(\n					plotBorder.crisp(null, plotLeft, plotTop, plotWidth, plotHeight)\n				);\n			}\n		}\n\n		// reset\n		chart.isDirtyBox = false;\n	},\n\n	/**\n	 * Detect whether a certain chart property is needed based on inspecting its options\n	 * and series. This mainly applies to the chart.invert property, and in extensions to \n	 * the chart.angular and chart.polar properties.\n	 */\n	propFromSeries: function () {\n		var chart = this,\n			optionsChart = chart.options.chart,\n			klass,\n			seriesOptions = chart.options.series,\n			i,\n			value;\n			\n			\n		each(['inverted', 'angular', 'polar'], function (key) {\n			\n			// The default series type's class\n			klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];\n			\n			// Get the value from available chart-wide properties\n			value = (\n				chart[key] || // 1. it is set before\n				optionsChart[key] || // 2. it is set in the options\n				(klass && klass.prototype[key]) // 3. it's default series class requires it\n			);\n	\n			// 4. Check if any the chart's series require it\n			i = seriesOptions && seriesOptions.length;\n			while (!value && i--) {\n				klass = seriesTypes[seriesOptions[i].type];\n				if (klass && klass.prototype[key]) {\n					value = true;\n				}\n			}\n	\n			// Set the chart property\n			chart[key] = value;	\n		});\n		\n	},\n\n	/**\n	 * Render all graphics for the chart\n	 */\n	render: function () {\n		var chart = this,\n			axes = chart.axes,\n			renderer = chart.renderer,\n			options = chart.options;\n\n		var labels = options.labels,\n			credits = options.credits,\n			creditsHref;\n\n		// Title\n		chart.setTitle();\n\n\n		// Legend\n		chart.legend = new Legend(chart);\n\n		// Get margins by pre-rendering axes\n		// set axes scales\n		each(axes, function (axis) {\n			axis.setScale();\n		});\n		chart.getMargins();\n\n		chart.maxTicks = null; // reset for second pass\n		each(axes, function (axis) {\n			axis.setTickPositions(true); // update to reflect the new margins\n			axis.setMaxTicks();\n		});\n		chart.adjustTickAmounts();\n		chart.getMargins(); // second pass to check for new labels\n\n\n		// Draw the borders and backgrounds\n		chart.drawChartBox();		\n\n\n		// Axes\n		if (chart.hasCartesianSeries) {\n			each(axes, function (axis) {\n				axis.render();\n			});\n		}\n\n		// The series\n		if (!chart.seriesGroup) {\n			chart.seriesGroup = renderer.g('series-group')\n				.attr({ zIndex: 3 })\n				.add();\n		}\n		each(chart.series, function (serie) {\n			serie.translate();\n			serie.setTooltipPoints();\n			serie.render();\n		});\n\n		// Labels\n		if (labels.items) {\n			each(labels.items, function (label) {\n				var style = extend(labels.style, label.style),\n					x = pInt(style.left) + chart.plotLeft,\n					y = pInt(style.top) + chart.plotTop + 12;\n\n				// delete to prevent rewriting in IE\n				delete style.left;\n				delete style.top;\n\n				renderer.text(\n					label.html,\n					x,\n					y\n				)\n				.attr({ zIndex: 2 })\n				.css(style)\n				.add();\n\n			});\n		}\n\n		// Credits\n		if (credits.enabled && !chart.credits) {\n			creditsHref = credits.href;\n			chart.credits = renderer.text(\n				credits.text,\n				0,\n				0\n			)\n			.on('click', function () {\n				if (creditsHref) {\n					location.href = creditsHref;\n				}\n			})\n			.attr({\n				align: credits.position.align,\n				zIndex: 8\n			})\n			.css(credits.style)\n			.add()\n			.align(credits.position);\n		}\n\n		// Set flag\n		chart.hasRendered = true;\n\n	},\n\n	/**\n	 * Clean up memory usage\n	 */\n	destroy: function () {\n		var chart = this,\n			axes = chart.axes,\n			series = chart.series,\n			container = chart.container,\n			i,\n			parentNode = container && container.parentNode;\n			\n		// fire the chart.destoy event\n		fireEvent(chart, 'destroy');\n		\n		// Delete the chart from charts lookup array\n		charts[chart.index] = UNDEFINED;\n		chart.renderTo.removeAttribute('data-highcharts-chart');\n\n		// remove events\n		removeEvent(chart);\n\n		// ==== Destroy collections:\n		// Destroy axes\n		i = axes.length;\n		while (i--) {\n			axes[i] = axes[i].destroy();\n		}\n\n		// Destroy each series\n		i = series.length;\n		while (i--) {\n			series[i] = series[i].destroy();\n		}\n\n		// ==== Destroy chart properties:\n		each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', \n				'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'tracker', 'scroller', \n				'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {\n			var prop = chart[name];\n\n			if (prop && prop.destroy) {\n				chart[name] = prop.destroy();\n			}\n		});\n\n		// remove container and all SVG\n		if (container) { // can break in IE when destroyed before finished loading\n			container.innerHTML = '';\n			removeEvent(container);\n			if (parentNode) {\n				discardElement(container);\n			}\n\n		}\n\n		// clean it all up\n		for (i in chart) {\n			delete chart[i];\n		}\n\n	},\n\n\n	/**\n	 * VML namespaces can't be added until after complete. Listening\n	 * for Perini's doScroll hack is not enough.\n	 */\n	isReadyToRender: function () {\n		var chart = this;\n\n		// Note: in spite of JSLint's complaints, win == win.top is required\n		/*jslint eqeq: true*/\n		if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) {\n		/*jslint eqeq: false*/\n			if (useCanVG) {\n				// Delay rendering until canvg library is downloaded and ready\n				CanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);\n			} else {\n				doc.attachEvent('onreadystatechange', function () {\n					doc.detachEvent('onreadystatechange', chart.firstRender);\n					if (doc.readyState === 'complete') {\n						chart.firstRender();\n					}\n				});\n			}\n			return false;\n		}\n		return true;\n	},\n\n	/**\n	 * Prepare for first rendering after all data are loaded\n	 */\n	firstRender: function () {\n		var chart = this,\n			options = chart.options,\n			callback = chart.callback;\n\n		// Check whether the chart is ready to render\n		if (!chart.isReadyToRender()) {\n			return;\n		}\n\n		// Create the container\n		chart.getContainer();\n\n		// Run an early event after the container and renderer are established\n		fireEvent(chart, 'init');\n\n		// Initialize range selector for stock charts\n		if (Highcharts.RangeSelector && options.rangeSelector.enabled) {\n			chart.rangeSelector = new Highcharts.RangeSelector(chart);\n		}\n\n		chart.resetMargins();\n		chart.setChartSize();\n\n		// Set the common chart properties (mainly invert) from the given series\n		chart.propFromSeries();\n\n		// get axes\n		chart.getAxes();\n\n		// Initialize the series\n		each(options.series || [], function (serieOptions) {\n			chart.initSeries(serieOptions);\n		});\n\n		// Run an event where series and axes can be added\n		//fireEvent(chart, 'beforeRender');\n\n		// Initialize scroller for stock charts\n		if (Highcharts.Scroller && (options.navigator.enabled || options.scrollbar.enabled)) {\n			chart.scroller = new Highcharts.Scroller(chart);\n		}\n\n		// depends on inverted and on margins being set\n		chart.tracker = new MouseTracker(chart, options);\n\n		chart.render();\n\n		// add canvas\n		chart.renderer.draw();\n		// run callbacks\n		if (callback) {\n			callback.apply(chart, [chart]);\n		}\n		each(chart.callbacks, function (fn) {\n			fn.apply(chart, [chart]);\n		});\n		\n		\n		// If the chart was rendered outside the top container, put it back in\n		chart.cloneRenderTo(true);\n\n		fireEvent(chart, 'load');\n\n	}\n}; // end Chart\n\n// Hook for exporting module\nChart.prototype.callbacks = [];\n/**\n * The Point object and prototype. Inheritable and used as base for PiePoint\n */\nvar Point = function () {};\nPoint.prototype = {\n\n	/**\n	 * Initialize the point\n	 * @param {Object} series The series object containing this point\n	 * @param {Object} options The data in either number, array or object format\n	 */\n	init: function (series, options, x) {\n		var point = this,\n			counters = series.chart.counters,\n			defaultColors;\n		point.series = series;\n		point.applyOptions(options, x);\n		point.pointAttr = {};\n\n		if (series.options.colorByPoint) {\n			defaultColors = series.chart.options.colors;\n			point.color = point.color || defaultColors[counters.color++];\n			// loop back to zero\n			counters.wrapColor(defaultColors.length);\n		}\n\n		series.chart.pointCount++;\n		return point;\n	},\n	/**\n	 * Apply the options containing the x and y data and possible some extra properties.\n	 * This is called on point init or from point.update.\n	 *\n	 * @param {Object} options\n	 */\n	applyOptions: function (options, x) {\n		var point = this,\n			series = point.series,\n			optionsType = typeof options;\n\n		point.config = options;\n\n		// onedimensional array input\n		if (optionsType === 'number' || options === null) {\n			point.y = options;\n		} else if (typeof options[0] === 'number') { // two-dimentional array\n			point.x = options[0];\n			point.y = options[1];\n		} else if (optionsType === 'object' && typeof options.length !== 'number') { // object input\n			// copy options directly to point\n			extend(point, options);\n			point.options = options;\n			\n			// This is the fastest way to detect if there are individual point dataLabels that need \n			// to be considered in drawDataLabels. These can only occur in object configs.\n			if (options.dataLabels) {\n				series._hasPointLabels = true;\n			}\n			\n			// Same approach as above for markers\n			if (options.marker) {\n				series._hasPointMarkers = true;\n			}\n		} else if (typeof options[0] === 'string') { // categorized data with name in first position\n			point.name = options[0];\n			point.y = options[1];\n		}\n		\n		/*\n		 * If no x is set by now, get auto incremented value. All points must have an\n		 * x value, however the y value can be null to create a gap in the series\n		 */\n		// todo: skip this? It is only used in applyOptions, in translate it should not be used\n		if (point.x === UNDEFINED) {\n			point.x = x === UNDEFINED ? series.autoIncrement() : x;\n		}\n		\n	},\n\n	/**\n	 * Destroy a point to clear memory. Its reference still stays in series.data.\n	 */\n	destroy: function () {\n		var point = this,\n			series = point.series,\n			chart = series.chart,\n			hoverPoints = chart.hoverPoints,\n			prop;\n\n		chart.pointCount--;\n\n		if (hoverPoints) {\n			point.setState();\n			erase(hoverPoints, point);\n			if (!hoverPoints.length) {\n				chart.hoverPoints = null;\n			}\n\n		}\n		if (point === chart.hoverPoint) {\n			point.onMouseOut();\n		}\n		\n		// remove all events\n		if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive\n			removeEvent(point);\n			point.destroyElements();\n		}\n\n		if (point.legendItem) { // pies have legend items\n			chart.legend.destroyItem(point);\n		}\n\n		for (prop in point) {\n			point[prop] = null;\n		}\n\n\n	},\n\n	/**\n	 * Destroy SVG elements associated with the point\n	 */\n	destroyElements: function () {\n		var point = this,\n			props = ['graphic', 'tracker', 'dataLabel', 'dataLabelUpper', 'group', 'connector', 'shadowGroup'],\n			prop,\n			i = 6;\n		while (i--) {\n			prop = props[i];\n			if (point[prop]) {\n				point[prop] = point[prop].destroy();\n			}\n		}\n	},\n\n	/**\n	 * Return the configuration hash needed for the data label and tooltip formatters\n	 */\n	getLabelConfig: function () {\n		var point = this;\n		return {\n			x: point.category,\n			y: point.y,\n			key: point.name || point.category,\n			series: point.series,\n			point: point,\n			percentage: point.percentage,\n			total: point.total || point.stackTotal\n		};\n	},\n\n	/**\n	 * Toggle the selection status of a point\n	 * @param {Boolean} selected Whether to select or unselect the point.\n	 * @param {Boolean} accumulate Whether to add to the previous selection. By default,\n	 *     this happens if the control key (Cmd on Mac) was pressed during clicking.\n	 */\n	select: function (selected, accumulate) {\n		var point = this,\n			series = point.series,\n			chart = series.chart;\n\n		selected = pick(selected, !point.selected);\n\n		// fire the event with the defalut handler\n		point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {\n			point.selected = selected;\n			point.setState(selected && SELECT_STATE);\n\n			// unselect all other points unless Ctrl or Cmd + click\n			if (!accumulate) {\n				each(chart.getSelectedPoints(), function (loopPoint) {\n					if (loopPoint.selected && loopPoint !== point) {\n						loopPoint.selected = false;\n						loopPoint.setState(NORMAL_STATE);\n						loopPoint.firePointEvent('unselect');\n					}\n				});\n			}\n		});\n	},\n\n	onMouseOver: function () {\n		var point = this,\n			series = point.series,\n			chart = series.chart,\n			tooltip = chart.tooltip,\n			hoverPoint = chart.hoverPoint;\n\n		// set normal state to previous series\n		if (hoverPoint && hoverPoint !== point) {\n			hoverPoint.onMouseOut();\n		}\n\n		// trigger the event\n		point.firePointEvent('mouseOver');\n\n		// update the tooltip\n		if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {\n			tooltip.refresh(point);\n		}\n\n		// hover this\n		point.setState(HOVER_STATE);\n		chart.hoverPoint = point;\n	},\n\n	onMouseOut: function () {\n		var chart = this.series.chart,\n			hoverPoints = chart.hoverPoints;\n		\n		if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887\n			this.firePointEvent('mouseOut');\n	\n			this.setState();\n			chart.hoverPoint = null;\n		}\n	},\n\n	/**\n	 * Extendable method for formatting each point's tooltip line\n	 *\n	 * @return {");
        builder.append("String} A string to be concatenated in to the common tooltip text\n	 */\n	tooltipFormatter: function (pointFormat) {\n		var point = this,\n			series = point.series,\n			seriesTooltipOptions = series.tooltipOptions,\n			match = pointFormat.match(/\\{(series|point)\\.[a-zA-Z]+\\}/g),\n			splitter = /[{\\.}]/,\n			obj,\n			key,\n			replacement,\n			repOptionKey,\n			parts,\n			prop,\n			i,\n			cfg = {\n				y: 0, // 0: use 'value' for repOptionKey\n				open: 0,\n				high: 0,\n				low: 0,\n				close: 0,\n				percentage: 1, // 1: use the self name for repOptionKey\n				total: 1\n			};\n		\n		// Backwards compatibility to y naming in early Highstock\n		seriesTooltipOptions.valuePrefix = seriesTooltipOptions.valuePrefix || seriesTooltipOptions.yPrefix;\n		seriesTooltipOptions.valueDecimals = pick(seriesTooltipOptions.valueDecimals, seriesTooltipOptions.yDecimals); // #1248\n		seriesTooltipOptions.valueSuffix = seriesTooltipOptions.valueSuffix || seriesTooltipOptions.ySuffix;\n\n		// loop over the variables defined on the form {series.name}, {point.y} etc\n		for (i in match) {\n			key = match[i];\n			if (isString(key) && key !== pointFormat) { // IE matches more than just the variables\n				\n				// Split it further into parts\n				parts = (' ' + key).split(splitter); // add empty string because IE and the rest handles it differently\n				obj = { 'point': point, 'series': series }[parts[1]];\n				prop = parts[2];\n				\n				// Add some preformatting\n				if (obj === point && cfg.hasOwnProperty(prop)) {\n					repOptionKey = cfg[prop] ? prop : 'value';\n					replacement = (seriesTooltipOptions[repOptionKey + 'Prefix'] || '') + \n						numberFormat(point[prop], pick(seriesTooltipOptions[repOptionKey + 'Decimals'], -1)) +\n						(seriesTooltipOptions[repOptionKey + 'Suffix'] || '');\n				\n				// Automatic replacement\n				} else {\n					replacement = obj[prop];\n				}\n				\n				pointFormat = pointFormat.replace(key, replacement);\n			}\n		}\n		\n		return pointFormat;\n	},\n\n	/**\n	 * Update the point with new options (typically x/y data) and optionally redraw the series.\n	 *\n	 * @param {Object} options Point options as defined in the series.data array\n	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n	 *    configuration\n	 *\n	 */\n	update: function (options, redraw, animation) {\n		var point = this,\n			series = point.series,\n			graphic = point.graphic,\n			i,\n			data = series.data,\n			dataLength = data.length,\n			chart = series.chart;\n\n		redraw = pick(redraw, true);\n\n		// fire the event with a default handler of doing the update\n		point.firePointEvent('update', { options: options }, function () {\n\n			point.applyOptions(options);\n\n			// update visuals\n			if (isObject(options)) {\n				series.getAttribs();\n				if (graphic) {\n					graphic.attr(point.pointAttr[series.state]);\n				}\n			}\n\n			// record changes in the parallel arrays\n			for (i = 0; i < dataLength; i++) {\n				if (data[i] === point) {\n					series.xData[i] = point.x;\n					series.yData[i] = point.toYData ? point.toYData() : point.y;\n					series.options.data[i] = options;\n					break;\n				}\n			}\n\n			// redraw\n			series.isDirty = true;\n			series.isDirtyData = true;\n			if (redraw) {\n				chart.redraw(animation);\n			}\n		});\n	},\n\n	/**\n	 * Remove a point and optionally redraw the series and if necessary the axes\n	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n	 *    configuration\n	 */\n	remove: function (redraw, animation) {\n		var point = this,\n			series = point.series,\n			chart = series.chart,\n			i,\n			data = series.data,\n			dataLength = data.length;\n\n		setAnimation(animation, chart);\n		redraw = pick(redraw, true);\n\n		// fire the event with a default handler of removing the point\n		point.firePointEvent('remove', null, function () {\n\n			//erase(series.data, point);\n\n			for (i = 0; i < dataLength; i++) {\n				if (data[i] === point) {\n\n					// splice all the parallel arrays\n					data.splice(i, 1);\n					series.options.data.splice(i, 1);\n					series.xData.splice(i, 1);\n					series.yData.splice(i, 1);\n					break;\n				}\n			}\n\n			point.destroy();\n\n\n			// redraw\n			series.isDirty = true;\n			series.isDirtyData = true;\n			if (redraw) {\n				chart.redraw();\n			}\n		});\n\n\n	},\n\n	/**\n	 * Fire an event on the Point object. Must not be renamed to fireEvent, as this\n	 * causes a name clash in MooTools\n	 * @param {String} eventType\n	 * @param {Object} eventArgs Additional event arguments\n	 * @param {Function} defaultFunction Default event handler\n	 */\n	firePointEvent: function (eventType, eventArgs, defaultFunction) {\n		var point = this,\n			series = this.series,\n			seriesOptions = series.options;\n\n		// load event handlers on demand to save time on mouseover/out\n		if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {\n			this.importEvents();\n		}\n\n		// add default handler if in selection mode\n		if (eventType === 'click' && seriesOptions.allowPointSelect) {\n			defaultFunction = function (event) {\n				// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera\n				point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n			};\n		}\n\n		fireEvent(this, eventType, eventArgs, defaultFunction);\n	},\n	/**\n	 * Import events from the series' and point's options. Only do it on\n	 * demand, to save processing time on hovering.\n	 */\n	importEvents: function () {\n		if (!this.hasImportedEvents) {\n			var point = this,\n				options = merge(point.series.options.point, point.options),\n				events = options.events,\n				eventType;\n\n			point.events = events;\n\n			for (eventType in events) {\n				addEvent(point, eventType, events[eventType]);\n			}\n			this.hasImportedEvents = true;\n\n		}\n	},\n\n	/**\n	 * Set the point's state\n	 * @param {String} state\n	 */\n	setState: function (state) {\n		var point = this,\n			plotX = point.plotX,\n			plotY = point.plotY,\n			series = point.series,\n			stateOptions = series.options.states,\n			markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,\n			normalDisabled = markerOptions && !markerOptions.enabled,\n			markerStateOptions = markerOptions && markerOptions.states[state],\n			stateDisabled = markerStateOptions && markerStateOptions.enabled === false,\n			stateMarkerGraphic = series.stateMarkerGraphic,\n			chart = series.chart,\n			radius,\n			pointAttr = point.pointAttr;\n\n		state = state || NORMAL_STATE; // empty string\n\n		if (\n				// already has this state\n				state === point.state ||\n				// selected points don't respond to hover\n				(point.selected && state !== SELECT_STATE) ||\n				// series' state options is disabled\n				(stateOptions[state] && stateOptions[state].enabled === false) ||\n				// point marker's state options is disabled\n				(state && (stateDisabled || (normalDisabled && !markerStateOptions.enabled)))\n\n			) {\n			return;\n		}\n\n		// apply hover styles to the existing point\n		if (point.graphic) {\n			radius = markerOptions && point.graphic.symbolName && pointAttr[state].r;\n			point.graphic.attr(merge(\n				pointAttr[state],\n				radius ? { // new symbol attributes (#507, #612)\n					x: plotX - radius,\n					y: plotY - radius,\n					width: 2 * radius,\n					height: 2 * radius\n				} : {}\n			));\n		} else {\n			// if a graphic is not applied to each point in the normal state, create a shared\n			// graphic for the hover state\n			if (state && markerStateOptions) {\n				radius = markerStateOptions.radius;\n				if (!stateMarkerGraphic) { // add\n					series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(\n						series.symbol,\n						plotX - radius,\n						plotY - radius,\n						2 * radius,\n						2 * radius\n					)\n					.attr(pointAttr[state])\n					.add(series.markerGroup);\n				\n				} else { // update\n					stateMarkerGraphic.attr({ // #1054\n						x: plotX - radius,\n						y: plotY - radius\n					});\n				}\n			}\n\n			if (stateMarkerGraphic) {\n				stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY) ? 'show' : 'hide']();\n			}\n		}\n\n		point.state = state;\n	}\n};\n\n/**\n * @classDescription The base function which all other series types inherit from. The data in the series is stored\n * in various arrays.\n *\n * - First, series.options.data contains all the original config options for\n * each point whether added by options or methods like series.addPoint.\n * - Next, series.data contains those values converted to points, but in case the series data length\n * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It\n * only contains the points that have been created on demand.\n * - Then there's series.points that contains all currently visible point objects. In case of cropping,\n * the cropped-away points are not part of this array. The series.points array starts at series.cropStart\n * compared to series.data and series.options.data. If however the series data is grouped, these can't\n * be correlated one to one.\n * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.\n * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.\n *\n * @param {Object} chart\n * @param {Object} options\n */\nvar Series = function () {};\n\nSeries.prototype = {\n\n	isCartesian: true,\n	type: 'line',\n	pointClass: Point,\n	sorted: true, // requires the data to be sorted\n	requireSorting: true,\n	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n		stroke: 'lineColor',\n		'stroke-width': 'lineWidth',\n		fill: 'fillColor',\n		r: 'radius'\n	},\n	init: function (chart, options) {\n		var series = this,\n			eventType,\n			events;\n\n		series.chart = chart;\n		series.options = options = series.setOptions(options); // merge with plotOptions\n		\n		// bind the axes\n		series.bindAxes();\n\n		// set some variables\n		extend(series, {\n			name: options.name,\n			state: NORMAL_STATE,\n			pointAttr: {},\n			visible: options.visible !== false, // true by default\n			selected: options.selected === true // false by default\n		});\n		\n		// special\n		if (useCanVG) {\n			options.animation = false;\n		}\n\n		// register event listeners\n		events = options.events;\n		for (eventType in events) {\n			addEvent(series, eventType, events[eventType]);\n		}\n		if (\n			(events && events.click) ||\n			(options.point && options.point.events && options.point.events.click) ||\n			options.allowPointSelect\n		) {\n			chart.runTrackerClick = true;\n		}\n\n		series.getColor();\n		series.getSymbol();\n\n		// set the data\n		series.setData(options.data, false);\n		\n		// Mark cartesian\n		if (series.isCartesian) {\n			chart.hasCartesianSeries = true;\n		}\n\n		// Register it in the chart\n		chart.series.push(series);\n		\n		// Sort series according to index option (#248, #1123)\n		stableSort(chart.series, function (a, b) {\n			return (a.options.index || 0) - (b.options.index || 0);\n		});\n		each(chart.series, function (series, i) {\n			series.index = i;\n			series.name = series.name || 'Series ' + (i + 1);\n		});\n	},\n	\n	/**\n	 * Set the xAxis and yAxis properties of cartesian series, and register the series\n	 * in the axis.series array\n	 */\n	bindAxes: function () {\n		var series = this,\n			seriesOptions = series.options,\n			chart = series.chart,\n			axisOptions;\n			\n		if (series.isCartesian) {\n			\n			each(['xAxis', 'yAxis'], function (AXIS) { // repeat for xAxis and yAxis\n				\n				each(chart[AXIS], function (axis) { // loop through the chart's axis objects\n					\n					axisOptions = axis.options;\n					\n					// apply if the series xAxis or yAxis option mathches the number of the \n					// axis, or if undefined, use the first axis\n					if ((seriesOptions[AXIS] === axisOptions.index) ||\n							(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {\n						\n						// register this series in the axis.series lookup\n						axis.series.push(series);\n						\n						// set this series.xAxis or series.yAxis reference\n						series[AXIS] = axis;\n						\n						// mark dirty for redraw\n						axis.isDirty = true;\n					}\n				});\n				\n			});\n		}\n	},\n\n\n	/**\n	 * Return an auto incremented x value based on the pointStart and pointInterval options.\n	 * This is only used if an x value is not given for the point that calls autoIncrement.\n	 */\n	autoIncrement: function () {\n		var series = this,\n			options = series.options,\n			xIncrement = series.xIncrement;\n\n		xIncrement = pick(xIncrement, options.pointStart, 0);\n\n		series.pointInterval = pick(series.pointInterval, options.pointInterval, 1);\n\n		series.xIncrement = xIncrement + series.pointInterval;\n		return xIncrement;\n	},\n\n	/**\n	 * Divide the series data into segments divided by null values.\n	 */\n	getSegments: function () {\n		var series = this,\n			lastNull = -1,\n			segments = [],\n			i,\n			points = series.points,\n			pointsLength = points.length;\n\n		if (pointsLength) { // no action required for []\n			\n			// if connect nulls, just remove null points\n			if (series.options.connectNulls) {\n				i = pointsLength;\n				while (i--) {\n					if (points[i].y === null) {\n						points.splice(i, 1);\n					}\n				}\n				if (points.length) {\n					segments = [points];\n				}\n				\n			// else, split on null points\n			} else {\n				each(points, function (point, i) {\n					if (point.y === null) {\n						if (i > lastNull + 1) {\n							segments.push(points.slice(lastNull + 1, i));\n						}\n						lastNull = i;\n					} else if (i === pointsLength - 1) { // last value\n						segments.push(points.slice(lastNull + 1, i + 1));\n					}\n				});\n			}\n		}\n		\n		// register it\n		series.segments = segments;\n	},\n	/**\n	 * Set the series options by merging from the options tree\n	 * @param {Object} itemOptions\n	 */\n	setOptions: function (itemOptions) {\n		var chart = this.chart,\n			chartOptions = chart.options,\n			plotOptions = chartOptions.plotOptions,\n			typeOptions = plotOptions[this.type],\n			data = itemOptions.data,\n			options;\n\n		itemOptions.data = null; // remove from merge to prevent looping over the data set\n\n		options = merge(\n			typeOptions,\n			plotOptions.series,\n			itemOptions\n		);\n		\n		// Re-insert the data array to the options and the original config (#717)\n		options.data = itemOptions.data = data;\n		\n		// the tooltip options are merged between global and series specific options\n		this.tooltipOptions = merge(chartOptions.tooltip, options.tooltip);\n		\n		// Delte marker object if not allowed (#1125)\n		if (typeOptions.marker === null) {\n			delete options.marker;\n		}\n		\n		return options;\n\n	},\n	/**\n	 * Get the series' color\n	 */\n	getColor: function () {\n		var options = this.options,\n			defaultColors = this.chart.options.colors,\n			counters = this.chart.counters;\n		this.color = options.color ||\n			(!options.colorByPoint && defaultColors[counters.color++]) || 'gray';\n		counters.wrapColor(defaultColors.length);\n	},\n	/**\n	 * Get the series' symbol\n	 */\n	getSymbol: function () {\n		var series = this,\n			seriesMarkerOption = series.options.marker,\n			chart = series.chart,\n			defaultSymbols = chart.options.symbols,\n			counters = chart.counters;\n		series.symbol = seriesMarkerOption.symbol || defaultSymbols[counters.symbol++];\n		\n		// don't substract radius in image symbols (#604)\n		if (/^url/.test(series.symbol)) {\n			seriesMarkerOption.radius = 0;\n		}\n		counters.wrapSymbol(defaultSymbols.length);\n	},\n\n	/**\n	 * Get the series' symbol in the legend. This method should be overridable to create custom \n	 * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n	 * \n	 * @param {Object} legend The legend object\n	 */\n	drawLegendSymbol: function (legend) {\n		\n		var options = this.options,\n			markerOptions = options.marker,\n			radius,\n			legendOptions = legend.options,\n			legendSymbol,\n			symbolWidth = legendOptions.symbolWidth,\n			renderer = this.chart.renderer,\n			legendItemGroup = this.legendGroup,\n			baseline = legend.baseline,\n			attr;\n			\n		// Draw the line\n		if (options.lineWidth) {\n			attr = {\n				'stroke-width': options.lineWidth\n			};\n			if (options.dashStyle) {\n				attr.dashstyle = options.dashStyle;\n			}\n			this.legendLine = renderer.path([\n				M,\n				0,\n				baseline - 4,\n				L,\n				symbolWidth,\n				baseline - 4\n			])\n			.attr(attr)\n			.add(legendItemGroup);\n		}\n		\n		// Draw the marker\n		if (markerOptions && markerOptions.enabled) {\n			radius = markerOptions.radius;\n			this.legendSymbol = legendSymbol = renderer.symbol(\n			");
        builder.append("	this.symbol,\n				(symbolWidth / 2) - radius,\n				baseline - 4 - radius,\n				2 * radius,\n				2 * radius\n			)\n			.add(legendItemGroup);\n		}\n	},\n\n	/**\n	 * Add a point dynamically after chart load time\n	 * @param {Object} options Point options as given in series.data\n	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n	 * @param {Boolean} shift If shift is true, a point is shifted off the start\n	 *    of the series as one is appended to the end.\n	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n	 *    configuration\n	 */\n	addPoint: function (options, redraw, shift, animation) {\n		var series = this,\n			seriesOptions = series.options,\n			data = series.data,\n			graph = series.graph,\n			area = series.area,\n			chart = series.chart,\n			xData = series.xData,\n			yData = series.yData,\n			currentShift = (graph && graph.shift) || 0,\n			dataOptions = seriesOptions.data,\n			point,\n			proto = series.pointClass.prototype;\n\n		setAnimation(animation, chart);\n\n		// Make graph animate sideways\n		if (graph && shift) { \n			graph.shift = currentShift + 1;\n		}\n		if (area) {\n			if (shift) { // #780\n				area.shift = currentShift + 1;\n			}\n			area.isArea = true; // needed in animation, both with and without shift\n		}\n		\n		// Optional redraw, defaults to true\n		redraw = pick(redraw, true);\n\n		// Get options and push the point to xData, yData and series.options. In series.generatePoints\n		// the Point instance will be created on demand and pushed to the series.data array.\n		point = { series: series };\n		proto.applyOptions.apply(point, [options]);\n		xData.push(point.x);\n		yData.push(proto.toYData ? proto.toYData.call(point) : point.y);\n		dataOptions.push(options);\n\n		// Generate points to be added to the legend (#1329) \n		if (seriesOptions.legendType === 'point') {\n			series.generatePoints();\n		}\n\n		// Shift the first point off the parallel arrays\n		// todo: consider series.removePoint(i) method\n		if (shift) {\n			if (data[0] && data[0].remove) {\n				data[0].remove(false);\n			} else {\n				data.shift();\n				xData.shift();\n				yData.shift();\n				dataOptions.shift();\n			}\n		}\n		series.getAttribs();\n\n		// redraw\n		series.isDirty = true;\n		series.isDirtyData = true;\n		if (redraw) {\n			chart.redraw();\n		}\n	},\n\n	/**\n	 * Replace the series data with a new set of data\n	 * @param {Object} data\n	 * @param {Object} redraw\n	 */\n	setData: function (data, redraw) {\n		var series = this,\n			oldData = series.points,\n			options = series.options,\n			initialColor = series.initialColor,\n			chart = series.chart,\n			firstPoint = null,\n			xAxis = series.xAxis,\n			i,\n			pointProto = series.pointClass.prototype;\n\n		// reset properties\n		series.xIncrement = null;\n		series.pointRange = xAxis && xAxis.categories ? 1 : options.pointRange;\n\n		if (defined(initialColor)) { // reset colors for pie\n			chart.counters.color = initialColor;\n		}\n		\n		// parallel arrays\n		var xData = [],\n			yData = [],\n			dataLength = data ? data.length : [],\n			turboThreshold = options.turboThreshold || 1000,\n			pt,\n			pointArrayMap = series.pointArrayMap,\n			valueCount = pointArrayMap && pointArrayMap.length;\n\n		// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The\n		// first value is tested, and we assume that all the rest are defined the same\n		// way. Although the 'for' loops are similar, they are repeated inside each\n		// if-else conditional for max performance.\n		if (dataLength > turboThreshold) {\n			\n			// find the first non-null point\n			i = 0;\n			while (firstPoint === null && i < dataLength) {\n				firstPoint = data[i];\n				i++;\n			}\n		\n		\n			if (isNumber(firstPoint)) { // assume all points are numbers\n				var x = pick(options.pointStart, 0),\n					pointInterval = pick(options.pointInterval, 1);\n\n				for (i = 0; i < dataLength; i++) {\n					xData[i] = x;\n					yData[i] = data[i];\n					x += pointInterval;\n				}\n				series.xIncrement = x;\n			} else if (isArray(firstPoint)) { // assume all points are arrays\n				if (valueCount) { // [x, low, high] or [x, o, h, l, c]\n					for (i = 0; i < dataLength; i++) {\n						pt = data[i];\n						xData[i] = pt[0];\n						yData[i] = pt.slice(1, valueCount + 1);\n					}\n				} else { // [x, y]\n					for (i = 0; i < dataLength; i++) {\n						pt = data[i];\n						xData[i] = pt[0];\n						yData[i] = pt[1];\n					}\n				}\n			} /* else {\n				error(12); // Highcharts expects configs to be numbers or arrays in turbo mode\n			}*/\n		} else {\n			for (i = 0; i < dataLength; i++) {\n				pt = { series: series };\n				pointProto.applyOptions.apply(pt, [data[i]]);\n				xData[i] = pt.x;\n				yData[i] = pointProto.toYData ? pointProto.toYData.call(pt) : pt.y;\n			}\n		}\n		\n		// Unsorted data is not supported by the line tooltip as well as data grouping and \n		// navigation in Stock charts (#725)\n		if (series.requireSorting && xData.length > 1 && xData[1] < xData[0]) {\n			error(15);\n		}\n\n		// Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON		\n		if (isString(yData[0])) {\n			error(14, true);\n		} \n\n		series.data = [];\n		series.options.data = data;\n		series.xData = xData;\n		series.yData = yData;\n\n		// destroy old points\n		i = (oldData && oldData.length) || 0;\n		while (i--) {\n			if (oldData[i] && oldData[i].destroy) {\n				oldData[i].destroy();\n			}\n		}\n\n		// reset minRange (#878)\n		if (xAxis) {\n			xAxis.minRange = xAxis.userMinRange;\n		}\n\n		// redraw\n		series.isDirty = series.isDirtyData = chart.isDirtyBox = true;\n		if (pick(redraw, true)) {\n			chart.redraw(false);\n		}\n	},\n\n	/**\n	 * Remove a series and optionally redraw the chart\n	 *\n	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n	 *    configuration\n	 */\n\n	remove: function (redraw, animation) {\n		var series = this,\n			chart = series.chart;\n		redraw = pick(redraw, true);\n\n		if (!series.isRemoving) {  /* prevent triggering native event in jQuery\n				(calling the remove function from the remove event) */\n			series.isRemoving = true;\n\n			// fire the event with a default handler of removing the point\n			fireEvent(series, 'remove', null, function () {\n\n\n				// destroy elements\n				series.destroy();\n\n\n				// redraw\n				chart.isDirtyLegend = chart.isDirtyBox = true;\n				if (redraw) {\n					chart.redraw(animation);\n				}\n			});\n\n		}\n		series.isRemoving = false;\n	},\n\n	/**\n	 * Process the data by cropping away unused data points if the series is longer\n	 * than the crop threshold. This saves computing time for lage series.\n	 */\n	processData: function (force) {\n		var series = this,\n			processedXData = series.xData, // copied during slice operation below\n			processedYData = series.yData,\n			dataLength = processedXData.length,\n			cropStart = 0,\n			cropEnd = dataLength,\n			cropped,\n			distance,\n			closestPointRange,\n			xAxis = series.xAxis,\n			i, // loop variable\n			options = series.options,\n			cropThreshold = options.cropThreshold,\n			isCartesian = series.isCartesian;\n\n		// If the series data or axes haven't changed, don't go through this. Return false to pass\n		// the message on to override methods like in data grouping. \n		if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\n			return false;\n		}\n\n		// optionally filter out points outside the plot area\n		if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {\n			var extremes = xAxis.getExtremes(),\n				min = extremes.min,\n				max = extremes.max;\n\n			// it's outside current extremes\n			if (processedXData[dataLength - 1] < min || processedXData[0] > max) {\n				processedXData = [];\n				processedYData = [];\n			\n			// only crop if it's actually spilling out\n			} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {\n\n				// iterate up to find slice start\n				for (i = 0; i < dataLength; i++) {\n					if (processedXData[i] >= min) {\n						cropStart = mathMax(0, i - 1);\n						break;\n					}\n				}\n				// proceed to find slice end\n				for (; i < dataLength; i++) {\n					if (processedXData[i] > max) {\n						cropEnd = i + 1;\n						break;\n					}\n					\n				}\n				processedXData = processedXData.slice(cropStart, cropEnd);\n				processedYData = processedYData.slice(cropStart, cropEnd);\n				cropped = true;\n			}\n		}\n		\n		\n		// Find the closest distance between processed points\n		for (i = processedXData.length - 1; i > 0; i--) {\n			distance = processedXData[i] - processedXData[i - 1];\n			if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {\n				closestPointRange = distance;\n			}\n		}\n		\n		// Record the properties\n		series.cropped = cropped; // undefined or true\n		series.cropStart = cropStart;\n		series.processedXData = processedXData;\n		series.processedYData = processedYData;\n		\n		if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC\n			series.pointRange = closestPointRange || 1;\n		}\n		series.closestPointRange = closestPointRange;\n		\n	},\n\n	/**\n	 * Generate the data point after the data has been processed by cropping away\n	 * unused points and optionally grouped in Highcharts Stock.\n	 */\n	generatePoints: function () {\n		var series = this,\n			options = series.options,\n			dataOptions = options.data,\n			data = series.data,\n			dataLength,\n			processedXData = series.processedXData,\n			processedYData = series.processedYData,\n			pointClass = series.pointClass,\n			processedDataLength = processedXData.length,\n			cropStart = series.cropStart || 0,\n			cursor,\n			hasGroupedData = series.hasGroupedData,\n			point,\n			points = [],\n			i;\n\n		if (!data && !hasGroupedData) {\n			var arr = [];\n			arr.length = dataOptions.length;\n			data = series.data = arr;\n		}\n\n		for (i = 0; i < processedDataLength; i++) {\n			cursor = cropStart + i;\n			if (!hasGroupedData) {\n				if (data[cursor]) {\n					point = data[cursor];\n				} else if (dataOptions[cursor] !== UNDEFINED) { // #970\n					data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);\n				}\n				points[i] = point;\n			} else {\n				// splat the y data in case of ohlc data array\n				points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));\n			}\n		}\n\n		// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when\n		// swithching view from non-grouped data to grouped data (#637)	\n		if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {\n			for (i = 0; i < dataLength; i++) {\n				if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points\n					i += processedDataLength;\n				}\n				if (data[i]) {\n					data[i].destroyElements();\n					data[i].plotX = UNDEFINED; // #1003\n				}\n			}\n		}\n\n		series.data = data;\n		series.points = points;\n	},\n\n	/**\n	 * Translate data points from raw data values to chart specific positioning data\n	 * needed later in drawPoints, drawGraph and drawTracker.\n	 */\n	translate: function () {\n		if (!this.processedXData) { // hidden series\n			this.processData();\n		}\n		this.generatePoints();\n		var series = this,\n			chart = series.chart,\n			options = series.options,\n			stacking = options.stacking,\n			xAxis = series.xAxis,\n			categories = xAxis.categories,\n			yAxis = series.yAxis,\n			points = series.points,\n			dataLength = points.length,\n			hasModifyValue = !!series.modifyValue,\n			isBottomSeries,\n			allStackSeries = yAxis.series,\n			i = allStackSeries.length,\n			placeBetween = options.pointPlacement === 'between';\n			//nextSeriesDown;\n			\n		// Is it the last visible series?\n		while (i--) {\n			if (allStackSeries[i].visible) {\n				if (allStackSeries[i] === series) { // #809\n					isBottomSeries = true;\n				}\n				break;\n			}\n		}\n		\n		// Translate each point\n		for (i = 0; i < dataLength; i++) {\n			var point = points[i],\n				xValue = point.x,\n				yValue = point.y,\n				yBottom = point.low,\n				stack = yAxis.stacks[(yValue < options.threshold ? '-' : '') + series.stackKey],\n				pointStack,\n				pointStackTotal;\n				\n			// get the plotX translation\n			//point.plotX = mathRound(xAxis.translate(xValue, 0, 0, 0, 1) * 10) / 10; // Math.round fixes #591\n			point.plotX = xAxis.translate(xValue, 0, 0, 0, 1, placeBetween); // Math.round fixes #591\n\n			// calculate the bottom y value for stacked series\n			if (stacking && series.visible && stack && stack[xValue]) {\n				pointStack = stack[xValue];\n				pointStackTotal = pointStack.total;\n				pointStack.cum = yBottom = pointStack.cum - yValue; // start from top\n				yValue = yBottom + yValue;\n				\n				if (isBottomSeries) {\n					yBottom = pick(options.threshold, yAxis.min);\n				}\n				\n				if (yAxis.isLog && yBottom <= 0) { // #1200, #1232\n					yBottom = null;\n				}\n				\n				if (stacking === 'percent') {\n					yBottom = pointStackTotal ? yBottom * 100 / pointStackTotal : 0;\n					yValue = pointStackTotal ? yValue * 100 / pointStackTotal : 0;\n				}\n\n				point.percentage = pointStackTotal ? point.y * 100 / pointStackTotal : 0;\n				point.total = point.stackTotal = pointStackTotal;\n				point.stackY = yValue;\n			}\n\n			// Set translated yBottom or remove it\n			point.yBottom = defined(yBottom) ? \n				yAxis.translate(yBottom, 0, 1, 0, 1) :\n				null;\n			\n			// general hook, used for Highstock compare mode\n			if (hasModifyValue) {\n				yValue = series.modifyValue(yValue, point);\n			}\n\n			// Set the the plotY value, reset it for redraws\n			point.plotY = (typeof yValue === 'number') ? \n				mathRound(yAxis.translate(yValue, 0, 1, 0, 1) * 10) / 10 : // Math.round fixes #591\n				UNDEFINED;\n			\n			// set client related positions for mouse tracking\n			point.clientX = chart.inverted ?\n				chart.plotHeight - point.plotX :\n				point.plotX; // for mouse tracking\n\n			// some API data\n			point.category = categories && categories[point.x] !== UNDEFINED ?\n				categories[point.x] : point.x;\n\n\n		}\n\n		// now that we have the cropped data, build the segments\n		series.getSegments();\n	},\n	/**\n	 * Memoize tooltip texts and positions\n	 */\n	setTooltipPoints: function (renew) {\n		var series = this,\n			points = [],\n			pointsLength,\n			low,\n			high,\n			xAxis = series.xAxis,\n			axisLength = xAxis ? (xAxis.tooltipLen || xAxis.len) : series.chart.plotSizeX, // tooltipLen and tooltipPosName used in polar\n			plotX = (xAxis && xAxis.tooltipPosName) || 'plotX',\n			point,\n			i,\n			tooltipPoints = []; // a lookup array for each pixel in the x dimension\n\n		// don't waste resources if tracker is disabled\n		if (series.options.enableMouseTracking === false) {\n			return;\n		}\n\n		// renew\n		if (renew) {\n			series.tooltipPoints = null;\n		}\n\n		// concat segments to overcome null values\n		each(series.segments || series.points, function (segment) {\n			points = points.concat(segment);\n		});\n\n		// Reverse the points in case the X axis is reversed\n		if (xAxis && xAxis.reversed) {\n			points = points.reverse();\n		}\n\n		// Assign each pixel position to the nearest point\n		pointsLength = points.length;\n		for (i = 0; i < pointsLength; i++) {\n			point = points[i];\n			// Set this range's low to the last range's high plus one\n			low = points[i - 1] ? high + 1 : 0;\n			// Now find the new high\n			high = points[i + 1] ?\n				mathMax(0, mathFloor((point[plotX] + (points[i + 1] ? points[i + 1][plotX] : axisLength)) / 2)) :\n				axisLength;\n\n			while (low >= 0 && low <= high) {\n				tooltipPoints[low++] = point;\n			}\n		}\n		series.tooltipPoints = tooltipPoints;\n	},\n\n	/**\n	 * Format the header of the tooltip\n	 */\n	tooltipHeaderFormatter: function (key) {\n		var series = this,\n			tooltipOptions = series.tooltipOptions,\n			xDateFormat = tooltipOptions.xDateFormat,\n			xAxis = series.xAxis,\n			isDateTime = xAxis && xAxis.options.type === 'datetime',\n			n;\n			\n		// Guess the best date format based on the closest point distance (#568)\n		if (isDateTime && !xDateFormat) {\n			for (n in timeUnits) {\n				if (timeUnits[n] >= xAxis.closestPointRange) {\n					xDateFormat = tooltipOptions.dateTimeLabelFormats[n];\n					break;\n				}	\n			}		\n		}\n		\n		return tooltipOptions.headerFormat\n			.replace('{point.key}', isDateTime && isNumber(key) ? dateFormat(xDateFormat, key) :  key)\n			.replace('{series.name}', series.name)\n			.replace('{series.color}', series.color);\n	},\n\n	/**\n	 * Series mouse over handler\n	 */\n	onMouseOver: function () {\n		var series = this,\n			chart = series.chart,\n			hoverSeries = chart.hoverSeries;\n\n		// set normal state to p");
        builder.append("revious series\n		if (hoverSeries && hoverSeries !== series) {\n			hoverSeries.onMouseOut();\n		}\n\n		// trigger the event, but to save processing time,\n		// only if defined\n		if (series.options.events.mouseOver) {\n			fireEvent(series, 'mouseOver');\n		}\n\n		// hover this\n		series.setState(HOVER_STATE);\n		chart.hoverSeries = series;\n	},\n\n	/**\n	 * Series mouse out handler\n	 */\n	onMouseOut: function () {\n		// trigger the event only if listeners exist\n		var series = this,\n			options = series.options,\n			chart = series.chart,\n			tooltip = chart.tooltip,\n			hoverPoint = chart.hoverPoint;\n\n		// trigger mouse out on the point, which must be in this series\n		if (hoverPoint) {\n			hoverPoint.onMouseOut();\n		}\n\n		// fire the mouse out event\n		if (series && options.events.mouseOut) {\n			fireEvent(series, 'mouseOut');\n		}\n\n\n		// hide the tooltip\n		if (tooltip && !options.stickyTracking && !tooltip.shared) {\n			tooltip.hide();\n		}\n\n		// set normal state\n		series.setState();\n		chart.hoverSeries = null;\n	},\n\n	/**\n	 * Animate in the series\n	 */\n	animate: function (init) {\n		var series = this,\n			chart = series.chart,\n			renderer = chart.renderer,\n			clipRect,\n			markerClipRect,\n			animation = series.options.animation,\n			clipBox = chart.clipBox,\n			inverted = chart.inverted,\n			sharedClipKey;\n\n		// Animation option is set to true\n		if (animation && !isObject(animation)) {\n			animation = defaultPlotOptions[series.type].animation;\n		}\n		sharedClipKey = '_sharedClip' + animation.duration + animation.easing;\n\n		// Initialize the animation. Set up the clipping rectangle.\n		if (init) { \n			\n			// If a clipping rectangle with the same properties is currently present in the chart, use that. \n			clipRect = chart[sharedClipKey];\n			markerClipRect = chart[sharedClipKey + 'm'];\n			if (!clipRect) {\n				chart[sharedClipKey] = clipRect = renderer.clipRect(\n					extend(clipBox, { width: 0 })\n				);\n				\n				chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(\n					-99, // include the width of the first marker\n					inverted ? -chart.plotLeft : -chart.plotTop, \n					99,\n					inverted ? chart.chartWidth : chart.chartHeight\n				);\n			}\n			series.group.clip(clipRect);\n			series.markerGroup.clip(markerClipRect);\n			series.sharedClipKey = sharedClipKey;\n\n		// Run the animation\n		} else { \n			clipRect = chart[sharedClipKey];\n			if (clipRect) {\n				clipRect.animate({\n					width: chart.plotSizeX\n				}, animation);\n				chart[sharedClipKey + 'm'].animate({\n					width: chart.plotSizeX + 99\n				}, animation);\n			}\n\n			// Delete this function to allow it only once\n			series.animate = null;\n			\n			// Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option\n			// which should be available to the user).\n			series.animationTimeout = setTimeout(function () {\n				series.afterAnimate();\n			}, animation.duration);\n		}\n	},\n	\n	/**\n	 * This runs after animation to land on the final plot clipping\n	 */\n	afterAnimate: function () {\n		var chart = this.chart,\n			sharedClipKey = this.sharedClipKey,\n			group = this.group,\n			trackerGroup = this.trackerGroup;\n			\n		if (group && this.options.clip !== false) {\n			group.clip(chart.clipRect);\n			if (trackerGroup) {\n				trackerGroup.clip(chart.clipRect); // #484\n			}\n			this.markerGroup.clip(); // no clip\n		}\n		\n		// Remove the shared clipping rectancgle when all series are shown		\n		setTimeout(function () {\n			if (sharedClipKey && chart[sharedClipKey]) {\n				chart[sharedClipKey] = chart[sharedClipKey].destroy();\n				chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();\n			}\n		}, 100);\n	},\n\n	/**\n	 * Draw the markers\n	 */\n	drawPoints: function () {\n		var series = this,\n			pointAttr,\n			points = series.points,\n			chart = series.chart,\n			plotX,\n			plotY,\n			i,\n			point,\n			radius,\n			symbol,\n			isImage,\n			graphic,\n			options = series.options,\n			seriesMarkerOptions = options.marker,\n			pointMarkerOptions,\n			enabled,\n			isInside,\n			markerGroup = series.markerGroup;\n\n		if (seriesMarkerOptions.enabled || series._hasPointMarkers) {\n			\n			i = points.length;\n			while (i--) {\n				point = points[i];\n				plotX = point.plotX;\n				plotY = point.plotY;\n				graphic = point.graphic;\n				pointMarkerOptions = point.marker || {};\n				enabled = (seriesMarkerOptions.enabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;\n				isInside = chart.isInsidePlot(plotX, plotY, chart.inverted);\n				\n				// only draw the point if y is defined\n				if (enabled && plotY !== UNDEFINED && !isNaN(plotY)) {\n\n					// shortcuts\n					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];\n					radius = pointAttr.r;\n					symbol = pick(pointMarkerOptions.symbol, series.symbol);\n					isImage = symbol.indexOf('url') === 0;\n\n					if (graphic) { // update\n						graphic\n							.attr({ // Since the marker group isn't clipped, each individual marker must be toggled\n								visibility: isInside ? (hasSVG ? 'inherit' : VISIBLE) : HIDDEN\n							})\n							.animate(extend({\n								x: plotX - radius,\n								y: plotY - radius\n							}, graphic.symbolName ? { // don't apply to image symbols #507\n								width: 2 * radius,\n								height: 2 * radius\n							} : {}));\n					} else if (isInside && (radius > 0 || isImage)) {\n						point.graphic = graphic = chart.renderer.symbol(\n							symbol,\n							plotX - radius,\n							plotY - radius,\n							2 * radius,\n							2 * radius\n						)\n						.attr(pointAttr)\n						.add(markerGroup);\n					}\n					\n				} else if (graphic) {\n					point.graphic = graphic.destroy(); // #1269\n				}\n			}\n		}\n\n	},\n\n	/**\n	 * Convert state properties from API naming conventions to SVG attributes\n	 *\n	 * @param {Object} options API options object\n	 * @param {Object} base1 SVG attribute object to inherit from\n	 * @param {Object} base2 Second level SVG attribute object to inherit from\n	 */\n	convertAttribs: function (options, base1, base2, base3) {\n		var conversion = this.pointAttrToOptions,\n			attr,\n			option,\n			obj = {};\n\n		options = options || {};\n		base1 = base1 || {};\n		base2 = base2 || {};\n		base3 = base3 || {};\n\n		for (attr in conversion) {\n			option = conversion[attr];\n			obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);\n		}\n		return obj;\n	},\n\n	/**\n	 * Get the state attributes. Each series type has its own set of attributes\n	 * that are allowed to change on a point's state change. Series wide attributes are stored for\n	 * all series, and additionally point specific attributes are stored for all\n	 * points with individual marker options. If such options are not defined for the point,\n	 * a reference to the series wide attributes is stored in point.pointAttr.\n	 */\n	getAttribs: function () {\n		var series = this,\n			normalOptions = defaultPlotOptions[series.type].marker ? series.options.marker : series.options,\n			stateOptions = normalOptions.states,\n			stateOptionsHover = stateOptions[HOVER_STATE],\n			pointStateOptionsHover,\n			seriesColor = series.color,\n			normalDefaults = {\n				stroke: seriesColor,\n				fill: seriesColor\n			},\n			points = series.points || [], // #927\n			i,\n			point,\n			seriesPointAttr = [],\n			pointAttr,\n			pointAttrToOptions = series.pointAttrToOptions,\n			hasPointSpecificOptions,\n			key;\n\n		// series type specific modifications\n		if (series.options.marker) { // line, spline, area, areaspline, scatter\n\n			// if no hover radius is given, default to normal radius + 2\n			stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + 2;\n			stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + 1;\n\n		} else { // column, bar, pie\n\n			// if no hover color is given, brighten the normal color\n			stateOptionsHover.color = stateOptionsHover.color ||\n				Color(stateOptionsHover.color || seriesColor)\n					.brighten(stateOptionsHover.brightness).get();\n		}\n\n		// general point attributes for the series normal state\n		seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);\n\n		// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius\n		each([HOVER_STATE, SELECT_STATE], function (state) {\n			seriesPointAttr[state] =\n					series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);\n		});\n\n		// set it\n		series.pointAttr = seriesPointAttr;\n\n\n		// Generate the point-specific attribute collections if specific point\n		// options are given. If not, create a referance to the series wide point\n		// attributes\n		i = points.length;\n		while (i--) {\n			point = points[i];\n			normalOptions = (point.options && point.options.marker) || point.options;\n			if (normalOptions && normalOptions.enabled === false) {\n				normalOptions.radius = 0;\n			}\n			hasPointSpecificOptions = series.options.colorByPoint; // #868\n			\n			// check if the point has specific visual options\n			if (point.options) {\n				for (key in pointAttrToOptions) {\n					if (defined(normalOptions[pointAttrToOptions[key]])) {\n						hasPointSpecificOptions = true;\n					}\n				}\n			}\n\n\n\n			// a specific marker config object is defined for the individual point:\n			// create it's own attribute collection\n			if (hasPointSpecificOptions) {\n				normalOptions = normalOptions || {};\n				pointAttr = [];\n				stateOptions = normalOptions.states || {}; // reassign for individual point\n				pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};\n\n				// Handle colors for column and pies\n				if (!series.options.marker) { // column, bar, point\n					// if no hover color is given, brighten the normal color\n					pointStateOptionsHover.color =\n						Color(pointStateOptionsHover.color || point.color)\n							.brighten(pointStateOptionsHover.brightness ||\n								stateOptionsHover.brightness).get();\n\n				}\n\n				// normal point state inherits series wide normal state\n				pointAttr[NORMAL_STATE] = series.convertAttribs(extend({\n					color: point.color // #868\n				}, normalOptions), seriesPointAttr[NORMAL_STATE]);\n\n				// inherit from point normal and series hover\n				pointAttr[HOVER_STATE] = series.convertAttribs(\n					stateOptions[HOVER_STATE],\n					seriesPointAttr[HOVER_STATE],\n					pointAttr[NORMAL_STATE]\n				);\n				// inherit from point normal and series hover\n				pointAttr[SELECT_STATE] = series.convertAttribs(\n					stateOptions[SELECT_STATE],\n					seriesPointAttr[SELECT_STATE],\n					pointAttr[NORMAL_STATE]\n				);\n\n\n\n			// no marker config object is created: copy a reference to the series-wide\n			// attribute collection\n			} else {\n				pointAttr = seriesPointAttr;\n			}\n\n			point.pointAttr = pointAttr;\n\n		}\n\n	},\n\n\n	/**\n	 * Clear DOM objects and free up memory\n	 */\n	destroy: function () {\n		var series = this,\n			chart = series.chart,\n			issue134 = /AppleWebKit\\/533/.test(userAgent),\n			destroy,\n			i,\n			data = series.data || [],\n			point,\n			prop,\n			axis;\n\n		// add event hook\n		fireEvent(series, 'destroy');\n\n		// remove all events\n		removeEvent(series);\n		\n		// erase from axes\n		each(['xAxis', 'yAxis'], function (AXIS) {\n			axis = series[AXIS];\n			if (axis) {\n				erase(axis.series, series);\n				axis.isDirty = true;\n			}\n		});\n\n		// remove legend items\n		if (series.legendItem) {\n			series.chart.legend.destroyItem(series);\n		}\n\n		// destroy all points with their elements\n		i = data.length;\n		while (i--) {\n			point = data[i];\n			if (point && point.destroy) {\n				point.destroy();\n			}\n		}\n		series.points = null;\n\n		// Clear the animation timeout if we are destroying the series during initial animation\n		clearTimeout(series.animationTimeout);\n\n		// destroy all SVGElements associated to the series\n		each(['area', 'graph', 'dataLabelsGroup', 'group', 'markerGroup', 'tracker', 'trackerGroup'], function (prop) {\n			if (series[prop]) {\n\n				// issue 134 workaround\n				destroy = issue134 && prop === 'group' ?\n					'hide' :\n					'destroy';\n\n				series[prop][destroy]();\n			}\n		});\n\n		// remove from hoverSeries\n		if (chart.hoverSeries === series) {\n			chart.hoverSeries = null;\n		}\n		erase(chart.series, series);\n\n		// clear all members\n		for (prop in series) {\n			delete series[prop];\n		}\n	},\n\n	/**\n	 * Draw the data labels\n	 */\n	drawDataLabels: function () {\n		\n		var series = this,\n			seriesOptions = series.options,\n			options = seriesOptions.dataLabels,\n			points = series.points,\n			pointOptions,\n			generalOptions,\n			str,\n			dataLabelsGroup;\n		\n		if (options.enabled || series._hasPointLabels) {\n						\n			// Process default alignment of data labels for columns\n			if (series.dlProcessOptions) {\n				series.dlProcessOptions(options);\n			}\n\n			// Create a separate group for the data labels to avoid rotation\n			dataLabelsGroup = series.plotGroup(\n				'dataLabelsGroup', \n				'data-labels', \n				series.visible ? VISIBLE : HIDDEN, \n				options.zIndex || 6\n			);\n			\n			// Make the labels for each point\n			generalOptions = options;\n			each(points, function (point) {\n				\n				var enabled,\n					dataLabel = point.dataLabel,\n					attr,\n					name,\n					rotation,\n					isNew = true;\n				\n				// Determine if each data label is enabled\n				pointOptions = point.options && point.options.dataLabels;\n				enabled = generalOptions.enabled || (pointOptions && pointOptions.enabled);\n				\n				\n				// If the point is outside the plot area, destroy it. #678, #820\n				if (dataLabel && !enabled) {\n					point.dataLabel = dataLabel.destroy();\n				\n				// Individual labels are disabled if the are explicitly disabled \n				// in the point options, or if they fall outside the plot area.\n				} else if (enabled) {\n					\n					rotation = options.rotation;\n					\n					// Create individual options structure that can be extended without \n					// affecting others\n					options = merge(generalOptions, pointOptions);\n				\n					// Get the string\n					str = options.formatter.call(point.getLabelConfig(), options);\n					\n					// Determine the color\n					options.style.color = pick(options.color, options.style.color, series.color, 'black');\n	\n					\n					// update existing label\n					if (dataLabel) {\n						// vertically centered\n						dataLabel\n							.attr({\n								text: str\n							});\n						isNew = false;\n					// create new label\n					} else if (defined(str)) {\n						attr = {\n							//align: align,\n							fill: options.backgroundColor,\n							stroke: options.borderColor,\n							'stroke-width': options.borderWidth,\n							r: options.borderRadius || 0,\n							rotation: rotation,\n							padding: options.padding,\n							zIndex: 1\n						};\n						// Remove unused attributes (#947)\n						for (name in attr) {\n							if (attr[name] === UNDEFINED) {\n								delete attr[name];\n							}\n						}\n						\n						dataLabel = point.dataLabel = series.chart.renderer[rotation ? 'text' : 'label']( // labels don't support rotation\n							str,\n							0,\n							-999,\n							null,\n							null,\n							null,\n							options.useHTML\n						)\n						.attr(attr)\n						.css(options.style)\n						.add(dataLabelsGroup)\n						.shadow(options.shadow);\n						\n					}\n					\n					// Now the data label is created and placed at 0,0, so we need to align it\n					if (dataLabel) {\n						series.alignDataLabel(point, dataLabel, options, null, isNew);\n					}\n				}\n			});\n		}\n	},\n	\n	/**\n	 * Align each individual data label\n	 */\n	alignDataLabel: function (point, dataLabel, options, alignTo, isNew) {\n		var chart = this.chart,\n			inverted = chart.inverted,\n			plotX = pick(point.plotX, -999),\n			plotY = pick(point.plotY, -999),\n			bBox = dataLabel.getBBox(),\n			alignAttr; // the final position;\n				\n		// The alignment box is a singular point\n		alignTo = extend({\n			x: inverted ? chart.plotWidth - plotY : plotX,\n			y: mathRound(inverted ? chart.plotHeight - plotX : plotY),\n			width: 0,\n			height: 0\n		}, alignTo);\n		\n		// Add the text size for alignment calculation\n		extend(options, {\n			width: bBox.width,\n			height: bBox.height\n		});\n		\n		// Allow a hook for changing alignment in the last moment, then do the alignment\n		if (options.rotation) { // Fancy box alignment isn't supported for rotated text\n			alignAttr = {\n				align: options.align,\n				x: alignTo.x + options.x + alignTo.width / 2,\n				y: alignTo.y + options.y + alignTo.height / 2\n			};\n			dataLabel[isNew ? 'attr' : 'animate'](alignAttr);\n		} else {\n			dataLabel.align(options, null, alignTo);\n			alignAttr = dataLabel.alignAttr;\n		}\n		\n		// Show or hide based on the final aligned position\n		dataLabel.attr({\n			visibility: options.crop === false || chart.isInsidePlot(alignAttr.x, alignAtt");
        builder.append("r.y) || chart.isInsidePlot(plotX, plotY, inverted) ? \n				(chart.renderer.isSVG ? 'inherit' : VISIBLE) : \n				HIDDEN\n		});\n				\n	},\n	\n	/**\n	 * Return the graph path of a segment\n	 */\n	getSegmentPath: function (segment) {		\n		var series = this,\n			segmentPath = [],\n			step = series.options.step;\n			\n		// build the segment line\n		each(segment, function (point, i) {\n			\n			var plotX = point.plotX,\n				plotY = point.plotY,\n				lastPoint;\n\n			if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object\n				segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));\n\n			} else {\n\n				// moveTo or lineTo\n				segmentPath.push(i ? L : M);\n\n				// step line?\n				if (step && i) {\n					lastPoint = segment[i - 1];\n					if (step === 'right') {\n						segmentPath.push(\n							lastPoint.plotX,\n							plotY\n						);\n						\n					} else if (step === 'center') {\n						segmentPath.push(\n							(lastPoint.plotX + plotX) / 2,\n							lastPoint.plotY,\n							(lastPoint.plotX + plotX) / 2,\n							plotY\n						);\n						\n					} else {\n						segmentPath.push(\n							plotX,\n							lastPoint.plotY\n						);\n					}\n				}\n\n				// normal line to next point\n				segmentPath.push(\n					point.plotX,\n					point.plotY\n				);\n			}\n		});\n		\n		return segmentPath;\n	},\n\n	/**\n	 * Get the graph path\n	 */\n	getGraphPath: function () {\n		var series = this,\n			graphPath = [],\n			segmentPath,\n			singlePoints = []; // used in drawTracker\n\n		// Divide into segments and build graph and area paths\n		each(series.segments, function (segment) {\n			\n			segmentPath = series.getSegmentPath(segment);\n			\n			// add the segment to the graph, or a single point for tracking\n			if (segment.length > 1) {\n				graphPath = graphPath.concat(segmentPath);\n			} else {\n				singlePoints.push(segment[0]);\n			}\n		});\n\n		// Record it for use in drawGraph and drawTracker, and return graphPath\n		series.singlePoints = singlePoints;\n		series.graphPath = graphPath;\n		\n		return graphPath;\n		\n	},\n	\n	/**\n	 * Draw the actual graph\n	 */\n	drawGraph: function () {		\n		var options = this.options,\n			graph = this.graph,\n			group = this.group,\n			color = options.lineColor || this.color,\n			lineWidth = options.lineWidth,\n			dashStyle =  options.dashStyle,\n			attribs,\n			graphPath = this.getGraphPath();\n			\n\n		// draw the graph\n		if (graph) {\n			stop(graph); // cancel running animations, #459\n			graph.animate({ d: graphPath });\n\n		} else {\n			if (lineWidth) {\n				attribs = {\n					stroke: color,\n					'stroke-width': lineWidth,\n					zIndex: 1 // #1069\n				};\n				if (dashStyle) {\n					attribs.dashstyle = dashStyle;\n				}\n\n				this.graph = this.chart.renderer.path(graphPath)\n					.attr(attribs).add(group).shadow(options.shadow);\n			}\n		}\n	},\n\n	/**\n	 * Initialize and perform group inversion on series.group and series.trackerGroup\n	 */\n	invertGroups: function () {\n		var series = this,\n			chart = series.chart;\n		\n		// A fixed size is needed for inversion to work\n		function setInvert() {			\n			var size = {\n				width: series.yAxis.len,\n				height: series.xAxis.len\n			};\n			\n			each(['group', 'trackerGroup', 'markerGroup'], function (groupName) {\n				if (series[groupName]) {\n					series[groupName].attr(size).invert();\n				}\n			});\n		}\n\n		addEvent(chart, 'resize', setInvert); // do it on resize\n		addEvent(series, 'destroy', function () {\n			removeEvent(chart, 'resize', setInvert);\n		});\n\n		// Do it now\n		setInvert(); // do it now\n		\n		// On subsequent render and redraw, just do setInvert without setting up events again\n		series.invertGroups = setInvert;\n	},\n	\n	/**\n	 * General abstraction for creating plot groups like series.group, series.trackerGroup, series.dataLabelsGroup and \n	 * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.\n	 */\n	plotGroup: function (prop, name, visibility, zIndex, parent) {\n		var group = this[prop],\n			chart = this.chart,\n			xAxis = this.xAxis,\n			yAxis = this.yAxis;\n		\n		// Generate it on first call\n		if (!group) {	\n			this[prop] = group = chart.renderer.g(name)\n				.attr({\n					visibility: visibility,\n					zIndex: zIndex || 0.1 // IE8 needs this\n				})\n				.add(parent);\n		}\n		// Place it on first and subsequent (redraw) calls\n		group.translate(\n			xAxis ? xAxis.left : chart.plotLeft, \n			yAxis ? yAxis.top : chart.plotTop\n		);\n		\n		return group;\n		\n	},\n	\n	/**\n	 * Render the graph and markers\n	 */\n	render: function () {\n		var series = this,\n			chart = series.chart,\n			group,\n			options = series.options,\n			animation = options.animation,\n			doAnimation = animation && !!series.animate,\n			visibility = series.visible ? VISIBLE : HIDDEN,\n			zIndex = options.zIndex,\n			hasRendered = series.hasRendered,\n			chartSeriesGroup = chart.seriesGroup;\n		\n		// the group\n		group = series.plotGroup(\n			'group', \n			'series', \n			visibility, \n			zIndex, \n			chartSeriesGroup\n		);\n		\n		series.markerGroup = series.plotGroup(\n			'markerGroup', \n			'markers', \n			visibility, \n			zIndex, \n			chartSeriesGroup\n		);\n		\n		// initiate the animation\n		if (doAnimation) {\n			series.animate(true);\n		}\n\n		// cache attributes for shapes\n		series.getAttribs();\n\n		// SVGRenderer needs to know this before drawing elements (#1089)\n		group.inverted = chart.inverted;\n		\n		// draw the graph if any\n		if (series.drawGraph) {\n			series.drawGraph();\n		}\n\n		// draw the points\n		series.drawPoints();\n		\n		// draw the data labels\n		series.drawDataLabels();\n\n\n		// draw the mouse tracking area\n		if (series.options.enableMouseTracking !== false) {\n			series.drawTracker();\n		}\n		\n		// Handle inverted series and tracker groups\n		if (chart.inverted) {\n			series.invertGroups();\n		}\n		\n		// Initial clipping, must be defined after inverting groups for VML\n		if (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n			group.clip(chart.clipRect);\n			if (this.trackerGroup) {\n				this.trackerGroup.clip(chart.clipRect);\n			}\n		}\n\n		// Run the animation\n		if (doAnimation) {\n			series.animate();\n		} else if (!hasRendered) {\n			series.afterAnimate();\n		}\n\n		series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n		// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n		series.hasRendered = true;\n	},\n	\n	/**\n	 * Redraw the series after an update in the axes.\n	 */\n	redraw: function () {\n		var series = this,\n			chart = series.chart,\n			wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after\n			group = series.group;\n\n		// reposition on resize\n		if (group) {\n			if (chart.inverted) {\n				group.attr({\n					width: chart.plotWidth,\n					height: chart.plotHeight\n				});\n			}\n\n			group.animate({\n				translateX: series.xAxis.left,\n				translateY: series.yAxis.top\n			});\n		}\n\n		series.translate();\n		series.setTooltipPoints(true);\n\n		series.render();\n		if (wasDirtyData) {\n			fireEvent(series, 'updatedData');\n		}\n	},\n\n	/**\n	 * Set the state of the graph\n	 */\n	setState: function (state) {\n		var series = this,\n			options = series.options,\n			graph = series.graph,\n			stateOptions = options.states,\n			lineWidth = options.lineWidth;\n\n		state = state || NORMAL_STATE;\n\n		if (series.state !== state) {\n			series.state = state;\n\n			if (stateOptions[state] && stateOptions[state].enabled === false) {\n				return;\n			}\n\n			if (state) {\n				lineWidth = stateOptions[state].lineWidth || lineWidth + 1;\n			}\n\n			if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML\n				graph.attr({ // use attr because animate will cause any other animation on the graph to stop\n					'stroke-width': lineWidth\n				}, state ? 0 : 500);\n			}\n		}\n	},\n\n	/**\n	 * Set the visibility of the graph\n	 *\n	 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,\n	 *        the visibility is toggled.\n	 */\n	setVisible: function (vis, redraw) {\n		var series = this,\n			chart = series.chart,\n			legendItem = series.legendItem,\n			seriesGroup = series.group,\n			seriesTracker = series.tracker,\n			dataLabelsGroup = series.dataLabelsGroup,\n			markerGroup = series.markerGroup,\n			showOrHide,\n			i,\n			points = series.points,\n			point,\n			ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n			oldVisibility = series.visible;\n\n		// if called without an argument, toggle visibility\n		series.visible = vis = vis === UNDEFINED ? !oldVisibility : vis;\n		showOrHide = vis ? 'show' : 'hide';\n\n		// show or hide series\n		if (seriesGroup) { // pies don't have one\n			seriesGroup[showOrHide]();\n		}\n		if (markerGroup) {\n			markerGroup[showOrHide]();\n		}\n\n		// show or hide trackers\n		if (seriesTracker) {\n			seriesTracker[showOrHide]();\n		} else if (points) {\n			i = points.length;\n			while (i--) {\n				point = points[i];\n				if (point.tracker) {\n					point.tracker[showOrHide]();\n				}\n			}\n		}\n		\n		// hide tooltip (#1361)\n		if (chart.hoverSeries === series) {\n			series.onMouseOut();\n		}\n\n\n		if (dataLabelsGroup) {\n			dataLabelsGroup[showOrHide]();\n		}\n\n		if (legendItem) {\n			chart.legend.colorizeItem(series, vis);\n		}\n\n\n		// rescale or adapt to resized chart\n		series.isDirty = true;\n		// in a stack, all other series are affected\n		if (series.options.stacking) {\n			each(chart.series, function (otherSeries) {\n				if (otherSeries.options.stacking && otherSeries.visible) {\n					otherSeries.isDirty = true;\n				}\n			});\n		}\n\n		if (ignoreHiddenSeries) {\n			chart.isDirtyBox = true;\n		}\n		if (redraw !== false) {\n			chart.redraw();\n		}\n\n		fireEvent(series, showOrHide);\n	},\n\n	/**\n	 * Show the graph\n	 */\n	show: function () {\n		this.setVisible(true);\n	},\n\n	/**\n	 * Hide the graph\n	 */\n	hide: function () {\n		this.setVisible(false);\n	},\n\n\n	/**\n	 * Set the selected state of the graph\n	 *\n	 * @param selected {Boolean} True to select the series, false to unselect. If\n	 *        UNDEFINED, the selection state is toggled.\n	 */\n	select: function (selected) {\n		var series = this;\n		// if called without an argument, toggle\n		series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;\n\n		if (series.checkbox) {\n			series.checkbox.checked = selected;\n		}\n\n		fireEvent(series, selected ? 'select' : 'unselect');\n	},\n\n	/**\n	 * Draw the tracker object that sits above all data labels and markers to\n	 * track mouse events on the graph or points. For the line type charts\n	 * the tracker uses the same graphPath, but with a greater stroke width\n	 * for better control.\n	 */\n	drawTracker: function () {\n		var series = this,\n			options = series.options,\n			trackByArea = options.trackByArea,\n			trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n			trackerPathLength = trackerPath.length,\n			chart = series.chart,\n			renderer = chart.renderer,\n			snap = chart.options.tooltip.snap,\n			tracker = series.tracker,\n			cursor = options.cursor,\n			css = cursor && { cursor: cursor },\n			singlePoints = series.singlePoints,\n			trackerGroup = this.isCartesian && this.plotGroup('trackerGroup', null, VISIBLE, options.zIndex || 1, chart.trackerGroup),\n			singlePoint,\n			i,\n			onMouseOver = function () {\n				if (chart.hoverSeries !== series) {\n					series.onMouseOver();\n				}\n			},\n			onMouseOut = function () {\n				if (!options.stickyTracking) {\n					series.onMouseOut();\n				}\n			};\n\n		// Extend end points. A better way would be to use round linecaps,\n		// but those are not clickable in VML.\n		if (trackerPathLength && !trackByArea) {\n			i = trackerPathLength + 1;\n			while (i--) {\n				if (trackerPath[i] === M) { // extend left side\n					trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);\n				}\n				if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side\n					trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);\n				}\n			}\n		}\n\n		// handle single points\n		for (i = 0; i < singlePoints.length; i++) {\n			singlePoint = singlePoints[i];\n			trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,\n				L, singlePoint.plotX + snap, singlePoint.plotY);\n		}\n		\n		\n\n		// draw the tracker\n		if (tracker) {\n			tracker.attr({ d: trackerPath });\n\n		} else { // create\n				\n			series.tracker = tracker = renderer.path(trackerPath)\n				.attr({\n					isTracker: true,\n					'stroke-linejoin': 'round', // #1225\n					visibility: series.visible ? VISIBLE : HIDDEN,\n					stroke: TRACKER_FILL,\n					fill: trackByArea ? TRACKER_FILL : NONE,\n					'stroke-width' : options.lineWidth + (trackByArea ? 0 : 2 * snap)\n				})\n				.on('mouseover', onMouseOver)\n				.on('mouseout', onMouseOut)\n				.css(css)\n				.add(trackerGroup);\n				\n			if (hasTouch) {\n				tracker.on('touchstart', onMouseOver);\n			} \n		}\n\n	}\n\n}; // end Series prototype\n\n\n/**\n * LineSeries object\n */\nvar LineSeries = extendClass(Series);\nseriesTypes.line = LineSeries;\n\n/**\n * Set the default options for area\n */\ndefaultPlotOptions.area = merge(defaultSeriesOptions, {\n	threshold: 0\n	// trackByArea: false,\n	// lineColor: null, // overrides color, but lets fillColor be unaltered\n	// fillOpacity: 0.75,\n	// fillColor: null\n});\n\n/**\n * AreaSeries object\n */\nvar AreaSeries = extendClass(Series, {\n	type: 'area',\n	\n	/**\n	 * Extend the base Series getSegmentPath method by adding the path for the area.\n	 * This path is pushed to the series.areaPath property.\n	 */\n	getSegmentPath: function (segment) {\n		\n		var segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method\n			areaSegmentPath = [].concat(segmentPath), // work on a copy for the area path\n			i,\n			options = this.options,\n			segLength = segmentPath.length;\n		\n		if (segLength === 3) { // for animation from 1 to two points\n			areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);\n		}\n		if (options.stacking && !this.closedStacks) {\n			\n			// Follow stack back. Todo: implement areaspline. A general solution could be to \n			// reverse the entire graphPath of the previous series, though may be hard with\n			// splines and with series with different extremes\n			for (i = segment.length - 1; i >= 0; i--) {\n			\n				// step line?\n				if (i < segment.length - 1 && options.step) {\n					areaSegmentPath.push(segment[i + 1].plotX, segment[i].yBottom);\n				}\n				\n				areaSegmentPath.push(segment[i].plotX, segment[i].yBottom);\n			}\n\n		} else { // follow zero line back\n			this.closeSegment(areaSegmentPath, segment);\n		}\n		this.areaPath = this.areaPath.concat(areaSegmentPath);\n		\n		return segmentPath;\n	},\n	\n	/**\n	 * Extendable method to close the segment path of an area. This is overridden in polar \n	 * charts.\n	 */\n	closeSegment: function (path, segment) {\n		var translatedThreshold = this.yAxis.getThreshold(this.options.threshold);\n		path.push(\n			L,\n			segment[segment.length - 1].plotX,\n			translatedThreshold,\n			L,\n			segment[0].plotX,\n			translatedThreshold\n		);\n	},\n	\n	/**\n	 * Draw the graph and the underlying area. This method calls the Series base\n	 * function and adds the area. The areaPath is calculated in the getSegmentPath\n	 * method called from Series.prototype.drawGraph.\n	 */\n	drawGraph: function () {\n		\n		// Define or reset areaPath\n		this.areaPath = [];\n		\n		// Call the base method\n		Series.prototype.drawGraph.apply(this);\n		\n		// Define local variables\n		var areaPath = this.areaPath,\n			options = this.options,\n			area = this.area;\n		\n		// Create or update the area\n		if (area) { // update\n			area.animate({ d: areaPath });\n\n		} else { // create\n			this.area = this.chart.renderer.path(areaPath)\n				.attr({\n					fill: pick(\n						options.fillColor,\n						Color(this.color).setOpacity(options.fillOpacity || 0.75).get()\n					),\n					zIndex: 0 // #1069\n				}).add(this.group);\n		}\n	},\n	\n	/**\n	 * Get the series' symbol in the legend\n	 * \n	 * @param {Object} legend The legend object\n	 * @param {Object} item The series (this) or point\n	 */\n	drawLegendSymbol: function (legend, item) {\n		\n		item.legendSymbol = this.chart.renderer.rect(\n			0,\n			legend.baseline - 11,\n			legend.options.symbolWidth,\n			12,\n			2\n		).attr({\n			zIndex: 3\n		}).add(item.legendGroup);		\n		\n	}\n});\n\nseriesTypes.area = AreaSeries;/**\n * Set the default options for spline\n */\ndefaultPlotOptions.spline = merge(defaultSeriesOptions);\n\n/**\n * SplineSeries object\n */\nvar SplineSeries = extendClass(Series, {\n	type: 'spline',\n\n	/**\n	 * Get the spline segment from a given point's previous neighbour to the given point\n	 */\n	getPointSpline: function (segment, point, i) {\n		var smoothing = 1.5, // 1 means contro");
        builder.append("l points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc\n			denom = smoothing + 1,\n			plotX = point.plotX,\n			plotY = point.plotY,\n			lastPoint = segment[i - 1],\n			nextPoint = segment[i + 1],\n			leftContX,\n			leftContY,\n			rightContX,\n			rightContY,\n			ret;\n\n		// find control points\n		if (lastPoint && nextPoint) {\n		\n			var lastX = lastPoint.plotX,\n				lastY = lastPoint.plotY,\n				nextX = nextPoint.plotX,\n				nextY = nextPoint.plotY,\n				correction;\n\n			leftContX = (smoothing * plotX + lastX) / denom;\n			leftContY = (smoothing * plotY + lastY) / denom;\n			rightContX = (smoothing * plotX + nextX) / denom;\n			rightContY = (smoothing * plotY + nextY) / denom;\n\n			// have the two control points make a straight line through main point\n			correction = ((rightContY - leftContY) * (rightContX - plotX)) /\n				(rightContX - leftContX) + plotY - rightContY;\n\n			leftContY += correction;\n			rightContY += correction;\n\n			// to prevent false extremes, check that control points are between\n			// neighbouring points' y values\n			if (leftContY > lastY && leftContY > plotY) {\n				leftContY = mathMax(lastY, plotY);\n				rightContY = 2 * plotY - leftContY; // mirror of left control point\n			} else if (leftContY < lastY && leftContY < plotY) {\n				leftContY = mathMin(lastY, plotY);\n				rightContY = 2 * plotY - leftContY;\n			}\n			if (rightContY > nextY && rightContY > plotY) {\n				rightContY = mathMax(nextY, plotY);\n				leftContY = 2 * plotY - rightContY;\n			} else if (rightContY < nextY && rightContY < plotY) {\n				rightContY = mathMin(nextY, plotY);\n				leftContY = 2 * plotY - rightContY;\n			}\n\n			// record for drawing in next point\n			point.rightContX = rightContX;\n			point.rightContY = rightContY;\n\n		}\n		\n		// Visualize control points for debugging\n		/*\n		if (leftContX) {\n			this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)\n				.attr({\n					stroke: 'red',\n					'stroke-width': 1,\n					fill: 'none'\n				})\n				.add();\n			this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,\n				'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n				.attr({\n					stroke: 'red',\n					'stroke-width': 1\n				})\n				.add();\n			this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)\n				.attr({\n					stroke: 'green',\n					'stroke-width': 1,\n					fill: 'none'\n				})\n				.add();\n			this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,\n				'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n				.attr({\n					stroke: 'green',\n					'stroke-width': 1\n				})\n				.add();\n		}\n		// */\n\n		// moveTo or lineTo\n		if (!i) {\n			ret = [M, plotX, plotY];\n		} else { // curve from last point to this\n			ret = [\n				'C',\n				lastPoint.rightContX || lastPoint.plotX,\n				lastPoint.rightContY || lastPoint.plotY,\n				leftContX || plotX,\n				leftContY || plotY,\n				plotX,\n				plotY\n			];\n			lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later\n		}\n		return ret;\n	}\n});\nseriesTypes.spline = SplineSeries;\n\n/**\n * Set the default options for areaspline\n */\ndefaultPlotOptions.areaspline = merge(defaultPlotOptions.area);\n\n/**\n * AreaSplineSeries object\n */\nvar areaProto = AreaSeries.prototype,\n	AreaSplineSeries = extendClass(SplineSeries, {\n		type: 'areaspline',\n		closedStacks: true, // instead of following the previous graph back, follow the threshold back\n		\n		// Mix in methods from the area series\n		getSegmentPath: areaProto.getSegmentPath,\n		closeSegment: areaProto.closeSegment,\n		drawGraph: areaProto.drawGraph\n	});\nseriesTypes.areaspline = AreaSplineSeries;\n\n/**\n * Set the default options for column\n */\ndefaultPlotOptions.column = merge(defaultSeriesOptions, {\n	borderColor: '#FFFFFF',\n	borderWidth: 1,\n	borderRadius: 0,\n	//colorByPoint: undefined,\n	groupPadding: 0.2,\n	//grouping: true,\n	marker: null, // point options are specified in the base options\n	pointPadding: 0.1,\n	//pointWidth: null,\n	minPointLength: 0,\n	cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes\n	pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories\n	states: {\n		hover: {\n			brightness: 0.1,\n			shadow: false\n		},\n		select: {\n			color: '#C0C0C0',\n			borderColor: '#000000',\n			shadow: false\n		}\n	},\n	dataLabels: {\n		align: null, // auto\n		verticalAlign: null, // auto\n		y: null\n	},\n	threshold: 0\n});\n\n/**\n * ColumnSeries object\n */\nvar ColumnSeries = extendClass(Series, {\n	type: 'column',\n	tooltipOutsidePlot: true,\n	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n		stroke: 'borderColor',\n		'stroke-width': 'borderWidth',\n		fill: 'color',\n		r: 'borderRadius'\n	},\n	\n	/**\n	 * Initialize the series\n	 */\n	init: function () {\n		Series.prototype.init.apply(this, arguments);\n\n		var series = this,\n			chart = series.chart;\n\n		// if the series is added dynamically, force redraw of other\n		// series affected by a new column\n		if (chart.hasRendered) {\n			each(chart.series, function (otherSeries) {\n				if (otherSeries.type === series.type) {\n					otherSeries.isDirty = true;\n				}\n			});\n		}\n	},\n\n	/**\n	 * Translate each point to the plot area coordinate system and find shape positions\n	 */\n	translate: function () {\n		var series = this,\n			chart = series.chart,\n			options = series.options,\n			stacking = options.stacking,\n			borderWidth = options.borderWidth,\n			columnCount = 0,\n			xAxis = series.xAxis,\n			yAxis = series.yAxis,\n			reversedXAxis = xAxis.reversed,\n			stackGroups = {},\n			stackKey,\n			columnIndex;\n\n		Series.prototype.translate.apply(series);\n\n		// Get the total number of column type series.\n		// This is called on every series. Consider moving this logic to a\n		// chart.orderStacks() function and call it on init, addSeries and removeSeries\n		if (options.grouping === false) {\n			columnCount = 1;\n		} else {\n			each(chart.series, function (otherSeries) {\n				var otherOptions = otherSeries.options;\n				if (otherSeries.type === series.type && otherSeries.visible &&\n						series.options.group === otherOptions.group) { // used in Stock charts navigator series\n					if (otherOptions.stacking) {\n						stackKey = otherSeries.stackKey;\n						if (stackGroups[stackKey] === UNDEFINED) {\n							stackGroups[stackKey] = columnCount++;\n						}\n						columnIndex = stackGroups[stackKey];\n					} else if (otherOptions.grouping !== false) { // #1162\n						columnIndex = columnCount++;\n					}\n					otherSeries.columnIndex = columnIndex;\n				}\n			});\n		}\n\n		// calculate the width and position of each column based on\n		// the number of column series in the plot, the groupPadding\n		// and the pointPadding options\n		var points = series.points,\n			categoryWidth = mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || 1),\n			groupPadding = categoryWidth * options.groupPadding,\n			groupWidth = categoryWidth - 2 * groupPadding,\n			pointOffsetWidth = groupWidth / columnCount,\n			optionPointWidth = options.pointWidth,\n			pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :\n				pointOffsetWidth * options.pointPadding,\n			pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), // exact point width, used in polar charts\n			barW = mathCeil(mathMax(pointWidth, 1 + 2 * borderWidth)), // rounded and postprocessed for border width\n			colIndex = (reversedXAxis ? \n				columnCount - (series.columnIndex || 0) : // #1251\n				series.columnIndex) || 0,\n			pointXOffset = pointPadding + (groupPadding + colIndex *\n				pointOffsetWidth - (categoryWidth / 2)) *\n				(reversedXAxis ? -1 : 1),\n			threshold = options.threshold,\n			translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),\n			minPointLength = pick(options.minPointLength, 5);\n\n		// record the new values\n		each(points, function (point) {\n			var plotY = mathMin(mathMax(-999, point.plotY), yAxis.len + 999), // Don't draw too far outside plot area (#1303)\n				yBottom = pick(point.yBottom, translatedThreshold),\n				barX = point.plotX + pointXOffset,\n				barY = mathCeil(mathMin(plotY, yBottom)),\n				barH = mathCeil(mathMax(plotY, yBottom) - barY),\n				stack = yAxis.stacks[(point.y < 0 ? '-' : '') + series.stackKey],\n				shapeArgs;\n\n			// Record the offset'ed position and width of the bar to be able to align the stacking total correctly\n			if (stacking && series.visible && stack && stack[point.x]) {\n				stack[point.x].setOffset(pointXOffset, barW);\n			}\n\n			// handle options.minPointLength\n			if (mathAbs(barH) < minPointLength) {\n				if (minPointLength) {\n					barH = minPointLength;\n					barY =\n						mathAbs(barY - translatedThreshold) > minPointLength ? // stacked\n							yBottom - minPointLength : // keep position\n							translatedThreshold - (plotY <= translatedThreshold ? minPointLength : 0);\n				}\n			}\n\n			point.barX = barX;\n			point.pointWidth = pointWidth;\n\n			// create shape type and shape args that are reused in drawPoints and drawTracker\n			point.shapeType = 'rect';\n			point.shapeArgs = shapeArgs = chart.renderer.Element.prototype.crisp.call(0, borderWidth, barX, barY, barW, barH); \n			\n			if (borderWidth % 2) { // correct for shorting in crisp method, visible in stacked columns with 1px border\n				shapeArgs.y -= 1;\n				shapeArgs.height += 1;\n			}\n\n			// make small columns responsive to mouse\n			point.trackerArgs = mathAbs(barH) < 3 && merge(point.shapeArgs, {\n				height: 6,\n				y: barY - 3\n			});\n		});\n\n	},\n\n	getSymbol: noop,\n	\n	/**\n	 * Use a solid rectangle like the area series types\n	 */\n	drawLegendSymbol: AreaSeries.prototype.drawLegendSymbol,\n	\n	\n	/**\n	 * Columns have no graph\n	 */\n	drawGraph: noop,\n\n	/**\n	 * Draw the columns. For bars, the series.group is rotated, so the same coordinates\n	 * apply for columns and bars. This method is inherited by scatter series.\n	 *\n	 */\n	drawPoints: function () {\n		var series = this,\n			options = series.options,\n			renderer = series.chart.renderer,\n			shapeArgs;\n\n\n		// draw the columns\n		each(series.points, function (point) {\n			var plotY = point.plotY,\n				graphic = point.graphic;\n			if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {\n				shapeArgs = point.shapeArgs;\n				if (graphic) { // update\n					stop(graphic);\n					graphic.animate(merge(shapeArgs));\n\n				} else {\n					point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n						.attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE])\n						.add(series.group)\n						.shadow(options.shadow, null, options.stacking && !options.borderRadius);\n				}\n\n			} else if (graphic) {\n				point.graphic = graphic.destroy(); // #1269\n			}\n		});\n	},\n	/**\n	 * Draw the individual tracker elements.\n	 * This method is inherited by pie charts too.\n	 */\n	drawTracker: function () {\n		var series = this,\n			chart = series.chart,\n			renderer = chart.renderer,\n			shapeArgs,\n			tracker,\n			trackerLabel = +new Date(),\n			options = series.options,\n			cursor = options.cursor,\n			css = cursor && { cursor: cursor },\n			trackerGroup = series.isCartesian && series.plotGroup('trackerGroup', null, VISIBLE, options.zIndex || 1, chart.trackerGroup),\n			rel,\n			plotY,\n			validPlotY,\n			points = series.points,\n			point,\n			i = points.length,\n			onMouseOver = function (event) {\n				rel = event.relatedTarget || event.fromElement;\n				if (chart.hoverSeries !== series && attr(rel, 'isTracker') !== trackerLabel) {\n					series.onMouseOver();\n				}\n				points[event.target._i].onMouseOver();\n			},\n			onMouseOut = function (event) {\n				if (!options.stickyTracking) {\n					rel = event.relatedTarget || event.toElement;\n					if (attr(rel, 'isTracker') !== trackerLabel) {\n						series.onMouseOut();\n					}\n				}\n			};\n			\n		while (i--) {\n			point = points[i];\n			tracker = point.tracker;\n			shapeArgs = point.trackerArgs || point.shapeArgs;\n			plotY = point.plotY;\n			validPlotY = !series.isCartesian || (plotY !== UNDEFINED && !isNaN(plotY));\n			delete shapeArgs.strokeWidth;\n			if (point.y !== null && validPlotY) {\n				if (tracker) {// update\n					tracker.attr(shapeArgs);\n\n				} else {\n					point.tracker = tracker =\n						renderer[point.shapeType](shapeArgs)\n						.attr({\n							isTracker: trackerLabel,\n							fill: TRACKER_FILL,\n							visibility: series.visible ? VISIBLE : HIDDEN\n						})\n						.on('mouseover', onMouseOver)\n						.on('mouseout', onMouseOut)\n						.css(css)\n						.add(point.group || trackerGroup); // pies have point group - see issue #118\n						\n					if (hasTouch) {\n						tracker.on('touchstart', onMouseOver);\n					}\n				}\n				tracker.element._i = i;\n			}\n		}\n	},\n	\n	/** \n	 * Override the basic data label alignment by adjusting for the position of the column\n	 */\n	alignDataLabel: function (point, dataLabel, options,  alignTo, isNew) {\n		var chart = this.chart,\n			inverted = chart.inverted,\n			below = point.below || (point.plotY > pick(this.translatedThreshold, chart.plotSizeY)),\n			inside = (this.options.stacking || options.inside); // draw it inside the box?\n		\n		// Align to the column itself, or the top of it\n		if (point.shapeArgs) { // Area range uses this method but not alignTo\n			alignTo = merge(point.shapeArgs);\n			if (inverted) {\n				alignTo = {\n					x: chart.plotWidth - alignTo.y - alignTo.height,\n					y: chart.plotHeight - alignTo.x - alignTo.width,\n					width: alignTo.height,\n					height: alignTo.width\n				};\n			}\n				\n			// Compute the alignment box\n			if (!inside) {\n				if (inverted) {\n					alignTo.x += below ? 0 : alignTo.width;\n					alignTo.width = 0;\n				} else {\n					alignTo.y += below ? alignTo.height : 0;\n					alignTo.height = 0;\n				}\n			}\n		}\n		\n		// When alignment is undefined (typically columns and bars), display the individual \n		// point below or above the point depending on the threshold\n		options.align = pick(\n			options.align, \n			!inverted || inside ? 'center' : below ? 'right' : 'left'\n		);\n		options.verticalAlign = pick(\n			options.verticalAlign, \n			inverted || inside ? 'middle' : below ? 'top' : 'bottom'\n		);\n		\n		// Call the parent method\n		Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n	},\n\n\n	/**\n	 * Animate the column heights one by one from zero\n	 * @param {Boolean} init Whether to initialize the animation or run it\n	 */\n	animate: function (init) {\n		var series = this,\n			points = series.points,\n			options = series.options;\n\n		if (!init) { // run the animation\n			/*\n			 * Note: Ideally the animation should be initialized by calling\n			 * series.group.hide(), and then calling series.group.show()\n			 * after the animation was started. But this rendered the shadows\n			 * invisible in IE8 standards mode. If the columns flicker on large\n			 * datasets, this is the cause.\n			 */\n\n			each(points, function (point) {\n				var graphic = point.graphic,\n					shapeArgs = point.shapeArgs,\n					yAxis = series.yAxis,\n					threshold = options.threshold;\n\n				if (graphic) {\n					// start values\n					graphic.attr({\n						height: 0,\n						y: defined(threshold) ? \n							yAxis.getThreshold(threshold) :\n							yAxis.translate(yAxis.getExtremes().min, 0, 1, 0, 1)\n					});\n\n					// animate\n					graphic.animate({\n						height: shapeArgs.height,\n						y: shapeArgs.y\n					}, options.animation);\n				}\n			});\n\n\n			// delete this function to allow it only once\n			series.animate = null;\n		}\n\n	},\n	\n	/**\n	 * Remove this series from the chart\n	 */\n	remove: function () {\n		var series = this,\n			chart = series.chart;\n\n		// column and bar series affects other series of the same type\n		// as they are either stacked or grouped\n		if (chart.hasRendered) {\n			each(chart.series, function (otherSeries) {\n				if (otherSeries.type === series.type) {\n					otherSeries.isDirty = true;\n				}\n			});\n		}\n\n		Series.prototype.remove.apply(series, arguments);\n	}\n});\nseriesTypes.column = ColumnSeries;\n/**\n * Set the default options for bar\n */\ndefaultPlotOptions.bar = merge(defaultPlotOptions.column);\n/**\n * The Bar series class\n */\nvar BarSeries = extendClass(ColumnSeries, {\n	type: 'bar',\n	inverted: true\n});\nseriesTypes.bar = BarSeries;\n\n/**\n * Set the default options for scatter\n */\ndefaultPlotOptions.scatter = merge(defaultSeriesOptions, {\n	lineWidth: 0,\n	states: {\n		hover: {\n			lineWidth: 0\n		}\n	},\n	tooltip: {\n		headerFormat: '<span style=\"font-size: 10px; color");
        builder.append(":{series.color}\">{series.name}</span><br/>',\n		pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n	}\n});\n\n/**\n * The scatter series class\n */\nvar ScatterSeries = extendClass(Series, {\n	type: 'scatter',\n	sorted: false,\n	requireSorting: false,\n	/**\n	 * Extend the base Series' translate method by adding shape type and\n	 * arguments for the point trackers\n	 */\n	translate: function () {\n		var series = this;\n\n		Series.prototype.translate.apply(series);\n\n		each(series.points, function (point) {\n			point.shapeType = 'circle';\n			point.shapeArgs = {\n				x: point.plotX,\n				y: point.plotY,\n				r: series.chart.options.tooltip.snap\n			};\n		});\n	},\n\n	/**\n	 * Add tracking event listener to the series group, so the point graphics\n	 * themselves act as trackers\n	 */\n	drawTracker: function () {\n		var series = this,\n			cursor = series.options.cursor,\n			css = cursor && { cursor: cursor },\n			points = series.points,\n			i = points.length,\n			graphic,\n			markerGroup = series.markerGroup,\n			onMouseOver = function (e) {\n				series.onMouseOver();\n				if (e.target._i !== UNDEFINED) { // undefined on graph in scatterchart\n					points[e.target._i].onMouseOver();\n				}\n			},\n			onMouseOut = function () {\n				if (!series.options.stickyTracking) {\n					series.onMouseOut();\n				}\n			};\n\n		// Set an expando property for the point index, used below\n		while (i--) {\n			graphic = points[i].graphic;\n			if (graphic) { // doesn't exist for null points\n				graphic.element._i = i; \n			}\n		}\n		\n		// Add the event listeners, we need to do this only once\n		if (!series._hasTracking) {\n			markerGroup\n				.attr({\n					isTracker: true\n				})\n				.on('mouseover', onMouseOver)\n				.on('mouseout', onMouseOut)\n				.css(css);\n			if (hasTouch) {\n				markerGroup.on('touchstart', onMouseOver);\n			}\n			\n		} else {\n			series._hasTracking = true;\n		}\n	},\n	\n	setTooltipPoints: noop\n});\nseriesTypes.scatter = ScatterSeries;\n\n/**\n * Set the default options for pie\n */\ndefaultPlotOptions.pie = merge(defaultSeriesOptions, {\n	borderColor: '#FFFFFF',\n	borderWidth: 1,\n	center: ['50%', '50%'],\n	colorByPoint: true, // always true for pies\n	dataLabels: {\n		// align: null,\n		// connectorWidth: 1,\n		// connectorColor: point.color,\n		// connectorPadding: 5,\n		distance: 30,\n		enabled: true,\n		formatter: function () {\n			return this.point.name;\n		}\n		// softConnector: true,\n		//y: 0\n	},\n	//innerSize: 0,\n	legendType: 'point',\n	marker: null, // point options are specified in the base options\n	size: '75%',\n	showInLegend: false,\n	slicedOffset: 10,\n	states: {\n		hover: {\n			brightness: 0.1,\n			shadow: false\n		}\n	}\n});\n\n/**\n * Extended point object for pies\n */\nvar PiePoint = extendClass(Point, {\n	/**\n	 * Initiate the pie slice\n	 */\n	init: function () {\n\n		Point.prototype.init.apply(this, arguments);\n\n		var point = this,\n			toggleSlice;\n\n		//visible: options.visible !== false,\n		extend(point, {\n			visible: point.visible !== false,\n			name: pick(point.name, 'Slice')\n		});\n\n		// add event listener for select\n		toggleSlice = function () {\n			point.slice();\n		};\n		addEvent(point, 'select', toggleSlice);\n		addEvent(point, 'unselect', toggleSlice);\n\n		return point;\n	},\n\n	/**\n	 * Toggle the visibility of the pie slice\n	 * @param {Boolean} vis Whether to show the slice or not. If undefined, the\n	 *    visibility is toggled\n	 */\n	setVisible: function (vis) {\n		var point = this,\n			series = point.series,\n			chart = series.chart,\n			tracker = point.tracker,\n			dataLabel = point.dataLabel,\n			connector = point.connector,\n			shadowGroup = point.shadowGroup,\n			method;\n\n		// if called without an argument, toggle visibility\n		point.visible = vis = vis === UNDEFINED ? !point.visible : vis;\n\n		method = vis ? 'show' : 'hide';\n\n		point.group[method]();\n		if (tracker) {\n			tracker[method]();\n		}\n		if (dataLabel) {\n			dataLabel[method]();\n		}\n		if (connector) {\n			connector[method]();\n		}\n		if (shadowGroup) {\n			shadowGroup[method]();\n		}\n		if (point.legendItem) {\n			chart.legend.colorizeItem(point, vis);\n		}\n		\n		// Handle ignore hidden slices\n		if (!series.isDirty && series.options.ignoreHiddenPoint) {\n			series.isDirty = true;\n			chart.redraw();\n		}\n	},\n\n	/**\n	 * Set or toggle whether the slice is cut out from the pie\n	 * @param {Boolean} sliced When undefined, the slice state is toggled\n	 * @param {Boolean} redraw Whether to redraw the chart. True by default.\n	 */\n	slice: function (sliced, redraw, animation) {\n		var point = this,\n			series = point.series,\n			chart = series.chart,\n			slicedTranslation = point.slicedTranslation,\n			translation;\n\n		setAnimation(animation, chart);\n\n		// redraw is true by default\n		redraw = pick(redraw, true);\n\n		// if called without an argument, toggle\n		sliced = point.sliced = defined(sliced) ? sliced : !point.sliced;\n\n		translation = {\n			translateX: (sliced ? slicedTranslation[0] : chart.plotLeft),\n			translateY: (sliced ? slicedTranslation[1] : chart.plotTop)\n		};\n		point.group.animate(translation);\n		if (point.shadowGroup) {\n			point.shadowGroup.animate(translation);\n		}\n\n	}\n});\n\n/**\n * The Pie series class\n */\nvar PieSeries = {\n	type: 'pie',\n	isCartesian: false,\n	pointClass: PiePoint,\n	requireSorting: false,\n	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n		stroke: 'borderColor',\n		'stroke-width': 'borderWidth',\n		fill: 'color'\n	},\n\n	/**\n	 * Pies have one color each point\n	 */\n	getColor: function () {\n		// record first color for use in setData\n		this.initialColor = this.chart.counters.color;\n	},\n\n	/**\n	 * Animate the pies in\n	 */\n	animate: function () {\n		var series = this,\n			points = series.points,\n			startAngleRad = series.startAngleRad;\n\n		each(points, function (point) {\n			var graphic = point.graphic,\n				args = point.shapeArgs;\n\n			if (graphic) {\n				// start values\n				graphic.attr({\n					r: series.center[3] / 2, // animate from inner radius (#779)\n					start: startAngleRad,\n					end: startAngleRad\n				});\n\n				// animate\n				graphic.animate({\n					r: args.r,\n					start: args.start,\n					end: args.end\n				}, series.options.animation);\n			}\n		});\n\n		// delete this function to allow it only once\n		series.animate = null;\n\n	},\n\n	/**\n	 * Extend the basic setData method by running processData and generatePoints immediately,\n	 * in order to access the points from the legend.\n	 */\n	setData: function (data, redraw) {\n		Series.prototype.setData.call(this, data, false);\n		this.processData();\n		this.generatePoints();\n		if (pick(redraw, true)) {\n			this.chart.redraw();\n		} \n	},\n	\n	/**\n	 * Get the center of the pie based on the size and center options relative to the  \n	 * plot area. Borrowed by the polar and gauge series types.\n	 */\n	getCenter: function () {\n		\n		var options = this.options,\n			chart = this.chart,\n			plotWidth = chart.plotWidth,\n			plotHeight = chart.plotHeight,\n			positions = options.center.concat([options.size, options.innerSize || 0]),\n			smallestSize = mathMin(plotWidth, plotHeight),\n			isPercent;			\n		\n		return map(positions, function (length, i) {\n\n			isPercent = /%$/.test(length);\n			return isPercent ?\n				// i == 0: centerX, relative to width\n				// i == 1: centerY, relative to height\n				// i == 2: size, relative to smallestSize\n				// i == 4: innerSize, relative to smallestSize\n				[plotWidth, plotHeight, smallestSize, smallestSize][i] *\n					pInt(length) / 100 :\n				length;\n		});\n	},\n	\n	/**\n	 * Do translation for pie slices\n	 */\n	translate: function () {\n		this.generatePoints();\n		\n		var total = 0,\n			series = this,\n			cumulative = 0,\n			precision = 1000, // issue #172\n			options = series.options,\n			slicedOffset = options.slicedOffset,\n			connectorOffset = slicedOffset + options.borderWidth,\n			positions,\n			chart = series.chart,\n			start,\n			end,\n			angle,\n			startAngleRad = series.startAngleRad = mathPI / 180 * ((options.startAngle || 0) % 360 - 90),\n			points = series.points,\n			circ = 2 * mathPI,\n			fraction,\n			radiusX, // the x component of the radius vector for a given point\n			radiusY,\n			labelDistance = options.dataLabels.distance,\n			ignoreHiddenPoint = options.ignoreHiddenPoint,\n			i,\n			len = points.length,\n			point;\n\n		// get positions - either an integer or a percentage string must be given\n		series.center = positions = series.getCenter();\n\n		// utility for getting the x value from a given y, used for anticollision logic in data labels\n		series.getX = function (y, left) {\n\n			angle = math.asin((y - positions[1]) / (positions[2] / 2 + labelDistance));\n\n			return positions[0] +\n				(left ? -1 : 1) *\n				(mathCos(angle) * (positions[2] / 2 + labelDistance));\n		};\n\n		// get the total sum\n		for (i = 0; i < len; i++) {\n			point = points[i];\n			total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;\n		}\n\n		// Calculate the geometry for each point\n		for (i = 0; i < len; i++) {\n			\n			point = points[i];\n			\n			// set start and end angle\n			fraction = total ? point.y / total : 0;\n			start = mathRound((startAngleRad + (cumulative * circ)) * precision) / precision;\n			if (!ignoreHiddenPoint || point.visible) {\n				cumulative += fraction;\n			}\n			end = mathRound((startAngleRad + (cumulative * circ)) * precision) / precision;\n\n			// set the shape\n			point.shapeType = 'arc';\n			point.shapeArgs = {\n				x: positions[0],\n				y: positions[1],\n				r: positions[2] / 2,\n				innerR: positions[3] / 2,\n				start: start,\n				end: end\n			};\n\n			// center for the sliced out slice\n			angle = (end + start) / 2;\n			if (angle > 0.75 * circ) {\n				angle -= 2 * mathPI;\n			}\n			point.slicedTranslation = map([\n				mathCos(angle) * slicedOffset + chart.plotLeft,\n				mathSin(angle) * slicedOffset + chart.plotTop\n			], mathRound);\n\n			// set the anchor point for tooltips\n			radiusX = mathCos(angle) * positions[2] / 2;\n			radiusY = mathSin(angle) * positions[2] / 2;\n			point.tooltipPos = [\n				positions[0] + radiusX * 0.7,\n				positions[1] + radiusY * 0.7\n			];\n			\n			point.half = angle < circ / 4 ? 0 : 1;\n			point.angle = angle;\n\n			// set the anchor point for data labels\n			point.labelPos = [\n				positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector\n				positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a\n				positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie\n				positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a\n				positions[0] + radiusX, // landing point for connector\n				positions[1] + radiusY, // a/a\n				labelDistance < 0 ? // alignment\n					'center' :\n					point.half ? 'right' : 'left', // alignment\n				angle // center angle\n			];\n			\n			// API properties\n			point.percentage = fraction * 100;\n			point.total = total;\n\n		}\n\n\n		this.setTooltipPoints();\n	},\n\n	/**\n	 * Render the slices\n	 */\n	render: function () {\n		var series = this;\n\n		// cache attributes for shapes\n		series.getAttribs();\n\n		this.drawPoints();\n\n		// draw the mouse tracking area\n		if (series.options.enableMouseTracking !== false) {\n			series.drawTracker();\n		}\n\n		this.drawDataLabels();\n\n		if (series.options.animation && series.animate) {\n			series.animate();\n		}\n\n		// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n		series.isDirty = false; // means data is in accordance with what you see\n	},\n\n	/**\n	 * Draw the data points\n	 */\n	drawPoints: function () {\n		var series = this,\n			chart = series.chart,\n			renderer = chart.renderer,\n			groupTranslation,\n			//center,\n			graphic,\n			group,\n			shadow = series.options.shadow,\n			shadowGroup,\n			shapeArgs;\n\n		// draw the slices\n		each(series.points, function (point) {\n			graphic = point.graphic;\n			shapeArgs = point.shapeArgs;\n			group = point.group;\n			shadowGroup = point.shadowGroup;\n\n			// put the shadow behind all points\n			if (shadow && !shadowGroup) {\n				shadowGroup = point.shadowGroup = renderer.g('shadow')\n					.attr({ zIndex: 4 })\n					.add();\n			}\n\n			// create the group the first time\n			if (!group) {\n				group = point.group = renderer.g('point')\n					.attr({ zIndex: 5 })\n					.add();\n			}\n\n			// if the point is sliced, use special translation, else use plot area traslation\n			groupTranslation = point.sliced ? point.slicedTranslation : [chart.plotLeft, chart.plotTop];\n			group.translate(groupTranslation[0], groupTranslation[1]);\n			if (shadowGroup) {\n				shadowGroup.translate(groupTranslation[0], groupTranslation[1]);\n			}\n\n			// draw the slice\n			if (graphic) {\n				graphic.animate(shapeArgs);\n			} else {\n				point.graphic = graphic = renderer.arc(shapeArgs)\n					.setRadialReference(series.center)\n					.attr(extend(\n						point.pointAttr[NORMAL_STATE],\n						{ 'stroke-linejoin': 'round' }\n					))\n					.add(point.group)\n					.shadow(shadow, shadowGroup);\n				\n			}\n\n			// detect point specific visibility\n			if (point.visible === false) {\n				point.setVisible(false);\n			}\n\n		});\n\n	},\n\n	/**\n	 * Override the base drawDataLabels method by pie specific functionality\n	 */\n	drawDataLabels: function () {\n		var series = this,\n			data = series.data,\n			point,\n			chart = series.chart,\n			options = series.options.dataLabels,\n			connectorPadding = pick(options.connectorPadding, 10),\n			connectorWidth = pick(options.connectorWidth, 1),\n			connector,\n			connectorPath,\n			softConnector = pick(options.softConnector, true),\n			distanceOption = options.distance,\n			seriesCenter = series.center,\n			radius = seriesCenter[2] / 2,\n			centerY = seriesCenter[1],\n			outside = distanceOption > 0,\n			dataLabel,\n			labelPos,\n			labelHeight,\n			halves = [// divide the points into right and left halves for anti collision\n				[], // right\n				[]  // left\n			],\n			x,\n			y,\n			visibility,\n			rankArr,\n			i = 2,\n			j,\n			sort = function (a, b) {\n				return b.y - a.y;\n			},\n			sortByAngle = function (points, sign) {\n				points.sort(function (a, b) {\n					return (b.angle - a.angle) * sign;\n				});\n			};\n\n		// get out if not enabled\n		if (!options.enabled && !series._hasPointLabels) {\n			return;\n		}\n\n		// run parent method\n		Series.prototype.drawDataLabels.apply(series);\n\n		// arrange points for detection collision\n		each(data, function (point) {\n			if (point.dataLabel) { // it may have been cancelled in the base method (#407)\n				halves[point.half].push(point);\n			}\n		});\n\n		// assume equal label heights\n		labelHeight = halves[0][0] && halves[0][0].dataLabel && (halves[0][0].dataLabel.getBBox().height || 21); // 21 is for #968\n\n		/* Loop over the points in each half, starting from the top and bottom\n		 * of the pie to detect overlapping labels.\n		 */\n		while (i--) {\n\n			var slots = [],\n				slotsLength,\n				usedSlots = [],\n				points = halves[i],\n				pos,\n				length = points.length,\n				slotIndex;\n				\n			// Sort by angle\n			sortByAngle(points, i - 0.5);\n\n			// Only do anti-collision when we are outside the pie and have connectors (#856)\n			if (distanceOption > 0) {\n				\n				// build the slots\n				for (pos = centerY - radius - distanceOption; pos <= centerY + radius + distanceOption; pos += labelHeight) {\n					slots.push(pos);\n					// visualize the slot\n					/*\n					var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),\n						slotY = pos + chart.plotTop;\n					if (!isNaN(slotX)) {\n						chart.renderer.rect(slotX, slotY - 7, 100, labelHeight)\n							.attr({\n								'stroke-width': 1,\n								stroke: 'silver'\n							})\n							.add();\n						chart.renderer.text('Slot '+ (slots.length - 1), slotX, slotY + 4)\n							.attr({\n								fill: 'silver'\n							}).add();\n					}\n					// */\n				}\n				slotsLength = slots.length;\n	\n				// if there are more values than available slots, remove lowest values\n				if (length > slotsLength) {\n					// create an array for sorting and ranking the points within each quarter\n					rankArr = [].concat(points);\n					rankArr.sort(sort);\n					j = length;\n					while (j--) {\n						rankArr[j].rank = j;\n					}\n					j = length;\n					while (j--) {\n						if (points[j].rank >= slotsLength) {\n							points.splice(j, 1);\n						}\n					}\n					length = points.length;\n				}\n	\n				// The label goes to the nearest open slot, but not closer to the edge than\n				// the label's index.\n				for (j = 0; j < length; j++) {\n	\n					point = points[j];\n					labelPos = point.labelPos;\n	\n					var closest = 9999,\n						distance,\n						slotI;\n	\n					// find the closest slot index\n					for (slotI = 0; slotI < slotsLength; slotI++) {\n						distance = mathAbs(slots[slotI] - labelPos[1]);\n						if (distance < closest) {\n							closest = distance;\n	");
        builder.append("						slotIndex = slotI;\n						}\n					}\n	\n					// if that slot index is closer to the edges of the slots, move it\n					// to the closest appropriate slot\n					if (slotIndex < j && slots[j] !== null) { // cluster at the top\n						slotIndex = j;\n					} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom\n						slotIndex = slotsLength - length + j;\n						while (slots[slotIndex] === null) { // make sure it is not taken\n							slotIndex++;\n						}\n					} else {\n						// Slot is taken, find next free slot below. In the next run, the next slice will find the\n						// slot above these, because it is the closest one\n						while (slots[slotIndex] === null) { // make sure it is not taken\n							slotIndex++;\n						}\n					}\n	\n					usedSlots.push({ i: slotIndex, y: slots[slotIndex] });\n					slots[slotIndex] = null; // mark as taken\n				}\n				// sort them in order to fill in from the top\n				usedSlots.sort(sort);\n			}\n\n			// now the used slots are sorted, fill them up sequentially\n			for (j = 0; j < length; j++) {\n				\n				var slot, naturalY;\n\n				point = points[j];\n				labelPos = point.labelPos;\n				dataLabel = point.dataLabel;\n				visibility = point.visible === false ? HIDDEN : VISIBLE;\n				naturalY = labelPos[1];\n				\n				if (distanceOption > 0) {\n					slot = usedSlots.pop();\n					slotIndex = slot.i;\n\n					// if the slot next to currrent slot is free, the y value is allowed\n					// to fall back to the natural position\n					y = slot.y;\n					if ((naturalY > y && slots[slotIndex + 1] !== null) ||\n							(naturalY < y &&  slots[slotIndex - 1] !== null)) {\n						y = naturalY;\n					}\n					\n				} else {\n					y = naturalY;\n				}\n\n				// get the x - use the natural x position for first and last slot, to prevent the top\n				// and botton slice connectors from touching each other on either side\n				x = options.justify ? \n					seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :\n					series.getX(slotIndex === 0 || slotIndex === slots.length - 1 ? naturalY : y, i);\n				\n				// move or place the data label\n				dataLabel\n					.attr({\n						visibility: visibility,\n						align: labelPos[6]\n					})[dataLabel.moved ? 'animate' : 'attr']({\n						x: x + options.x +\n							({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),\n						y: y + options.y - 10 // 10 is for the baseline (label vs text)\n					});\n				dataLabel.moved = true;\n\n				// draw the connector\n				if (outside && connectorWidth) {\n					connector = point.connector;\n\n					connectorPath = softConnector ? [\n						M,\n						x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n						'C',\n						x, y, // first break, next to the label\n						2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],\n						labelPos[2], labelPos[3], // second break\n						L,\n						labelPos[4], labelPos[5] // base\n					] : [\n						M,\n						x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n						L,\n						labelPos[2], labelPos[3], // second break\n						L,\n						labelPos[4], labelPos[5] // base\n					];\n\n					if (connector) {\n						connector.animate({ d: connectorPath });\n						connector.attr('visibility', visibility);\n\n					} else {\n						point.connector = connector = series.chart.renderer.path(connectorPath).attr({\n							'stroke-width': connectorWidth,\n							stroke: options.connectorColor || point.color || '#606060',\n							visibility: visibility,\n							zIndex: 3\n						})\n						.translate(chart.plotLeft, chart.plotTop)\n						.add();\n					}\n				}\n			}\n		}\n	},\n	\n	alignDataLabel: noop,\n\n	/**\n	 * Draw point specific tracker objects. Inherit directly from column series.\n	 */\n	drawTracker: ColumnSeries.prototype.drawTracker,\n\n	/**\n	 * Use a simple symbol from column prototype\n	 */\n	drawLegendSymbol: AreaSeries.prototype.drawLegendSymbol,\n\n	/**\n	 * Pies don't have point marker symbols\n	 */\n	getSymbol: function () {}\n\n};\nPieSeries = extendClass(Series, PieSeries);\nseriesTypes.pie = PieSeries;\n\n\n// global variables\nextend(Highcharts, {\n	\n	// Constructors\n	Axis: Axis,\n	CanVGRenderer: CanVGRenderer,\n	Chart: Chart,\n	Color: Color,\n	Legend: Legend,\n	MouseTracker: MouseTracker,\n	Point: Point,\n	Tick: Tick,\n	Tooltip: Tooltip,\n	Renderer: Renderer,\n	Series: Series,\n	SVGRenderer: SVGRenderer,\n	VMLRenderer: VMLRenderer,\n	\n	// Various\n	arrayMin: arrayMin,\n	arrayMax: arrayMax,\n	charts: charts,\n	dateFormat: dateFormat,\n	pathAnim: pathAnim,\n	getOptions: getOptions,\n	hasBidiBug: hasBidiBug,\n	isTouchDevice: isTouchDevice,\n	numberFormat: numberFormat,\n	seriesTypes: seriesTypes,\n	setOptions: setOptions,\n	addEvent: addEvent,\n	removeEvent: removeEvent,\n	createElement: createElement,\n	discardElement: discardElement,\n	css: css,\n	each: each,\n	extend: extend,\n	map: map,\n	merge: merge,\n	pick: pick,\n	splat: splat,\n	extendClass: extendClass,\n	pInt: pInt,\n	wrap: wrap,\n	svg: hasSVG,\n	canvas: useCanVG,\n	vml: !hasSVG && !useCanVG,\n	product: 'Highcharts',\n	version: '2.3.5'\n});\n}());\n");
        return builder.toString();
      }
      public String getName() {
        return "highcharts";
      }
    }
    ;
  }
  private static class highchartsInitializer {
    static {
      _instance0.highchartsInitializer();
    }
    static com.google.gwt.resources.client.TextResource get() {
      return highcharts;
    }
  }
  public com.google.gwt.resources.client.TextResource highcharts() {
    return highchartsInitializer.get();
  }
  private void highchartsMoreInitializer() {
    highchartsMore = new com.google.gwt.resources.client.TextResource() {
      // jar:file:/Users/ajaybhaga/.m2/repository/com/vaadin/addon/vaadin-charts/1.0.0/vaadin-charts-1.0.0.jar!/com/vaadin/addon/charts/client/highcharts-more.js
      public String getText() {
        return "/*\n Highcharts JS v2.3.5 (2012-12-19)\n\n (c) 2009-2011 Torstein Hønsi\n\n License: www.highcharts.com/license\n*/\n(function(i,v){function A(a,b,c){this.init.call(this,a,b,c)}function B(a,b,c){a.call(this,b,c);if(this.chart.polar)this.closeSegment=function(a){var b=this.xAxis.center;a.push(\"L\",b[0],b[1])},this.closedStacks=!0}function C(a,b){var c=this.chart,d=this.options.animation,g=this.group,f=this.markerGroup,e=this.xAxis.center,h=c.plotLeft,m=c.plotTop;if(c.polar){if(c.renderer.isSVG)if(d===!0&&(d={}),b){if(g.attrSetters.scaleX=g.attrSetters.scaleY=function(a,b){this[b]=a;this.scaleX!==v&&this.scaleY!==\nv&&this.element.setAttribute(\"transform\",\"translate(\"+this.translateX+\",\"+this.translateY+\") scale(\"+this.scaleX+\",\"+this.scaleY+\")\");return!1},c={translateX:e[0]+h,translateY:e[1]+m,scaleX:0,scaleY:0},g.attr(c),f)f.attrSetters=g.attrSetters,f.attr(c)}else c={translateX:h,translateY:m,scaleX:1,scaleY:1},g.animate(c,d),f&&f.animate(c,d),this.animate=null}else a.call(this,b)}var q=i.each,w=i.extend,p=i.merge,G=i.map,o=i.pick,x=i.pInt,n=i.getOptions().plotOptions,j=i.seriesTypes,D=i.extendClass,E=i.splat,\nl=i.wrap,s=i.Axis,H=i.Tick,z=i.Series,r=j.column.prototype,t=function(){};w(A.prototype,{init:function(a,b,c){var d=this,g=d.defaultOptions;d.chart=b;if(b.angular)g.background={};d.options=a=p(g,a);(a=a.background)&&q([].concat(E(a)).reverse(),function(a){var b=a.backgroundColor,a=p(d.defaultBackgroundOptions,a);if(b)a.backgroundColor=b;a.color=a.backgroundColor;c.options.plotBands.unshift(a)})},defaultOptions:{center:[\"50%\",\"50%\"],size:\"85%\",startAngle:0},defaultBackgroundOptions:{shape:\"circle\",\nborderWidth:1,borderColor:\"silver\",backgroundColor:{linearGradient:{x1:0,y1:0,x2:0,y2:1},stops:[[0,\"#FFF\"],[1,\"#DDD\"]]},from:Number.MIN_VALUE,innerRadius:0,to:Number.MAX_VALUE,outerRadius:\"105%\"}});var y=s.prototype,s=H.prototype,I={getOffset:t,redraw:function(){this.isDirty=!1},render:function(){this.isDirty=!1},setScale:t,setCategories:t,setTitle:t},F={isRadial:!0,defaultRadialGaugeOptions:{labels:{align:\"center\",x:0,y:null},minorGridLineWidth:0,minorTickInterval:\"auto\",minorTickLength:10,minorTickPosition:\"inside\",\nminorTickWidth:1,plotBands:[],tickLength:10,tickPosition:\"inside\",tickWidth:2,title:{rotation:0},zIndex:2},defaultRadialXOptions:{gridLineWidth:1,labels:{align:null,distance:15,x:0,y:null},maxPadding:0,minPadding:0,plotBands:[],showLastLabel:!1,tickLength:0},defaultRadialYOptions:{gridLineInterpolation:\"circle\",labels:{align:\"right\",x:-3,y:-2},plotBands:[],showLastLabel:!1,title:{x:4,text:null,rotation:90}},setOptions:function(a){this.options=p(this.defaultOptions,this.defaultRadialOptions,a)},getOffset:function(){y.getOffset.call(this);\nthis.chart.axisOffset[this.side]=0;this.center=this.pane.center=j.pie.prototype.getCenter.call(this.pane)},getLinePath:function(a,b){var c=this.center,b=o(b,c[2]/2-this.offset);return this.chart.renderer.symbols.arc(this.left+c[0],this.top+c[1],b,b,{start:this.startAngleRad,end:this.endAngleRad,open:!0,innerR:0})},setAxisTranslation:function(){y.setAxisTranslation.call(this);if(this.center&&(this.transA=this.isCircular?(this.endAngleRad-this.startAngleRad)/(this.max-this.min||1):this.center[2]/2/\n(this.max-this.min||1),this.isXAxis))this.minPixelPadding=this.transA*this.minPointOffset+(this.reversed?(this.endAngleRad-this.startAngleRad)/4:0)},beforeSetTickPositions:function(){this.autoConnect&&(this.max+=this.categories&&1||this.pointRange||this.closestPointRange)},setAxisSize:function(){y.setAxisSize.call(this);if(this.center)this.len=this.width=this.height=this.isCircular?this.center[2]*(this.endAngleRad-this.startAngleRad)/2:this.center[2]/2},getPosition:function(a,b){if(!this.isCircular)b=\nthis.translate(a),a=this.min;return this.postTranslate(this.translate(a),o(b,this.center[2]/2)-this.offset)},postTranslate:function(a,b){var c=this.chart,d=this.center,a=this.startAngleRad+a;return{x:c.plotLeft+d[0]+Math.cos(a)*b,y:c.plotTop+d[1]+Math.sin(a)*b}},getPlotBandPath:function(a,b,c){var d=this.center,g=this.startAngleRad,f=d[2]/2,e=[o(c.outerRadius,\"100%\"),c.innerRadius,o(c.thickness,10)],h=/%$/,m,k=this.isCircular;this.options.gridLineInterpolation===\"polygon\"?d=this.getPlotLinePath(a).concat(this.getPlotLinePath(b,\n!0)):(k||(e[0]=this.translate(a),e[1]=this.translate(b)),e=G(e,function(a){h.test(a)&&(a=x(a,10)*f/100);return a}),c.shape===\"circle\"||!k?(a=-Math.PI/2,b=Math.PI*1.5,m=!0):(a=g+this.translate(a),b=g+this.translate(b)),d=this.chart.renderer.symbols.arc(this.left+d[0],this.top+d[1],e[0],e[0],{start:a,end:b,innerR:o(e[1],e[0]-e[2]),open:m}));return d},getPlotLinePath:function(a,b){var c=this.center,d=this.chart,g=this.getPosition(a),f,e,h;this.isCircular?h=[\"M\",c[0]+d.plotLeft,c[1]+d.plotTop,\"L\",g.x,\ng.y]:this.options.gridLineInterpolation===\"circle\"?(a=this.translate(a))&&(h=this.getLinePath(0,a)):(f=d.xAxis[0],h=[],a=this.translate(a),c=f.tickPositions,f.autoConnect&&(c=c.concat([c[0]])),b&&(c=[].concat(c).reverse()),q(c,function(b,c){e=f.getPosition(b,a);h.push(c?\"L\":\"M\",e.x,e.y)}));return h},getTitlePosition:function(){var a=this.center,b=this.chart,c=this.options.title;return{x:b.plotLeft+a[0]+(c.x||0),y:b.plotTop+a[1]-{high:0.5,middle:0.25,low:0}[c.align]*a[2]+(c.y||0)}}};l(y,\"init\",function(a,\nb,c){var d=b.angular,g=b.polar,f=c.isX,e=d&&f,h,m;m=b.options;var k=c.pane||0;if(d){if(w(this,e?I:F),h=!f)this.defaultRadialOptions=this.defaultRadialGaugeOptions}else if(g)w(this,F),this.defaultRadialOptions=(h=f)?this.defaultRadialXOptions:p(this.defaultYAxisOptions,this.defaultRadialYOptions);a.call(this,b,c);if(!e&&(d||g)){a=this.options;if(!b.panes)b.panes=[];this.pane=b.panes[k]=k=new A(E(m.pane)[k],b,this);k=k.options;b.inverted=!1;m.chart.zoomType=null;this.startAngleRad=b=(k.startAngle-90)*\nMath.PI/180;this.endAngleRad=m=(o(k.endAngle,k.startAngle+360)-90)*Math.PI/180;this.offset=a.offset||0;if((this.isCircular=h)&&c.max===v&&m-b===2*Math.PI)this.autoConnect=!0}});l(s,\"getPosition\",function(a,b,c,d,g){var f=this.axis;return f.getPosition?f.getPosition(c):a.call(this,b,c,d,g)});l(s,\"getLabelPosition\",function(a,b,c,d,g,f,e,h,m){var k=this.axis,i=f.y,j=f.align,l=(k.translate(this.pos)+k.startAngleRad+Math.PI/2)/Math.PI*180;k.isRadial?(a=k.getPosition(this.pos,k.center[2]/2+o(f.distance,\n-25)),f.rotation===\"auto\"?d.attr({rotation:l}):i===null&&(i=x(d.styles.lineHeight)*0.9-d.getBBox().height/2),j===null&&(j=k.isCircular?l>20&&l<160?\"left\":l>200&&l<340?\"right\":\"center\":\"center\",d.attr({align:j})),a.x+=f.x,a.y+=i):a=a.call(this,b,c,d,g,f,e,h,m);return a});l(s,\"getMarkPath\",function(a,b,c,d,g,f,e){var h=this.axis;h.isRadial?(a=h.getPosition(this.pos,h.center[2]/2+d),b=[\"M\",b,c,\"L\",a.x,a.y]):b=a.call(this,b,c,d,g,f,e);return b});n.arearange=p(n.area,{lineWidth:1,marker:null,threshold:null,\ntooltip:{pointFormat:'<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>'},trackByArea:!0,dataLabels:{verticalAlign:null,xLow:0,xHigh:0,yLow:0,yHigh:0},shadow:!1});s=i.extendClass(i.Point,{applyOptions:function(a,b){var c=this.series,d=c.pointArrayMap,g=0,f=0,e=d.length;if(typeof a===\"object\"&&typeof a.length!==\"number\")w(this,a),this.options=a;else if(a.length){if(a.length>e){if(typeof a[0]===\"string\")this.name=a[0];else if(typeof a[0]===\"number\")this.x=\na[0];g++}for(;f<e;)this[d[f++]]=a[g++]}this.y=this[c.pointValKey];if(this.x===v&&c)this.x=b===v?c.autoIncrement():b;return this},toYData:function(){return[this.low,this.high]}});j.arearange=i.extendClass(j.area,{type:\"arearange\",pointArrayMap:[\"low\",\"high\"],pointClass:s,pointValKey:\"low\",translate:function(){var a=this.yAxis;j.area.prototype.translate.apply(this);q(this.points,function(b){if(b.y!==null)b.plotLow=b.plotY,b.plotHigh=a.translate(b.high,0,1,0,1)})},getSegmentPath:function(a){var b=[],\nc=a.length,d=z.prototype.getSegmentPath,g,f;f=this.options;for(var e=f.step;c--;)g=a[c],b.push({plotX:g.plotX,plotY:g.plotHigh});a=d.call(this,a);if(e)e===!0&&(e=\"left\"),f.step={left:\"right\",center:\"center\",right:\"left\"}[e];b=d.call(this,b);f.step=e;f=[].concat(a,b);b[0]=\"L\";this.areaPath=this.areaPath.concat(a,b);return f},drawDataLabels:function(){var a=this.data,b=a.length,c,d=[],g=z.prototype,f=this.options.dataLabels,e,h=this.chart.inverted;if(f.enabled||this._hasPointLabels){for(c=b;c--;)e=\na[c],e.y=e.high,e.plotY=e.plotHigh,d[c]=e.dataLabel,e.dataLabel=e.dataLabelUpper,e.below=!1,h?(f.align=\"left\",f.x=f.xHigh):f.y=f.yHigh;g.drawDataLabels.apply(this,arguments);for(c=b;c--;)e=a[c],e.dataLabelUpper=e.dataLabel,e.dataLabel=d[c],e.y=e.low,e.plotY=e.plotLow,e.below=!0,h?(f.align=\"right\",f.x=f.xLow):f.y=f.yLow;g.drawDataLabels.apply(this,arguments)}},alignDataLabel:j.column.prototype.alignDataLabel,getSymbol:j.column.prototype.getSymbol,drawPoints:t});n.areasplinerange=p(n.arearange);j.areasplinerange=\nD(j.arearange,{type:\"areasplinerange\",getPointSpline:j.spline.prototype.getPointSpline});n.columnrange=p(n.column,n.arearange,{lineWidth:1,pointRange:null});j.columnrange=D(j.arearange,{type:\"columnrange\",translate:function(){var a=this.yAxis,b;r.translate.apply(this);q(this.points,function(c){var d=c.shapeArgs;c.plotHigh=b=a.translate(c.high,0,1,0,1);c.plotLow=c.plotY;d.y=b;d.height=c.plotY-b;c.trackerArgs=d})},drawGraph:t,pointAttrToOptions:r.pointAttrToOptions,drawPoints:r.drawPoints,drawTracker:r.drawTracker,\nanimate:r.animate});n.gauge=p(n.line,{dataLabels:{enabled:!0,y:15,borderWidth:1,borderColor:\"silver\",borderRadius:3,style:{fontWeight:\"bold\"},verticalAlign:\"top\",zIndex:2},dial:{},pivot:{},tooltip:{headerFormat:\"\"},showInLegend:!1});n={type:\"gauge\",pointClass:i.extendClass(i.Point,{setState:function(a){this.state=a}}),angular:!0,translate:function(){var a=this,b=a.yAxis,c=b.center;a.generatePoints();q(a.points,function(d){var g=p(a.options.dial,d.dial),f=x(o(g.radius,80))*c[2]/200,e=x(o(g.baseLength,\n70))*f/100,h=x(o(g.rearLength,10))*f/100,m=g.baseWidth||3,k=g.topWidth||1;d.shapeType=\"path\";d.shapeArgs={d:g.path||[\"M\",-h,-m/2,\"L\",e,-m/2,f,-k/2,f,k/2,e,m/2,-h,m/2,\"z\"],translateX:c[0],translateY:c[1],rotation:(b.startAngleRad+b.translate(d.y,null,null,null,!0))*180/Math.PI};d.plotX=c[0];d.plotY=c[1]})},drawPoints:function(){var a=this,b=a.yAxis.center,c=a.pivot,d=a.options,g=d.pivot,f=a.chart.renderer;q(a.points,function(b){var c=b.graphic,g=b.shapeArgs,k=g.d,i=p(d.dial,b.dial);c?(c.animate(g),\ng.d=k):b.graphic=f[b.shapeType](g).attr({stroke:i.borderColor||\"none\",\"stroke-width\":i.borderWidth||0,fill:i.backgroundColor||\"black\",rotation:g.rotation}).add(a.group)});c?c.animate({translateX:b[0],translateY:b[1]}):a.pivot=f.circle(0,0,o(g.radius,5)).attr({\"stroke-width\":g.borderWidth||0,stroke:g.borderColor||\"silver\",fill:g.backgroundColor||\"black\"}).translate(b[0],b[1]).add(a.group)},animate:function(){var a=this;q(a.points,function(b){var c=b.graphic;c&&(c.attr({rotation:a.yAxis.startAngleRad*\n180/Math.PI}),c.animate({rotation:b.shapeArgs.rotation},a.options.animation))});a.animate=null},render:function(){this.group=this.plotGroup(\"group\",\"series\",this.visible?\"visible\":\"hidden\",this.options.zIndex,this.chart.seriesGroup);j.pie.prototype.render.call(this);this.group.clip(this.chart.clipRect)},setData:j.pie.prototype.setData,drawTracker:j.column.prototype.drawTracker};j.gauge=i.extendClass(j.line,n);var u=z.prototype,n=i.MouseTracker.prototype;u.toXY=function(a){var b,c=this.chart;b=a.plotX;\nvar d=a.plotY;a.rectPlotX=b;a.rectPlotY=d;a.deg=b/Math.PI*180;b=this.xAxis.postTranslate(a.plotX,this.yAxis.len-d);a.plotX=a.polarPlotX=b.x-c.plotLeft;a.plotY=a.polarPlotY=b.y-c.plotTop};l(j.area.prototype,\"init\",B);l(j.areaspline.prototype,\"init\",B);l(j.spline.prototype,\"getPointSpline\",function(a,b,c,d){var g,f,e,h,i,k,j;if(this.chart.polar){g=c.plotX;f=c.plotY;a=b[d-1];e=b[d+1];this.connectEnds&&(a||(a=b[b.length-2]),e||(e=b[1]));if(a&&e)h=a.plotX,i=a.plotY,b=e.plotX,k=e.plotY,h=(1.5*g+h)/2.5,\ni=(1.5*f+i)/2.5,e=(1.5*g+b)/2.5,j=(1.5*f+k)/2.5,b=Math.sqrt(Math.pow(h-g,2)+Math.pow(i-f,2)),k=Math.sqrt(Math.pow(e-g,2)+Math.pow(j-f,2)),h=Math.atan2(i-f,h-g),i=Math.atan2(j-f,e-g),j=Math.PI/2+(h+i)/2,Math.abs(h-j)>Math.PI/2&&(j-=Math.PI),h=g+Math.cos(j)*b,i=f+Math.sin(j)*b,e=g+Math.cos(Math.PI+j)*k,j=f+Math.sin(Math.PI+j)*k,c.rightContX=e,c.rightContY=j;d?(c=[\"C\",a.rightContX||a.plotX,a.rightContY||a.plotY,h||g,i||f,g,f],a.rightContX=a.rightContY=null):c=[\"M\",g,f]}else c=a.call(this,b,c,d);return c});\nl(u,\"translate\",function(a){a.call(this);if(this.chart.polar&&!this.preventPostTranslate)for(var a=this.points,b=a.length;b--;)this.toXY(a[b])});l(u,\"getSegmentPath\",function(a,b){var c=this.points;if(this.chart.polar&&this.options.connectEnds!==!1&&b[b.length-1]===c[c.length-1]&&c[0].y!==null)this.connectEnds=!0,b=[].concat(b,[c[0]]);return a.call(this,b)});l(u,\"animate\",C);l(r,\"animate\",C);l(u,\"setTooltipPoints\",function(a,b){this.chart.polar&&w(this.xAxis,{tooltipLen:360,tooltipPosName:\"deg\"});\nreturn a.call(this,b)});l(r,\"translate\",function(a){var b=this.xAxis,c=this.yAxis.len,d=b.center,g=b.startAngleRad,f=this.chart.renderer,e,h;this.preventPostTranslate=!0;a.call(this);if(b.isRadial){b=this.points;for(h=b.length;h--;)e=b[h],a=e.barX+g,e.shapeType=\"path\",e.shapeArgs={d:f.symbols.arc(d[0],d[1],c-e.plotY,null,{start:a,end:a+e.pointWidth,innerR:c-o(e.yBottom,c)})},this.toXY(e)}});l(r,\"alignDataLabel\",function(a,b,c,d,g,f){if(this.chart.polar){a=b.rectPlotX/Math.PI*180;if(d.align===null)d.align=\na>20&&a<160?\"left\":a>200&&a<340?\"right\":\"center\";if(d.verticalAlign===null)d.verticalAlign=a<45||a>315?\"bottom\":a>135&&a<225?\"top\":\"middle\";u.alignDataLabel.call(this,b,c,d,g,f)}else a.call(this,b,c,d,g,f)});l(n,\"getIndex\",function(a,b){var c,d=this.chart,g;d.polar?(g=d.xAxis[0].center,c=b.chartX-g[0]-d.plotLeft,d=b.chartY-g[1]-d.plotTop,c=180-Math.round(Math.atan2(c,d)/Math.PI*180)):c=a.call(this,b);return c});l(n,\"getMouseCoordinates\",function(a,b){var c=this.chart,d={xAxis:[],yAxis:[]};c.polar?\nq(c.axes,function(a){var f=a.isXAxis,e=a.center,h=b.chartX-e[0]-c.plotLeft,e=b.chartY-e[1]-c.plotTop;d[f?\"xAxis\":\"yAxis\"].push({axis:a,value:a.translate(f?Math.PI-Math.atan2(h,e):Math.sqrt(Math.pow(h,2)+Math.pow(e,2)),!0)})}):d=a.call(this,b);return d})})(Highcharts);\n";
      }
      public String getName() {
        return "highchartsMore";
      }
    }
    ;
  }
  private static class highchartsMoreInitializer {
    static {
      _instance0.highchartsMoreInitializer();
    }
    static com.google.gwt.resources.client.TextResource get() {
      return highchartsMore;
    }
  }
  public com.google.gwt.resources.client.TextResource highchartsMore() {
    return highchartsMoreInitializer.get();
  }
  private void jqueryInitializer() {
    jquery = new com.google.gwt.resources.client.TextResource() {
      // jar:file:/Users/ajaybhaga/.m2/repository/com/vaadin/addon/vaadin-charts/1.0.0/vaadin-charts-1.0.0.jar!/com/vaadin/addon/charts/client/jquery.min.js
      public String getText() {
        StringBuilder builder = new StringBuilder();
        builder.append("/*! jQuery v1.7.2 jquery.com | jquery.org/license */\n(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cu(a){if(!cj[a]){var b=c.body,d=f(\"<\"+a+\">\").appendTo(b),e=d.css(\"display\");d.remove();if(e===\"none\"||e===\"\"){ck||(ck=c.createElement(\"iframe\"),ck.frameBorder=ck.width=ck.height=0),b.appendChild(ck);if(!cl||!ck.createElement)cl=(ck.contentWindow||ck.contentDocument).document,cl.write((f.support.boxModel?\"<!doctype html>\":\"\")+\"<html><body>\"),cl.close();d=cl.createElement(a),cl.body.appendChild(d),e=f.css(d,\"display\"),b.removeChild(ck)}cj[a]=e}return cj[a]}function ct(a,b){var c={};f.each(cp.concat.apply([],cp.slice(0,b)),function(){c[this]=a});return c}function cs(){cq=b}function cr(){setTimeout(cs,0);return cq=f.now()}function ci(){try{return new a.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(b){}}function ch(){try{return new a.XMLHttpRequest}catch(b){}}function cb(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h==\"string\"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k===\"*\")k=l;else if(l!==\"*\"&&l!==k){m=l+\" \"+k,n=e[m]||e[\"* \"+k];if(!n){p=b;for(o in e){j=o.split(\" \");if(j[0]===l||j[0]===\"*\"){p=e[j[1]+\" \"+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error(\"No conversion from \"+m.replace(\" \",\" to \")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function ca(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]===\"*\")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader(\"content-type\"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+\" \"+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function b_(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bD.test(a)?d(a,e):b_(a+\"[\"+(typeof e==\"object\"?b:\"\")+\"]\",e,c,d)});else if(!c&&f.type(b)===\"object\")for(var e in b)b_(a+\"[\"+e+\"]\",b[e],c,d);else d(a,b)}function b$(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function bZ(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bS,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l==\"string\"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=bZ(a,c,d,e,l,g)));(k||!l)&&!g[\"*\"]&&(l=bZ(a,c,d,e,\"*\",g));return l}function bY(a){return function(b,c){typeof b!=\"string\"&&(c=b,b=\"*\");if(f.isFunction(c)){var d=b.toLowerCase().split(bO),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\\+/.test(h),j&&(h=h.substr(1)||\"*\"),i=a[h]=a[h]||[],i[j?\"unshift\":\"push\"](c)}}}function bB(a,b,c){var d=b===\"width\"?a.offsetWidth:a.offsetHeight,e=b===\"width\"?1:0,g=4;if(d>0){if(c!==\"border\")for(;e<g;e+=2)c||(d-=parseFloat(f.css(a,\"padding\"+bx[e]))||0),c===\"margin\"?d+=parseFloat(f.css(a,c+bx[e]))||0:d-=parseFloat(f.css(a,\"border\"+bx[e]+\"Width\"))||0;return d+\"px\"}d=by(a,b);if(d<0||d==null)d=a.style[b];if(bt.test(d))return d;d=parseFloat(d)||0;if(c)for(;e<g;e+=2)d+=parseFloat(f.css(a,\"padding\"+bx[e]))||0,c!==\"padding\"&&(d+=parseFloat(f.css(a,\"border\"+bx[e]+\"Width\"))||0),c===\"margin\"&&(d+=parseFloat(f.css(a,c+bx[e]))||0);return d+\"px\"}function bo(a){var b=c.createElement(\"div\");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||\"\").toLowerCase();b===\"input\"?bm(a):b!==\"script\"&&typeof a.getElementsByTagName!=\"undefined\"&&f.grep(a.getElementsByTagName(\"input\"),bm)}function bm(a){if(a.type===\"checkbox\"||a.type===\"radio\")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!=\"undefined\"?a.getElementsByTagName(\"*\"):typeof a.querySelectorAll!=\"undefined\"?a.querySelectorAll(\"*\"):[]}function bk(a,b){var c;b.nodeType===1&&(b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase(),c===\"object\"?b.outerHTML=a.outerHTML:c!==\"input\"||a.type!==\"checkbox\"&&a.type!==\"radio\"?c===\"option\"?b.selected=a.defaultSelected:c===\"input\"||c===\"textarea\"?b.defaultValue=a.defaultValue:c===\"script\"&&b.text!==a.text&&(b.text=a.text):(a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value)),b.removeAttribute(f.expando),b.removeAttribute(\"_submit_attached\"),b.removeAttribute(\"_change_attached\"))}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c,i[c][d])}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,\"table\")?a.getElementsByTagName(\"tbody\")[0]||a.appendChild(a.ownerDocument.createElement(\"tbody\")):a}function U(a){var b=V.split(\"|\"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b==\"string\"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+\"defer\",e=b+\"queue\",g=b+\"mark\",h=f._data(a,d);h&&(c===\"queue\"||!f._data(a,e))&&(c===\"mark\"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b===\"data\"&&f.isEmptyObject(a[b]))continue;if(b!==\"toJSON\")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e=\"data-\"+c.replace(k,\"-$1\").toLowerCase();d=a.getAttribute(e);if(typeof d==\"string\"){try{d=d===\"true\"?!0:d===\"false\"?!1:d===\"null\"?null:f.isNumeric(d)?+d:j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll(\"left\")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,j=/\\S/,k=/^\\s+/,l=/\\s+$/,m=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/,n=/^[\\],:{}\\s]*$/,o=/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,q=/(?:^|:|,)(?:\\s*\\[)+/g,r=/(webkit)[ \\/]([\\w.]+)/,s=/(opera)(?:.*version)?[ \\/]([\\w.]+)/,t=/(msie) ([\\w.]+)/,u=/(mozilla)(?:.*? rv:([\\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+\"\").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a===\"body\"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a==\"string\"){a.charAt(0)!==\"<\"||a.charAt(a.length-1)!==\">\"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:\"\",jquery:\"1.7.2\",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b===\"find\"?d.selector=this.selector+(this.selector?\" \":\"\")+c:b&&(d.selector=this.selector+\".\"+b+\"(\"+c+\")\");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),\"slice\",F.call(arguments).join(\",\"))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i==\"boolean\"&&(l=i,i=arguments[1]||{},j=2),typeof i!=\"object\"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger(\"ready\").off(\"ready\")}},bindReady:function(){if(!A){A=e.Callbacks(\"once memory\");if(c.readyState===\"complete\")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener(\"DOMContentLoaded\",B,!1),a.addEventListener(\"load\",e.ready,!1);else if(c.attachEvent){c.attachEvent(\"onreadystatechange\",B),a.attachEvent(\"onload\",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)===\"function\"},isArray:Array.isArray||function(a){return e.type(a)===\"array\"},isWindow:function(a){return a!=null&&a==a.window},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||\"object\"},isPlainObject:function(a){if(!a||e.type(a)!==\"object\"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,\"constructor\")&&!D.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!=\"string\"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,\"@\").replace(p,\"]\").replace(q,\"\")))return(new Function(\"return \"+b))();e.error(\"Invalid JSON: \"+b)},parseXML:function(c){if(typeof c!=\"string\"||!c)return null;var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,\"text/xml\")):(d=new ActiveXObject(\"Microsoft.XMLDOM\"),d.async=\"false\",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName(\"parsererror\").length)&&e.error(\"Invalid XML: \"+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,\"ms-\").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?\"\":G.call(a)}:function(a){return a==null?\"\":(a+\"\").replace(k,\"\").replace(l,\"\")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d===\"string\"||d===\"function\"||d===\"regexp\"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length==\"number\")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j==\"number\"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c==\"string\"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h,i){var j,k=d==null,l=0,m=a.length;if(d&&typeof d==\"object\"){for(l in d)e.access(a,c,l,d[l],1,h,f);g=1}else if(f!==b){j=i===b&&e.isFunction(f),k&&(j?(j=c,c=function(a,b,c){return j.call(e(a),c)}):(c.call(a,f),c=null));if(c)for(;l<m;l++)c(a[l],d,j?f.call(a[l],l,c(a[l],d)):f,i);g=1}return g?a:k?c.call(a):m?c(a[0],d):h},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf(\"compatible\")<0&&u.exec(a)||[];return{browser:b[1]||\"\",version:b[2]||\"0\"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"),function(a,b){I[\"[object \"+b+\"]\"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(\" \")&&(k=/^[\\s\\xA0]+/,l=/[\\s\\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener(\"DOMContentLoaded\",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState===\"complete\"&&(c.detachEvent(\"onreadystatechange\",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m,n=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h===\"array\"?n(g):h===\"function\"&&(!a.unique||!p.has(g))&&c.push(g)},o=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,j=!0,m=k||0,k=0,l=c.length;for(;c&&m<l;m++)if(c[m].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}j=!1,c&&(a.once?e===!0?p.disable():c=[]:d&&d.length&&(e=d.shift(),p.fireWith(e[0],e[1])))},p={add:function(){if(c){var a=c.length;n(arguments),j?l=c.length:e&&e!==!0&&(k=a,o(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){j&&f<=l&&(l--,f<=m&&m--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&p.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(j?a.once||d.push([b,c]):(!a.once||!e)&&o(b,c));return this},fire:function(){p.fireWith(this,arguments);return this},fired:function(){return!!i}};return p};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks(\"once memory\"),c=f.Callbacks(\"once memory\"),d=f.Callbacks(\"memory\"),e=\"pending\",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,\"resolve\"],fail:[b,\"reject\"],progress:[c,\"notify\"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e");
        builder.append("+\"With\"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+\"With\"]=g[j].fireWith;i.done(function(){e=\"resolved\"},c.disable,d.lock).fail(function(){e=\"rejected\"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p=c.createElement(\"div\"),q=c.documentElement;p.setAttribute(\"className\",\"t\"),p.innerHTML=\"   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>\",d=p.getElementsByTagName(\"*\"),e=p.getElementsByTagName(\"a\")[0];if(!d||!d.length||!e)return{};g=c.createElement(\"select\"),h=g.appendChild(c.createElement(\"option\")),i=p.getElementsByTagName(\"input\")[0],b={leadingWhitespace:p.firstChild.nodeType===3,tbody:!p.getElementsByTagName(\"tbody\").length,htmlSerialize:!!p.getElementsByTagName(\"link\").length,style:/top/.test(e.getAttribute(\"style\")),hrefNormalized:e.getAttribute(\"href\")===\"/a\",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value===\"on\",optSelected:h.selected,getSetAttribute:p.className!==\"t\",enctype:!!c.createElement(\"form\").enctype,html5Clone:c.createElement(\"nav\").cloneNode(!0).outerHTML!==\"<:nav></:nav>\",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,pixelMargin:!0},f.boxModel=b.boxModel=c.compatMode===\"CSS1Compat\",i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete p.test}catch(r){b.deleteExpando=!1}!p.addEventListener&&p.attachEvent&&p.fireEvent&&(p.attachEvent(\"onclick\",function(){b.noCloneEvent=!1}),p.cloneNode(!0).fireEvent(\"onclick\")),i=c.createElement(\"input\"),i.value=\"t\",i.setAttribute(\"type\",\"radio\"),b.radioValue=i.value===\"t\",i.setAttribute(\"checked\",\"checked\"),i.setAttribute(\"name\",\"t\"),p.appendChild(i),j=c.createDocumentFragment(),j.appendChild(p.lastChild),b.checkClone=j.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,j.removeChild(i),j.appendChild(p);if(p.attachEvent)for(n in{submit:1,change:1,focusin:1})m=\"on\"+n,o=m in p,o||(p.setAttribute(m,\"return;\"),o=typeof p[m]==\"function\"),b[n+\"Bubbles\"]=o;j.removeChild(p),j=g=h=p=i=null,f(function(){var d,e,g,h,i,j,l,m,n,q,r,s,t,u=c.getElementsByTagName(\"body\")[0];!u||(m=1,t=\"padding:0;margin:0;border:\",r=\"position:absolute;top:0;left:0;width:1px;height:1px;\",s=t+\"0;visibility:hidden;\",n=\"style='\"+r+t+\"5px solid #000;\",q=\"<div \"+n+\"display:block;'><div style='\"+t+\"0;display:block;overflow:hidden;'></div></div>\"+\"<table \"+n+\"' cellpadding='0' cellspacing='0'>\"+\"<tr><td></td></tr></table>\",d=c.createElement(\"div\"),d.style.cssText=s+\"width:0;height:0;position:static;top:0;margin-top:\"+m+\"px\",u.insertBefore(d,u.firstChild),p=c.createElement(\"div\"),d.appendChild(p),p.innerHTML=\"<table><tr><td style='\"+t+\"0;display:none'></td><td>t</td></tr></table>\",k=p.getElementsByTagName(\"td\"),o=k[0].offsetHeight===0,k[0].style.display=\"\",k[1].style.display=\"none\",b.reliableHiddenOffsets=o&&k[0].offsetHeight===0,a.getComputedStyle&&(p.innerHTML=\"\",l=c.createElement(\"div\"),l.style.width=\"0\",l.style.marginRight=\"0\",p.style.width=\"2px\",p.appendChild(l),b.reliableMarginRight=(parseInt((a.getComputedStyle(l,null)||{marginRight:0}).marginRight,10)||0)===0),typeof p.style.zoom!=\"undefined\"&&(p.innerHTML=\"\",p.style.width=p.style.padding=\"1px\",p.style.border=0,p.style.overflow=\"hidden\",p.style.display=\"inline\",p.style.zoom=1,b.inlineBlockNeedsLayout=p.offsetWidth===3,p.style.display=\"block\",p.style.overflow=\"visible\",p.innerHTML=\"<div style='width:5px;'></div>\",b.shrinkWrapBlocks=p.offsetWidth!==3),p.style.cssText=r+s,p.innerHTML=q,e=p.firstChild,g=e.firstChild,i=e.nextSibling.firstChild.firstChild,j={doesNotAddBorder:g.offsetTop!==5,doesAddBorderForTableAndCells:i.offsetTop===5},g.style.position=\"fixed\",g.style.top=\"20px\",j.fixedPosition=g.offsetTop===20||g.offsetTop===15,g.style.position=g.style.top=\"\",e.style.overflow=\"hidden\",e.style.position=\"relative\",j.subtractsBorderForOverflowNotVisible=g.offsetTop===-5,j.doesNotIncludeMarginInBodyOffset=u.offsetTop!==m,a.getComputedStyle&&(p.style.marginTop=\"1%\",b.pixelMargin=(a.getComputedStyle(p,null)||{marginTop:0}).marginTop!==\"1%\"),typeof d.style.zoom!=\"undefined\"&&(d.style.zoom=1),u.removeChild(d),l=p=d=null,f.extend(b,j))});return b}();var j=/^(?:\\{.*\\}|\\[.*\\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:\"jQuery\"+(f.fn.jquery+Math.random()).replace(/\\D/g,\"\"),noData:{embed:!0,object:\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c==\"string\",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c===\"events\";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c==\"object\"||typeof c==\"function\")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(\" \")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute(\"classid\")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h,i,j=this[0],k=0,m=null;if(a===b){if(this.length){m=f.data(j);if(j.nodeType===1&&!f._data(j,\"parsedAttrs\")){g=j.attributes;for(i=g.length;k<i;k++)h=g[k].name,h.indexOf(\"data-\")===0&&(h=f.camelCase(h.substring(5)),l(j,h,m[h]));f._data(j,\"parsedAttrs\",!0)}}return m}if(typeof a==\"object\")return this.each(function(){f.data(this,a)});d=a.split(\".\",2),d[1]=d[1]?\".\"+d[1]:\"\",e=d[1]+\"!\";return f.access(this,function(c){if(c===b){m=this.triggerHandler(\"getData\"+e,[d[0]]),m===b&&j&&(m=f.data(j,a),m=l(j,a,m));return m===b&&d[1]?this.data(d[0]):m}d[1]=c,this.each(function(){var b=f(this);b.triggerHandler(\"setData\"+e,d),f.data(this,a,c),b.triggerHandler(\"changeData\"+e,d)})},null,c,arguments.length>1,null,!1)},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||\"fx\")+\"mark\",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||\"fx\";var d=c+\"mark\",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,\"mark\"))}},queue:function(a,b,c){var d;if(a){b=(b||\"fx\")+\"queue\",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||\"fx\";var c=f.queue(a,b),d=c.shift(),e={};d===\"inprogress\"&&(d=c.shift()),d&&(b===\"fx\"&&c.unshift(\"inprogress\"),f._data(a,b+\".run\",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+\"queue \"+b+\".run\",!0),n(a,b,\"queue\"))}}),f.fn.extend({queue:function(a,c){var d=2;typeof a!=\"string\"&&(c=a,a=\"fx\",d--);if(arguments.length<d)return f.queue(this[0],a);return c===b?this:this.each(function(){var b=f.queue(this,a,c);a===\"fx\"&&b[0]!==\"inprogress\"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||\"fx\";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||\"fx\",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!=\"string\"&&(c=a,a=b),a=a||\"fx\";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+\"defer\",j=a+\"queue\",k=a+\"mark\",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks(\"once memory\"),!0))h++,l.add(m);m();return d.promise(c)}});var o=/[\\n\\t\\r]/g,p=/\\s+/,q=/\\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,f.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,f.prop,a,b,arguments.length>1)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a==\"string\"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=\" \"+e.className+\" \";for(h=0,i=b.length;h<i;h++)~g.indexOf(\" \"+b[h]+\" \")||(g+=b[h]+\" \");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a==\"string\"||a===b){c=(a||\"\").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(\" \"+g.className+\" \").replace(o,\" \");for(i=0,j=c.length;i<j;i++)h=h.replace(\" \"+c[i]+\" \",\" \");g.className=f.trim(h)}else g.className=\"\"}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b==\"boolean\";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c===\"string\"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?\"addClass\":\"removeClass\"](e)}else if(c===\"undefined\"||c===\"boolean\")this.className&&f._data(this,\"__className__\",this.className),this.className=this.className||a===!1?\"\":f._data(this,\"__className__\")||\"\"})},hasClass:function(a){var b=\" \"+a+\" \",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(\" \"+this[c].className+\" \").replace(o,\" \").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h=\"\":typeof h==\"number\"?h+=\"\":f.isArray(h)&&(h=f.map(h,function(a){return a==null?\"\":a+\"\"})),c=f.valHooks[this.type]||f.valHooks[this.nodeName.toLowerCase()];if(!c||!(\"set\"in c)||c.set(this,h,\"value\")===b)this.value=h}})}if(g){c=f.valHooks[g.type]||f.valHooks[g.nodeName.toLowerCase()];if(c&&\"get\"in c&&(d=c.get(g,\"value\"))!==b)return d;d=g.value;return typeof d==\"string\"?d.replace(q,\"\"):d==null?\"\":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type===\"select-one\";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute(\"disabled\")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,\"optgroup\"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find(\"option\").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute==\"undefined\")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&\"set\"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,\"\"+d);return d}if(h&&\"get\"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h,i=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;i<g;i++)e=d[i],e&&(c=f.propFix[e]||e,h=u.test(e),h||f.attr(a,e,\"\"),a.removeAttribute(v?e:c),h&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error(\"type property can't be changed\");else if(!f.support.radioValue&&b===\"radio\"&&f.nodeName(a,\"input\")){var c=a.value;a.setAttribute(\"type\",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,\"button\"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,\"button\"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:\"tabIndex\",readonly:\"readOnly\",\"for\":\"htmlFor\",\"class\":\"className\",maxlength:\"maxLength\",cellspacing:\"cellSpacing\",cellpadding:\"cellPadding\",rowspan:\"rowSpan\",colspan:\"colSpan\",usemap:\"useMap\",frameborder:\"frameBorder\",contenteditable:\"contentEditable\"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&\"set\"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&\"get\"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode(\"tabindex\");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!=\"boolean\"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0,coords:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!==\"\":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+\"\"}},f.attrHooks.tabindex.set=w.set,f.each([\"width\",\"height\"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===\"\"){a.setAttribute(b,\"auto\");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===\"\"&&(b=\"false\"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each([\"href\",\"src\",\"width\",\"height\"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=\"\"+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype=\"encoding\"),f.support.checkOn||f.each([\"radio\",\"checkbox\"],function(){f.valHooks[this]={get:function(a){return a.getAttribute(\"value\")===null?\"on\":a.value}}}),f.each([\"radio\",\"checkbox\"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\\.]*)?(?:\\.(.+))?$/,B=/(?:^|\\s)hover(\\.\\S+)?\\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\\w*)(?:#([\\w\\-]+))?(?:\\.([\\w\\-]+))?$/,G=function(\na){var b=F.exec(a);b&&(b[1]=(b[1]||\"\").toLowerCase(),b[3]=b[3]&&new RegExp(\"(?:^|\\\\s)\"+b[3]+\"(?:\\\\s|$)\"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c[\"class\"]||{}).value))},I=function(a){return");
        builder.append(" f.event.special.hover?a:a.replace(B,\"mouseenter$1 mouseleave$1\")};f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler,g=p.selector),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!=\"undefined\"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(\" \");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||\"\").split(\".\").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:g&&G(g),namespace:n.join(\".\")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent(\"on\"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||\"\")).split(\" \");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp(\"(^|\\\\.)\"+l.split(\".\").sort().join(\"\\\\.(?:.*\\\\.)?\")+\"(\\\\.|$)\"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d===\"**\"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,[\"events\",\"handle\"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf(\"!\")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(\".\")>=0&&(i=h.split(\".\"),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c==\"object\"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join(\".\"),c.namespace_re=c.namespace?new RegExp(\"(^|\\\\.)\"+i.join(\"\\\\.(?:.*\\\\.)?\")+\"(\\\\.|$)\"):null,o=h.indexOf(\":\")<0?\"on\"+h:\"\";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,\"events\")||{})[c.type]&&f._data(m,\"handle\"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!==\"click\"||!f.nodeName(e,\"a\"))&&f.acceptData(e)&&o&&e[h]&&(h!==\"focus\"&&h!==\"blur\"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,\"events\")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=f.event.special[c.type]||{},j=[],k,l,m,n,o,p,q,r,s,t,u;g[0]=c,c.delegateTarget=this;if(!i.preDispatch||i.preDispatch.call(this,c)!==!1){if(e&&(!c.button||c.type!==\"click\")){n=f(this),n.context=this.ownerDocument||this;for(m=c.target;m!=this;m=m.parentNode||this)if(m.disabled!==!0){p={},r=[],n[0]=m;for(k=0;k<e;k++)s=d[k],t=s.selector,p[t]===b&&(p[t]=s.quick?H(m,s.quick):n.is(t)),p[t]&&r.push(s);r.length&&j.push({elem:m,matches:r})}}d.length>e&&j.push({elem:this,matches:d.slice(e)});for(k=0;k<j.length&&!c.isPropagationStopped();k++){q=j[k],c.currentTarget=q.elem;for(l=0;l<q.matches.length&&!c.isImmediatePropagationStopped();l++){s=q.matches[l];if(h||!c.namespace&&!s.namespace||c.namespace_re&&c.namespace_re.test(s.namespace))c.data=s.data,c.handleObj=s,o=((f.event.special[s.origType]||{}).handle||s.handler).apply(q.elem,g),o!==b&&(c.result=o,o===!1&&(c.preventDefault(),c.stopPropagation()))}}i.postDispatch&&i.postDispatch.call(this,c);return c.result}},props:\"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),fixHooks:{},keyHooks:{props:\"char charCode key keyCode\".split(\" \"),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:\"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:\"focusin\"},blur:{delegateType:\"focusout\"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent(\"on\"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,\"form\"))return!1;f.event.add(this,\"click._submit keypress._submit\",function(a){var c=a.target,d=f.nodeName(c,\"input\")||f.nodeName(c,\"button\")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,\"submit._submit\",function(a){a._submit_bubble=!0}),d._submit_attached=!0)})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&f.event.simulate(\"submit\",this.parentNode,a,!0))},teardown:function(){if(f.nodeName(this,\"form\"))return!1;f.event.remove(this,\"._submit\")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type===\"checkbox\"||this.type===\"radio\")f.event.add(this,\"propertychange._change\",function(a){a.originalEvent.propertyName===\"checked\"&&(this._just_changed=!0)}),f.event.add(this,\"click._change\",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate(\"change\",this,a,!0))});return!1}f.event.add(this,\"beforeactivate._change\",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,\"change._change\",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate(\"change\",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!==\"radio\"&&b.type!==\"checkbox\")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,\"._change\");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:\"focusin\",blur:\"focusout\"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a==\"object\"){typeof c!=\"string\"&&(d=d||c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c==\"string\"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.origType+\".\"+e.namespace:e.origType,e.selector,e.handler);return this}if(typeof a==\"object\"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c==\"function\")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||\"**\",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,\"**\"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,\"lastToggle\"+a.guid)||0)%d;f._data(this,\"lastToggle\"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!=\"string\"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|['\"][^'\"]*['\"]|[^\\[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,d=\"sizcache\"+(Math.random()+\"\").replace(\".\",\"\"),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\\\/g,k=/\\r\\n/g,l=/\\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!=\"string\")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(\"\"),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]===\"~\"||w[0]===\"+\")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q=\"\",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)===\"[object Array]\")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!==\"\\\\\"){g[1]=(g[1]||\"\").replace(j,\"\"),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],\"\");break}}}}d||(d=typeof b.getElementsByTagName!=\"undefined\"?b.getElementsByTagName(\"*\"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)===\"\\\\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],\"\");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error(\"Syntax error, unrecognized expression: \"+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e=\"\";if(d){if(d===1||d===9||d===11){if(typeof a.textContent==\"string\")return a.textContent;if(typeof a.innerText==\"string\")return a.innerText.replace(k,\"\");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:[\"ID\",\"NAME\",\"TAG\"],match:{ID:/#((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,CLASS:/\\.((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,NAME:/\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)['\"]*\\]/,ATTR:/\\[\\s*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(?:(['\"])(.*?)\\3|(#?(?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)*)|)|)\\s*\\]/,TAG:/^((?:[\\w\\u00c0-\\uFFFF\\*\\-]|\\\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\\(\\s*(even|odd|(?:[+\\-]?\\d+|(?:[+\\-]?\\d*)?n\\s*(?:[+\\-]\\s*\\d+)?))\\s*\\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^\\-]|$)/,PSEUDO:/:((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)(?:\\((['\"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/},leftMatch:{},attrMap:{\"class\":\"className\",\"for\":\"htmlFor\"},attrHandle:{href:function(a){return a.getAttribute(\"href\")},type:function(a){return a.getAttribute(\"type\")}},relative:{\"+\":function(a,b){var c=typeof b==\"string\",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e");
        builder.append("&&m.filter(b,a,!0)},\">\":function(a,b){var c,d=typeof b==\"string\",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},\"\":function(a,b,c){var d,f=e++,g=x;typeof b==\"string\"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g(\"parentNode\",b,f,a,d,c)},\"~\":function(a,b,c){var d,f=e++,g=x;typeof b==\"string\"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g(\"previousSibling\",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!=\"undefined\"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!=\"undefined\"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute(\"name\")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!=\"undefined\")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=\" \"+a[1].replace(j,\"\")+\" \";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(\" \"+h.className+\" \").replace(/[\\t\\n\\r]/g,\" \").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,\"\")},TAG:function(a,b){return a[1].replace(j,\"\").toLowerCase()},CHILD:function(a){if(a[1]===\"nth\"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\\+|\\s*/g,\"\");var b=/(-?)(\\d*)(?:n([+\\-]?\\d*))?/.exec(a[2]===\"even\"&&\"2n\"||a[2]===\"odd\"&&\"2n+1\"||!/\\D/.test(a[2])&&\"0n+\"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,\"\");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||\"\").replace(j,\"\"),a[2]===\"~=\"&&(a[4]=\" \"+a[4]+\" \");return a},PSEUDO:function(b,c,d,e,f){if(b[1]===\"not\")if((a.exec(b[3])||\"\").length>1||/^\\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!==\"hidden\"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute(\"type\"),c=a.type;return a.nodeName.toLowerCase()===\"input\"&&\"text\"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"radio\"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"checkbox\"===a.type},file:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"file\"===a.type},password:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"password\"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b===\"input\"||b===\"button\")&&\"submit\"===a.type},image:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"image\"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b===\"input\"||b===\"button\")&&\"reset\"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b===\"input\"&&\"button\"===a.type||b===\"button\"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e===\"contains\")return(a.textContent||a.innerText||n([a])||\"\").indexOf(b[3])>=0;if(e===\"not\"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case\"only\":case\"first\":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k===\"first\")return!0;l=a;case\"last\":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case\"nth\":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute(\"id\")===b},TAG:function(a,b){return b===\"*\"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(\" \"+(a.className||a.getAttribute(\"class\"))+\" \").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+\"\",f=b[2],g=b[4];return d==null?f===\"!=\":!f&&m.attr?d!=null:f===\"=\"?e===g:f===\"*=\"?e.indexOf(g)>=0:f===\"~=\"?(\" \"+e+\" \").indexOf(g)>=0:g?f===\"!=\"?e!==g:f===\"^=\"?e.indexOf(g)===0:f===\"$=\"?e.substr(e.length-g.length)===g:f===\"|=\"?e===g||e.substr(0,g.length+1)===g+\"-\":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return\"\\\\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\\[]*\\])(?![^\\(]*\\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\\r|\\n)*?)/.source+o.match[r].source.replace(/\\\\(\\d+)/g,q));o.match.globalPOS=p;var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)===\"[object Array]\")Array.prototype.push.apply(d,a);else if(typeof a.length==\"number\")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement(\"div\"),d=\"script\"+(new Date).getTime(),e=c.documentElement;a.innerHTML=\"<a name='\"+d+\"'/>\",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!=\"undefined\"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!=\"undefined\"&&e.getAttributeNode(\"id\").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!=\"undefined\"&&a.getAttributeNode(\"id\");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement(\"div\");a.appendChild(c.createComment(\"\")),a.getElementsByTagName(\"*\").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]===\"*\"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML=\"<a href='#'></a>\",a.firstChild&&typeof a.firstChild.getAttribute!=\"undefined\"&&a.firstChild.getAttribute(\"href\")!==\"#\"&&(o.attrHandle.href=function(a){return a.getAttribute(\"href\",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement(\"div\"),d=\"__sizzle__\";b.innerHTML=\"<p class='TEST'></p>\";if(!b.querySelectorAll||b.querySelectorAll(\".TEST\").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\\w+$)|^\\.([\\w\\-]+$)|^#([\\w\\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b===\"body\"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!==\"object\"){var k=e,l=e.getAttribute(\"id\"),n=l||d,p=e.parentNode,q=/^\\s*[+~]/.test(b);l?n=n.replace(/'/g,\"\\\\$&\"):e.setAttribute(\"id\",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll(\"[id='\"+n+\"'] \"+b),f)}catch(r){}finally{l||k.removeAttribute(\"id\")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement(\"div\"),\"div\"),e=!1;try{b.call(c.documentElement,\"[test!='']:sizzle\")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\\=\\s*([^'\"\\]]*)\\s*\\]/g,\"='$1']\");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement(\"div\");a.innerHTML=\"<div class='test e'></div><div class='test'></div>\";if(!!a.getElementsByClassName&&a.getElementsByClassName(\"e\").length!==0){a.lastChild.className=\"e\";if(a.getElementsByClassName(\"e\").length===1)return;o.order.splice(1,0,\"CLASS\"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!=\"undefined\"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!==\"HTML\":!1};var y=function(a,b,c){var d,e=[],f=\"\",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,\"\");a=o.relative[a]?a+\"*\":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[\":\"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\\[\\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.globalPOS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!=\"string\")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack(\"\",\"find\",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),\"not\",a)},filter:function(a){return this.pushStack(T(this,a,!0),\"filter\",a)},is:function(a){return!!a&&(typeof a==\"string\"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!=\"string\"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,\"closest\",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a==\"string\")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a==\"string\"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,\"parentNode\")},parentsUntil:function(a,b,c){return f.dir(a,\"parentNode\",c)},next:function(a){return f.nth(a,2,\"nextSibling\")},prev:function(a){return f.nth(a,2,\"previousSibling\")},nextAll:function(a){return f.dir(a,\"nextSibling\")},prevAll:function(a){return f.dir(a,\"previousSibling\")},nextUntil:function(a,b,c){return f.dir(a,\"nextSibling\",c)},prevUntil:function(a,b,c){return f.dir(a,\"previousSibling\",c)},siblings:function(a){return f.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,\"iframe\")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d==\"string\"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(\",\"))}}),f.extend({filter:function(a,b,c){c&&(a=\":not(\"+a+\")\");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V=\"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",W=/ jQuery\\d+=\"(?:\\d+|null)\"/g,X=/^\\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,Z=/<([\\w:]+)/,$=/<tbody/i,_=/<|&#?\\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp(\"<(?:\"+V+\")[\\\\s/>]\",\"i\"),bd=/checked\\s*(?:[^=]|=\\s*.checked.)/i,be=/\\/(java|ecma)script/i,bf=/^\\s*<!(?:\\[CDATA\\[|\\-\\-)/,bg={option:[1,\"<select multiple='multiple'>\",\"</select>\"],legend:[1,\"<fieldset>\",\"</fieldset>\"],thead:[1,\"<table>\",\"</table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],col:[2,\"<table><tbody></tbody><colgroup>\",\"</colgroup></table>\"],area:[1,\"<map>\",\"</map>\"],_default:[0,\"\",\"\"]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,\"div<div>\",\"</div>\"]),f.fn.extend({text:function(a){return f.access(this,function(a){return a===b?f.text(this):this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a))},null,a,arguments.length)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,\"body\")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f\n.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,\"before\",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,\"after\",ar");
        builder.append("guments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName(\"*\")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName(\"*\"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){return f.access(this,function(a){var c=this[0]||{},d=0,e=this.length;if(a===b)return c.nodeType===1?c.innerHTML.replace(W,\"\"):null;if(typeof a==\"string\"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||[\"\",\"\"])[1].toLowerCase()]){a=a.replace(Y,\"<$1></$2>\");try{for(;d<e;d++)c=this[d]||{},c.nodeType===1&&(f.cleanData(c.getElementsByTagName(\"*\")),c.innerHTML=a);c=0}catch(g){}}c&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!=\"string\"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),\"replaceWith\",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j==\"string\"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,\"tr\");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,function(a,b){b.src?f.ajax({type:\"GET\",global:!1,url:b.src,async:!1,dataType:\"script\"}):f.globalEval((b.text||b.textContent||b.innerHTML||\"\").replace(bf,\"/*$0*/\")),b.parentNode&&b.parentNode.removeChild(b)})}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j==\"string\"&&j.length<512&&i===c&&j.charAt(0)===\"<\"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||f.isXMLDoc(a)||!bc.test(\"<\"+a.nodeName+\">\")?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g,h,i,j=[];b=b||c,typeof b.createElement==\"undefined\"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);for(var k=0,l;(l=a[k])!=null;k++){typeof l==\"number\"&&(l+=\"\");if(!l)continue;if(typeof l==\"string\")if(!_.test(l))l=b.createTextNode(l);else{l=l.replace(Y,\"<$1></$2>\");var m=(Z.exec(l)||[\"\",\"\"])[1].toLowerCase(),n=bg[m]||bg._default,o=n[0],p=b.createElement(\"div\"),q=bh.childNodes,r;b===c?bh.appendChild(p):U(b).appendChild(p),p.innerHTML=n[1]+l+n[2];while(o--)p=p.lastChild;if(!f.support.tbody){var s=$.test(l),t=m===\"table\"&&!s?p.firstChild&&p.firstChild.childNodes:n[1]===\"<table>\"&&!s?p.childNodes:[];for(i=t.length-1;i>=0;--i)f.nodeName(t[i],\"tbody\")&&!t[i].childNodes.length&&t[i].parentNode.removeChild(t[i])}!f.support.leadingWhitespace&&X.test(l)&&p.insertBefore(b.createTextNode(X.exec(l)[0]),p.firstChild),l=p.childNodes,p&&(p.parentNode.removeChild(p),q.length>0&&(r=q[q.length-1],r&&r.parentNode&&r.parentNode.removeChild(r)))}var u;if(!f.support.appendChecked)if(l[0]&&typeof (u=l.length)==\"number\")for(i=0;i<u;i++)bn(l[i]);else bn(l);l.nodeType?j.push(l):j=f.merge(j,l)}if(d){g=function(a){return!a.type||be.test(a.type)};for(k=0;j[k];k++){h=j[k];if(e&&f.nodeName(h,\"script\")&&(!h.type||be.test(h.type)))e.push(h.parentNode?h.parentNode.removeChild(h):h);else{if(h.nodeType===1){var v=f.grep(h.getElementsByTagName(\"script\"),g);j.splice.apply(j,[k+1,0].concat(v))}d.appendChild(h)}}}return j},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bp=/alpha\\([^)]*\\)/i,bq=/opacity=([^)]*)/,br=/([A-Z]|^ms)/g,bs=/^[\\-+]?(?:\\d*\\.)?\\d+$/i,bt=/^-?(?:\\d*\\.)?\\d+(?!px)[^\\d\\s]+$/i,bu=/^([\\-+])=([\\-+.\\de]+)/,bv=/^margin/,bw={position:\"absolute\",visibility:\"hidden\",display:\"block\"},bx=[\"Top\",\"Right\",\"Bottom\",\"Left\"],by,bz,bA;f.fn.css=function(a,c){return f.access(this,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)},a,c,arguments.length>1)},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=by(a,\"opacity\");return c===\"\"?\"1\":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{\"float\":f.support.cssFloat?\"cssFloat\":\"styleFloat\"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&\"get\"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h===\"string\"&&(g=bu.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h=\"number\");if(d==null||h===\"number\"&&isNaN(d))return;h===\"number\"&&!f.cssNumber[i]&&(d+=\"px\");if(!k||!(\"set\"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c===\"cssFloat\"&&(c=\"float\");if(g&&\"get\"in g&&(e=g.get(a,!0,d))!==b)return e;if(by)return by(a,c)},swap:function(a,b,c){var d={},e,f;for(f in b)d[f]=a.style[f],a.style[f]=b[f];e=c.call(a);for(f in b)a.style[f]=d[f];return e}}),f.curCSS=f.css,c.defaultView&&c.defaultView.getComputedStyle&&(bz=function(a,b){var c,d,e,g,h=a.style;b=b.replace(br,\"-$1\").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===\"\"&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b))),!f.support.pixelMargin&&e&&bv.test(b)&&bt.test(c)&&(g=h.width,h.width=c,c=e.width,h.width=g);return c}),c.documentElement.currentStyle&&(bA=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f==null&&g&&(e=g[b])&&(f=e),bt.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b===\"fontSize\"?\"1em\":f,f=g.pixelLeft+\"px\",g.left=c,d&&(a.runtimeStyle.left=d));return f===\"\"?\"auto\":f}),by=bz||bA,f.each([\"height\",\"width\"],function(a,b){f.cssHooks[b]={get:function(a,c,d){if(c)return a.offsetWidth!==0?bB(a,b,d):f.swap(a,bw,function(){return bB(a,b,d)})},set:function(a,b){return bs.test(b)?b+\"px\":b}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return bq.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||\"\")?parseFloat(RegExp.$1)/100+\"\":b?\"1\":\"\"},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?\"alpha(opacity=\"+b*100+\")\":\"\",g=d&&d.filter||c.filter||\"\";c.zoom=1;if(b>=1&&f.trim(g.replace(bp,\"\"))===\"\"){c.removeAttribute(\"filter\");if(d&&!d.filter)return}c.filter=bp.test(g)?g.replace(bp,e):g+\" \"+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){return f.swap(a,{display:\"inline-block\"},function(){return b?by(a,\"margin-right\"):a.style.marginRight})}})}),f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,\"display\"))===\"none\"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)}),f.each({margin:\"\",padding:\"\",border:\"Width\"},function(a,b){f.cssHooks[a+b]={expand:function(c){var d,e=typeof c==\"string\"?c.split(\" \"):[c],f={};for(d=0;d<4;d++)f[a+bx[d]+b]=e[d]||e[d-2]||e[0];return f}}});var bC=/%20/g,bD=/\\[\\]$/,bE=/\\r?\\n/g,bF=/#.*$/,bG=/^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg,bH=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bI=/^(?:about|app|app\\-storage|.+\\-extension|file|res|widget):$/,bJ=/^(?:GET|HEAD)$/,bK=/^\\/\\//,bL=/\\?/,bM=/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,bN=/^(?:select|textarea)/i,bO=/\\s+/,bP=/([?&])_=[^&]*/,bQ=/^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+))?)?/,bR=f.fn.load,bS={},bT={},bU,bV,bW=[\"*/\"]+[\"*\"];try{bU=e.href}catch(bX){bU=c.createElement(\"a\"),bU.href=\"\",bU=bU.href}bV=bQ.exec(bU.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!=\"string\"&&bR)return bR.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(\" \");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h=\"GET\";c&&(f.isFunction(c)?(d=c,c=b):typeof c==\"object\"&&(c=f.param(c,f.ajaxSettings.traditional),h=\"POST\"));var i=this;f.ajax({url:a,type:h,dataType:\"html\",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f(\"<div>\").append(c.replace(bM,\"\")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bN.test(this.nodeName)||bH.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bE,\"\\r\\n\")}}):{name:b.name,value:c.replace(bE,\"\\r\\n\")}}).get()}}),f.each(\"ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend\".split(\" \"),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each([\"get\",\"post\"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,\"script\")},getJSON:function(a,b,c){return f.get(a,b,c,\"json\")},ajaxSetup:function(a,b){b?b$(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b$(a,b);return a},ajaxSettings:{url:bU,isLocal:bI.test(bV[1]),global:!0,type:\"GET\",contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",processData:!0,async:!0,accepts:{xml:\"application/xml, text/xml\",html:\"text/html\",text:\"text/plain\",json:\"application/json, text/javascript\",\"*\":bW},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:\"responseXML\",text:\"responseText\"},converters:{\"* text\":a.String,\"text html\":!0,\"text json\":f.parseJSON,\"text xml\":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bY(bS),ajaxTransport:bY(bT),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||\"\",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?ca(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader(\"Last-Modified\"))f.lastModified[k]=y;if(z=v.getResponseHeader(\"Etag\"))f.etag[k]=z}if(a===304)w=\"notmodified\",o=!0;else try{r=cb(d,x),w=\"success\",o=!0}catch(A){w=\"parsererror\",u=A}}else{u=w;if(!w||a)w=\"error\",a<0&&(a=0)}v.status=a,v.statusText=\"\"+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger(\"ajax\"+(o?\"Success\":\"Error\"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger(\"ajaxComplete\",[v,d]),--f.active||f.event.trigger(\"ajaxStop\"))}}typeof a==\"object\"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks(\"once memory\"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bG.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||\"abort\",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+\"\").replace(bF,\"\").replace(bK,bV[1]+\"//\"),d.dataTypes=f.trim(d.dataType||\"*\").toLowerCase().split(bO),d.crossDomain==null&&(r=bQ.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bV[1]&&r[2]==bV[2]&&(r[3]||(r[1]===\"http:\"?80:443))==(bV[3]||(bV[1]===\"http:\"?80:443)))),d.data&&d.processData&&typeof d.data!=\"string\"&&(d.data=f.param(d.data,d.traditional)),bZ(bS,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bJ.test(d.type),t&&f.active++===0&&f.event.trigger(\"ajaxStart\");if(!d.hasContent){d.data&&(d.url+=(bL.test(d.url)?\"&\":\"?\")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bP,\"$1_=\"+x);d.url=y+(y===d.url?(bL.test(d.url)?\"&\":\"?\")+\"_=\"+x:\"\")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader(\"Content-Type\",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader(\"If-Modified-Since\",f.lastModified[k]),f.etag[k]&&v.setRequestHeader(\"If-None-Match\",f.etag[k])),v.setRequestHeader(\"Accept\",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!==\"*\"?\", \"+bW+\"; q=0.01\":\"\"):d.accepts[\"*\"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=bZ(bT,d,c,v);if(!p)w(-1,\"No Transport\");else{v.readyState=1,t&&g.trigger(\"ajaxSend\",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort(\"timeout\")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+\"=\"+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)b_(g,a[g],c,e);return d.join(\"&\").replace(bC,\"+\")}}),f.extend({active:0,lastModified:{},etag:{}});var cc=f.now(),cd=/(\\=)\\?(&|$)|\\?\\?/i;f.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){return f.expando+\"_\"+cc++}}),f.ajaxPrefilter(\"json jsonp\",function(b,c,d){var e=typeof b.data==\"string\"&&/^application\\/x\\-www\\-form\\-urlencoded/.test(b.contentType);if(b.dataTypes[0]===\"jsonp\"||b.jsonp!==!1&&(cd.test(b.url)||e&&cd.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l=\"$1\"+h+\"$2\";b.jsonp!==!1&&(j=j.replace(cd,l),b.url===j&&(e&&(k=k.replace(cd,l)),b.data===k&&(j+=(/\\?/.test(j)?\"&\":\"?\")+b.jsonp+\"=\"+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters[\"script json\"]=function(){g||f.error(h+\" was not called\");return g[0]},b.dataTypes[0]=\"json\";return\"script\"}}),f.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/javascript|ecmascript/},converters:{\"text script\":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter(\"script\",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type=\"GET\",a.global=!1)}),f.ajaxTransport(\"script\",function(a){if(a.cross");
        builder.append("Domain){var d,e=c.head||c.getElementsByTagName(\"head\")[0]||c.documentElement;return{send:function(f,g){d=c.createElement(\"script\"),d.async=\"async\",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,\"success\")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var ce=a.ActiveXObject?function(){for(var a in cg)cg[a](0,1)}:!1,cf=0,cg;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ch()||ci()}:ch,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&\"withCredentials\"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e[\"X-Requested-With\"]&&(e[\"X-Requested-With\"]=\"XMLHttpRequest\");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,ce&&delete cg[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n);try{m.text=h.responseText}catch(a){}try{k=h.statusText}catch(o){k=\"\"}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cf,ce&&(cg||(cg={},f(a).unload(ce)),cg[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var cj={},ck,cl,cm=/^(?:toggle|show|hide)$/,cn=/^([+\\-]=)?([\\d+.\\-]+)([a-z%]*)$/i,co,cp=[[\"height\",\"marginTop\",\"marginBottom\",\"paddingTop\",\"paddingBottom\"],[\"width\",\"marginLeft\",\"marginRight\",\"paddingLeft\",\"paddingRight\"],[\"opacity\"]],cq;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(ct(\"show\",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,\"olddisplay\")&&e===\"none\"&&(e=d.style.display=\"\"),(e===\"\"&&f.css(d,\"display\")===\"none\"||!f.contains(d.ownerDocument.documentElement,d))&&f._data(d,\"olddisplay\",cu(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===\"\"||e===\"none\")d.style.display=f._data(d,\"olddisplay\")||\"\"}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(ct(\"hide\",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,\"display\"),e!==\"none\"&&!f._data(d,\"olddisplay\")&&f._data(d,\"olddisplay\",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display=\"none\");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a==\"boolean\";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(\":hidden\");f(this)[b?\"show\":\"hide\"]()}):this.animate(ct(\"toggle\",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(\":hidden\").css(\"opacity\",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(\":hidden\"),g,h,i,j,k,l,m,n,o,p,q;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]);if((k=f.cssHooks[g])&&\"expand\"in k){l=k.expand(a[g]),delete a[g];for(i in l)i in a||(a[i]=l[i])}}for(g in a){h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||\"swing\";if(h===\"hide\"&&d||h===\"show\"&&!d)return b.complete.call(this);c&&(g===\"height\"||g===\"width\")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,\"display\")===\"inline\"&&f.css(this,\"float\")===\"none\"&&(!f.support.inlineBlockNeedsLayout||cu(this.nodeName)===\"inline\"?this.style.display=\"inline-block\":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow=\"hidden\");for(i in a)j=new f.fx(this,b,i),h=a[i],cm.test(h)?(q=f._data(this,\"toggle\"+i)||(h===\"toggle\"?d?\"show\":\"hide\":0),q?(f._data(this,\"toggle\"+i,q===\"show\"?\"hide\":\"show\"),j[q]()):j[h]()):(m=cn.exec(h),n=j.cur(),m?(o=parseFloat(m[2]),p=m[3]||(f.cssNumber[i]?\"\":\"px\"),p!==\"px\"&&(f.style(this,i,(o||1)+p),n=(o||1)/j.cur()*n,f.style(this,i,n+p)),m[1]&&(o=(m[1]===\"-=\"?-1:1)*o+n),j.custom(n,o,p)):j.custom(n,h,\"\"));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!=\"string\"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||\"fx\",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(\".run\")===b.length-4&&h(this,g,b);else g[b=a+\".run\"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:ct(\"show\",1),slideUp:ct(\"hide\",1),slideToggle:ct(\"toggle\",1),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a==\"object\"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration==\"number\"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue=\"fx\";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a){return a},swing:function(a){return-Math.cos(a*Math.PI)/2+.5}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b===\"auto\"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cq||cr(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?\"\":\"px\"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){f._data(e.elem,\"fxshow\"+e.prop)===b&&(e.options.hide?f._data(e.elem,\"fxshow\"+e.prop,e.start):e.options.show&&f._data(e.elem,\"fxshow\"+e.prop,e.end))},h()&&f.timers.push(h)&&!co&&(co=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,\"fxshow\"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop===\"width\"||this.prop===\"height\"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,\"fxshow\"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cq||cr(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each([\"\",\"X\",\"Y\"],function(a,b){h.style[\"overflow\"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,\"fxshow\"+b,!0),f.removeData(h,\"toggle\"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(co),co=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,\"opacity\",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(cp.concat.apply([],cp),function(a,b){b.indexOf(\"margin\")&&(f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)})}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cv,cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;\"getBoundingClientRect\"in c.documentElement?cv=function(a,b,c,d){try{d=a.getBoundingClientRect()}catch(e){}if(!d||!f.contains(c,a))return d?{top:d.top,left:d.left}:{top:0,left:0};var g=b.body,h=cy(b),i=c.clientTop||g.clientTop||0,j=c.clientLeft||g.clientLeft||0,k=h.pageYOffset||f.support.boxModel&&c.scrollTop||g.scrollTop,l=h.pageXOffset||f.support.boxModel&&c.scrollLeft||g.scrollLeft,m=d.top+k-i,n=d.left+l-j;return{top:m,left:n}}:cv=function(a,b,c){var d,e=a.offsetParent,g=a,h=b.body,i=b.defaultView,j=i?i.getComputedStyle(a,null):a.currentStyle,k=a.offsetTop,l=a.offsetLeft;while((a=a.parentNode)&&a!==h&&a!==c){if(f.support.fixedPosition&&j.position===\"fixed\")break;d=i?i.getComputedStyle(a,null):a.currentStyle,k-=a.scrollTop,l-=a.scrollLeft,a===e&&(k+=a.offsetTop,l+=a.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(a.nodeName))&&(k+=parseFloat(d.borderTopWidth)||0,l+=parseFloat(d.borderLeftWidth)||0),g=e,e=a.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&d.overflow!==\"visible\"&&(k+=parseFloat(d.borderTopWidth)||0,l+=parseFloat(d.borderLeftWidth)||0),j=d}if(j.position===\"relative\"||j.position===\"static\")k+=h.offsetTop,l+=h.offsetLeft;f.support.fixedPosition&&j.position===\"fixed\"&&(k+=Math.max(c.scrollTop,h.scrollTop),l+=Math.max(c.scrollLeft,h.scrollLeft));return{top:k,left:l}},f.fn.offset=function(a){if(arguments.length)return a===b?this:this.each(function(b){f.offset.setOffset(this,a,b)});var c=this[0],d=c&&c.ownerDocument;if(!d)return null;if(c===d.body)return f.offset.bodyOffset(c);return cv(c,d,d.documentElement)},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,\"marginTop\"))||0,c+=parseFloat(f.css(a,\"marginLeft\"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,\"position\");d===\"static\"&&(a.style.position=\"relative\");var e=f(a),g=e.offset(),h=f.css(a,\"top\"),i=f.css(a,\"left\"),j=(d===\"absolute\"||d===\"fixed\")&&f.inArray(\"auto\",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),\"using\"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,\"marginTop\"))||0,c.left-=parseFloat(f.css(a,\"marginLeft\"))||0,d.top+=parseFloat(f.css(b[0],\"borderTopWidth\"))||0,d.left+=parseFloat(f.css(b[0],\"borderLeftWidth\"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,\"position\")===\"static\")a=a.offsetParent;return a})}}),f.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(a,c){var d=/Y/.test(c);f.fn[a]=function(e){return f.access(this,function(a,e,g){var h=cy(a);if(g===b)return h?c in h?h[c]:f.support.boxModel&&h.document.documentElement[e]||h.document.body[e]:a[e];h?h.scrollTo(d?f(h).scrollLeft():g,d?g:f(h).scrollTop()):a[e]=g},a,e,arguments.length,null)}}),f.each({Height:\"height\",Width:\"width\"},function(a,c){var d=\"client\"+a,e=\"scroll\"+a,g=\"offset\"+a;f.fn[\"inner\"+a]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,c,\"padding\")):this[c]():null},f.fn[\"outer\"+a]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,c,a?\"margin\":\"border\")):this[c]():null},f.fn[c]=function(a){return f.access(this,function(a,c,h){var i,j,k,l;if(f.isWindow(a)){i=a.document,j=i.documentElement[d];return f.support.boxModel&&j||i.body&&i.body[d]||j}if(a.nodeType===9){i=a.documentElement;if(i[d]>=i[e])return i[d];return Math.max(a.body[e],i[e],a.body[g],i[g])}if(h===b){k=f.css(a,c),l=parseFloat(k);return f.isNumeric(l)?l:k}f(a).css(c,h)},c,a,arguments.length,null)}}),a.jQuery=a.$=f,typeof define==\"function\"&&define.amd&&define.amd.jQuery&&define(\"jquery\",[],function(){return f})})(window);");
        return builder.toString();
      }
      public String getName() {
        return "jquery";
      }
    }
    ;
  }
  private static class jqueryInitializer {
    static {
      _instance0.jqueryInitializer();
    }
    static com.google.gwt.resources.client.TextResource get() {
      return jquery;
    }
  }
  public com.google.gwt.resources.client.TextResource jquery() {
    return jqueryInitializer.get();
  }
  private static java.util.HashMap<java.lang.String, com.google.gwt.resources.client.ResourcePrototype> resourceMap;
  private static com.google.gwt.resources.client.TextResource defaultTheme;
  private static com.google.gwt.resources.client.TextResource exporting;
  private static com.google.gwt.resources.client.TextResource highcharts;
  private static com.google.gwt.resources.client.TextResource highchartsMore;
  private static com.google.gwt.resources.client.TextResource jquery;
  
  public ResourcePrototype[] getResources() {
    return new ResourcePrototype[] {
      defaultTheme(), 
      exporting(), 
      highcharts(), 
      highchartsMore(), 
      jquery(), 
    };
  }
  public ResourcePrototype getResource(String name) {
    if (GWT.isScript()) {
      return getResourceNative(name);
    } else {
      if (resourceMap == null) {
        resourceMap = new java.util.HashMap<java.lang.String, com.google.gwt.resources.client.ResourcePrototype>();
        resourceMap.put("defaultTheme", defaultTheme());
        resourceMap.put("exporting", exporting());
        resourceMap.put("highcharts", highcharts());
        resourceMap.put("highchartsMore", highchartsMore());
        resourceMap.put("jquery", jquery());
      }
      return resourceMap.get(name);
    }
  }
  private native ResourcePrototype getResourceNative(String name) /*-{
    switch (name) {
      case 'defaultTheme': return this.@com.vaadin.addon.charts.client.HighchartResources::defaultTheme()();
      case 'exporting': return this.@com.vaadin.addon.charts.client.HighchartResources::exporting()();
      case 'highcharts': return this.@com.vaadin.addon.charts.client.HighchartResources::highcharts()();
      case 'highchartsMore': return this.@com.vaadin.addon.charts.client.HighchartResources::highchartsMore()();
      case 'jquery': return this.@com.vaadin.addon.charts.client.HighchartResources::jquery()();
    }
    return null;
  }-*/;
}
